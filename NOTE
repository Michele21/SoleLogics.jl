# Notes about SoleLogics structure.

##########################
#        syntax.jl       #
##########################

For example, the AND operator can be instantiated as `NamedOperator{:∧}`.

struct NamedOperator{T} <: AbstractOperator end

top = NamedOperator{:⊤}
ariety(top) = 0

bottom = NamedOperator{:⊥}
ariety(bottom) = 0

conjunction = NamedOperator{:∧}
ariety(conjunction) = 2

disjunction = NamedOperator{:∨}

ariety(disjunction) = 2

implication = NamedOperator{:⟹}
ariety(implication) = 2

BaseOperators = Union{top, bottom, conjunction, disjunction, implication}






struct ExplicitAlphabet{A} <: AbstractAlphabet{A}
    alphabet::Vector{<:A} # TODO: choose correct type here
end
length(EA::ExplicitAlphabet{A}) where {A} = length(EA.alphabet)
...

# This alphabet leverages generators to dynamically manipulate letters
struct InfiniteAlphabet{A} <: AbstractAlphabet{A}
    # ...
end
isfinite(::InfiniteAlphabet) = false
isiterable(::InfiniteAlphabet) = false

# This alphabet is not complete and its dispatches requires more arguments to work
struct NonCompleteDimensionalAlphabet{A} <: AbstractAlphabet{A}
    #
end
isfinite = false
isiterable = false
Base.length



# AbstractAlphabet children types
ExplicitAlphabet{A} # Wraps a Vector{Letter{A}}
LazyAlphabet
InfiniteAlphabet{A}
NonCompleteDimensionalAlphabet

    #### Alphabet: new things (5 december) ####
    AbstractDimensionaAlphabet
        DimensionalAlphabet # Wraps a Vector{L}
        FullUmbounded       # 4 parameters are combined using product
                            #but A is infinite (thresholds are needed to enumerate things)



# rand(Grammar, rng) dispatch to generate a new valid formula

ExplicitCompleteGrammar{At, O}
    - alphabet

    #### Grammar: new things (5 december) ####
    BNFCompleteGrammar # Backus Naur Form

##########################
#      semantics.jl      #
##########################

#### Algebra ####

BooleanAlgebra # Singleton whose domain is [true,false], domain_type is Bool and iscrisp is true

##########################
#        base.jl        #
##########################

#### Logic ####

BaseLogic{At, O, Al}
    - grammar::G{At, O}

#### Model ####
Model{L}
    goes_with(::Model, ::Logic) = false
    check(Formula, Model)
    provides_specific_check(...) = false
    check(Formula, Model, args...) = provides_specific_check(...) ? error() : error()

PropositionalLogic{At, O, Al} <: Logic{At, O, Al}

TruthDictionary{L} <: Model{L}
    goes_with(::PropositionalLogic) = true
    check(::Formula{L}, ::TruthDictionary)
    check(::SyntaxNode{...}, ::TruthDictionary) # SyntaxNode is converted to Formula, then the new dispatch is applied
    check(::Letter, ::TruthDict)

#### Relations ####
Relation
RelationalOperator
    relation(op::RelationalOperator) = op.relation
DiamondRelationalOperator
BoxRelationalOperator
    ismodal(...)


To be continued ...

##########################
#        traits.jl       #
##########################
# Things that could be moved in a traits.jl file.

isinfinite(...)
isinfinite(...)

isconstant(...)
isunary(...)
isbinary(...)

ismodal(...)

iscrisp()
isfuzzy()

letters()

##########################
#       Still TODO       #
##########################
Kripke Model (single/multi)
Ontologies (Geometry, Dimensional)
Model checking
