<!-- Draft README.md 
# Usage

## Parsing Formulas
Consider the string representation of a logical formula (in infix notation, e.g., "p∧q" or in function notation, e.g. "∧(p,q)". Such expressions can easily be parsed to a `SyntaxTree` representation using the method `parsebaseformula`. As you can see from the documentation, it is highly customizable, allowing parsing custom-defined operators and changing how recognized propositions must be interpreted (e.g. in "true∧false" propositions are booleans, while in "1∧0" they are integers).


The `SyntaxTree` returned by `parsebaseformula` can be paired with a logic (a grammar and an algebra) using `parsebaseformula`, thus returning a Formula: the latter method disposes of the same flexibility of `parsetree` TODO not true.

## Generating random formulas
Random formulas generation is provided by the following methods:
- randformula (which returns a SyntaxTree);
- randbaseformula (which returns a SyntaxTree anchored to a Logic, thus, a Formula).

Both allow customizing the generation process by setting an alphabet (that is, which propositional letters are in play), an operators vector, the maximum height of the SyntaxTree and the maximum modal depth (that is, the maximum number of modal operators, if any, in each SyntaxTree path).

Notes for Giovanni; 
1) many important definitions are introduced here: is this the correct place to explain them or it's better to just link the documentation? 
2) I'm still working on putting a modal_depth parameter in both randbaseformula and randformula 
3) As stated in AbstractSyntaxStructure docstring, classically a logical formula is implemented using a tree structure (an AST) but other representations may exist: I guess we could add a "randnormalform" method

## Generating random interpretations
Kripke structures generation is provided by gen_kstructure interface. As you can see from the documentation, internally it builds up a random directed graph structure (using some, possibly custom algorithm). The adjacency list obtained is enriched with informations to obtain a so called Kripke frame; this is done by taking each vertex in the list and

- converting it into a World structure;
- defining which worlds are accessible from this following a specific relation (I'm trying to summarize both the concept of binary accessiblity relation R and the accessibles method...).

Finally, pairing each world in the Kripke frame with a list of propositional letters (this goes undeer the name of world valuation function), a Kripke structure is returned by gen_kstructure.

## Model checking

## Interpretation sets

 -->


propositional-logic: 

julia> t2 = TruthDict(["a" => true, "b" => false, "c" => true])
TruthDict wrapping:
Dict{Proposition{String}, Bool} with 3 entries:
  Proposition{String}("c") => 1
  Proposition{String}("b") => 0
  Proposition{String}("a") => 1

1) rename TruthDict in TruthTable
then, change 

function Base.show(
    io::IO,
    i::TruthDict{A,T,D},
) where {A,T<:TruthValue,D<:AbstractDict{<:Proposition{<:A},T}}
    # println(io, "TruthDict{$(A),$(T),$(D)} wrapping:")
    println(io, "TruthDict wrapping:")
    Base.display(i.truth)
end

to be 

" | p | q | r | s | "

-------------------------------------------------------------------------------------------

syntaxstring:

DONE: 0) clonare e istanziare in dev-v0.9.1 (e tenerlo checkouttato lì) SoleBase e SoleData.

1) rinominare parentheses in parentheses, e parenthesis in paranthesis.
	Questo va fatto in SoleLogics (dev-v0.9.1), e SoleModels (dev-v0.9.1)

2) rendere più leggibile syntaxstring (di default, NON è allparentheses.)
	2.1) scegliere con parametro "allparentheses"
	2.2) TESTARE (cioè, vedere che i test girino già come sono adesso)
	2.3) testare anche, ovviamente, con allparentheses=true

3) vedi propositional-logic sopra

4) Leggere documentazione SoleData (controllare anche grammatica) e vedere se ho capito
e cosa trasporterei in SoleLogics. 
	4.1) Eventualmente fare un branch personale