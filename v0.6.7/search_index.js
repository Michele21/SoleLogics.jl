var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleLogics","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section you will learn about the main building blocks of SoleLogics. Their definition, usage examples and how to customize them to your own needings. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In a few words, you can consider this package as divided into two halves. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The syntactical half deals with defining data structures to represent logical constructs such as assertions, logical constants, alphabets, grammars, crisp and fuzzy algebras, formulas etc. A consistent part of SoleLogics is devoted to randomly generate such structures, as well as parse and minimize formulas.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The semantic half deals with defining which rules must be applied when interpreting a logical formulas. The \"semantic heart\" of SoleLogics is its finite model checking algorithm, whose purpose is to efficiently check whether a formula is satisfied by an interpretation or not.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Please, feel free to use the following tree structures to orient yourself in the reading of this section. More pieces will be added to this type-hierarchy tree in the following sections.","category":"page"},{"location":"getting-started/#Syntax-and-Semantics-tree-type-hierarchies","page":"Getting started","title":"Syntax and Semantics tree type hierarchies","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Syntactical\nFormula\nAbstractSyntaxStructure\nSyntaxTree (e.g., ¬p ∧ q → s)\nSyntaxLeaf\nAtom (e.g., p, q)\nTruth (e.g., ⊤, ⊥)\nSyntaxBranch (e.g., p ∧ q)\n... (more on Formula subtypes in the next chapters)\nConnective (e.g., ∧, ∨, ¬, →)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractInterpretation (e.g., p is ⊤, equivalent to p is true in boolean logic)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Also, two union types are defined:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Operator, that is, Union{Connective,Truth}, \nSyntaxToken, that is, Union{Atom,Connective}.  ","category":"page"},{"location":"getting-started/#syntactical-base-definitions","page":"Getting started","title":"Syntax Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Syntactical","category":"page"},{"location":"getting-started/#SoleLogics.Syntactical","page":"Getting started","title":"SoleLogics.Syntactical","text":"abstract type Syntactical end\n\nMaster abstract type for all syntactical objects (e.g., formulas, connectives).\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Connective","category":"page"},{"location":"getting-started/#SoleLogics.Connective","page":"Getting started","title":"SoleLogics.Connective","text":"abstract type Connective <: Syntactical end\n\nAbstract type for logical connectives, that are used to express non-atomic statements; for example, CONJUNCTION, DISJUNCTION, NEGATION and IMPLICATION (stylized as ∧, ∨, ¬ and →).\n\nImplementation\n\nWhen implementing a new type C for a connective, please define its arity. For example, with a binary operator (e.g., ∨ or ∧):\n\narity(::C) = 2\n\nWhen implementing a new type C for a commutative connective with arity higher than 1, please provide a method iscommutative(::C). This can speed up model checking operations.\n\nWhen implementing a custom binary connective, one can override the default precedence and associativity (see here. If the custom connective is a NamedConnective and renders as something considered as a math symbol (for example, ⊙, see https://stackoverflow.com/a/60321302/5646732), by the Julia parser, Base.operator_precedence and Base.operator_associativity are used to define these behaviors, and you might want to avoid providing these methods at all.\n\nThe semantics of a propositional connective can be specified via collatetruth (see example below); in principle, the definition can rely on the partial order between truth values (specified via Base.isless).\n\nHere is an example of a custom implementation of the xor (⊻) Boolean operator.\n\nimport SoleLogics: arity, iscommutative, collatetruth\nconst ⊻ = SoleLogics.NamedConnective{:⊻}()\nSoleLogics.arity(::typeof(⊻)) = 2\nSoleLogics.iscommutative(::typeof(⊻)) = true\nSoleLogics.collatetruth(::typeof(⊻), (t1, t2)::NTuple{N,T where T<:BooleanTruth}) where {N} = (count(istop, (t1, t2)) == 1)\n\nNote that collatetruth must be defined at least for some truth value types T via methods accepting an NTuple{arity,T} as a second argument.\n\nTo make the operator work with incomplete interpretations (e.g., when the Truth value for an atom is not known), simplification rules for NTuple{arity,T where T<:Formula}s should be provided via methods for simplify. For example, these rules suffice for simplifying xors between Top/Bot`s, and other formulas:\n\nimport SoleLogics: simplify\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Top,Top}) = Bot\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Top,Bot}) = Top\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Bot,Top}) = Top\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Bot,Bot}) = Bot\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Top,Formula}) = ¬t2\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Bot,Formula}) = t2\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Formula,Top}) = ¬t1\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Formula,Bot}) = t1\n\nBeware of dispatch ambiguities!\n\nSee also arity, SyntaxBranch, associativity, precedence, check, iscommutative, NamedConnective, Syntactical.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"If the definition above overwhelms you, don't worry: it will be clearer later. For now we are simply interested in understanding that Connectives are simply symbols used to concatenate other logical constructs with each other. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Later, we will see some interesting example about how to equip these symbols with semantics, that is, what rules should be applied when interpreting connectives in a generic Formula. We will also understand how to define our own custom connectives.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"arity","category":"page"},{"location":"getting-started/#SoleLogics.arity","page":"Getting started","title":"SoleLogics.arity","text":"arity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\narity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\narity(::AbstractRelation)::Integer\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The vast majority of data structures involved in encoding a logical formula, are children of the Formula abstract type. When such data structures purely represents tree-shaped data structures (or single nodes in them), then they are also children of the AbstractSyntaxStructure abstract type.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Formula","category":"page"},{"location":"getting-started/#SoleLogics.Formula","page":"Getting started","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), AbstractSyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nSee also tree, AbstractSyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following methods define Formula interface.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"tree(φ::Formula)\nheight(φ::Formula)\ntokens(φ::Formula)","category":"page"},{"location":"getting-started/#SoleLogics.tree-Tuple{Formula}","page":"Getting started","title":"SoleLogics.tree","text":"tree(φ::Formula)::SyntaxTree\n\nReturn the SyntaxTree representation of a formula; note that this is equivalent to Base.convert(SyntaxTree, φ).\n\nSee also Formula, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.height-Tuple{Formula}","page":"Getting started","title":"SoleLogics.height","text":"height(φ::Formula)::Integer\n\nReturn the height of a formula in its syntax tree representation.\n\nSee also SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.tokens-Tuple{Formula}","page":"Getting started","title":"SoleLogics.tokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Now, let us see how to simply merge togheter Syntactical elements.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"composeformulas(c::Connective, φs::NTuple{N,F}) where {N,F<:Formula}","category":"page"},{"location":"getting-started/#SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, Tuple{Vararg{F, N}}}} where {N, F<:Formula}","page":"Getting started","title":"SoleLogics.composeformulas","text":"composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\n\nReturn a new formula of type F by composing N formulas of the same type via a connective c. This function allows one to use connectives for flexibly composing formulas (see Implementation section).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxBranch: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;) (see https://stackoverflow.com/a/60321302/5646732)\nSyntaxBranch: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxBranch: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon composeformulas lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (c::Connective)(φs::NTuple{N,Formula}) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of Formula, a new method for composeformulas should be defined, together with promotion from/to other Formulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective c, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nnote: Note\nTo allow for the composition of Formulas of different types, promotion rules should be provided.\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We are ready to see how logical formulas are represented using syntax trees","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractSyntaxStructure\nSyntaxTree\nchildren(φ::SyntaxTree)\ntoken(φ::SyntaxTree)\narity(φ::SyntaxTree)\n\nSyntaxLeaf\nSyntaxToken\ndual(t::SyntaxToken)\nBase.in(tok::SyntaxToken, φ::SyntaxTree)\n\nAtom","category":"page"},{"location":"getting-started/#SoleLogics.AbstractSyntaxStructure","page":"Getting started","title":"SoleLogics.AbstractSyntaxStructure","text":"abstract type AbstractSyntaxStructure <: Formula end\n\nAbstract type for the purely-syntactic component of a logical formula (e.g., no fancy memoization structure associated). The typical representation is the SyntaxTree, however, different implementations can cover specific syntactic forms (e.g., conjunctive or disjunctive normal forms).\n\nSee also Formula, AbstractLogic, SyntaxTree, tree.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.SyntaxTree","page":"Getting started","title":"SoleLogics.SyntaxTree","text":"abstract type SyntaxTree <: AbstractSyntaxStructure end\n\nAbstract type for syntax trees; that is, syntax leaves (see SyntaxLeaf, such as Truth values and Atoms), and their composition via Connectives (i.e., SyntaxBranch).\n\nNote that SyntaxTrees are ranked trees, and (should) adhere to the AbstractTrees interface.\n\nSee also SyntaxLeaf, SyntaxBranch, AbstractSyntaxStructure, Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#AbstractTrees.children-Tuple{SyntaxTree}","page":"Getting started","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nGetter for φ children.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.token-Tuple{SyntaxTree}","page":"Getting started","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nGetter for the token wrapped in a SyntaxTree.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.arity-Tuple{SyntaxTree}","page":"Getting started","title":"SoleLogics.arity","text":"arity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.SyntaxLeaf","page":"Getting started","title":"SoleLogics.SyntaxLeaf","text":"abstract type SyntaxLeaf <: AbstractSyntaxStructure end\n\nAn atomic logical element, like a Truth value or an Atom. SyntaxLeafs have arity equal to zero, meaning that they are not allowed to have children in tree-like syntactic structures.\n\nSee also AbstractSyntaxStructure,  arity, SyntaxBranch.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.SyntaxToken","page":"Getting started","title":"SoleLogics.SyntaxToken","text":"const SyntaxToken = Union{Connective,SyntaxLeaf}\n\nUnion type for values wrapped in SyntaxTree nodes.\n\nSee also SyntaxTree, SyntaxLeaf, Connective.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.dual-Tuple{SyntaxToken}","page":"Getting started","title":"SoleLogics.dual","text":"dual(tok::SyntaxToken)\n\nReturn the dual of a syntax token.\n\nIf tok is an Operator of arity n, the dual dtok is such that, on a Boolean algebra, tok(ch_1, ..., ch_n) ≡ ¬dtok(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q) (De Morgan's law). Duality also applies to operators with existential/universal semantics (◊/□), to Truth values (⊤/⊥), and to Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Base.in-Tuple{SyntaxToken, SyntaxTree}","page":"Getting started","title":"Base.in","text":"Base.in(tok::SyntaxToken, φ::Formula)::Bool\n\nReturn whether a syntax token appears in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.Atom","page":"Getting started","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, atoms, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Truth","category":"page"},{"location":"getting-started/#SoleLogics.Truth","page":"Getting started","title":"SoleLogics.Truth","text":"abstract type Truth <: SyntaxLeaf end\n\nAbstract type for syntax leaves representing values of a lattice algebra. In Boolean logic, the two BooleanTruth values Top and Bot are used.\n\nSee also Top, Bot, BooleanTruth.\n\nImplementation\n\nA three-valued algebra, that is, an algebra with three truth values (top, bottom and unknown), can be based on the following Truth value definitions:\n\nimport Base: isless\n\nabstract type ThreeVTruth <: Truth end\n\nstruct ThreeTop <: ThreeVTruth end\nconst ⫪ = ThreeTop() # Note that ⊤ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeTop; kwargs...) = \"⫪\"\n\nstruct ThreeBot <: ThreeVTruth end\nconst ⫫ = ThreeBot() # Note that ⊥ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeBot; kwargs...) = \"⫫\"\n\nstruct ThreeUnknown <: ThreeVTruth end\nconst υ = ThreeUnknown()\nsyntaxstring(::ThreeUnknown; kwargs...) = \"υ\"\n\nistop(t::ThreeTop) = true\nisbot(t::ThreeBot) = true\n\nBase.isless(::ThreeBot, ::ThreeTop) = true\nBase.isless(::ThreeBot, ::ThreeUnknown) = true\nBase.isless(::ThreeUnknown, ::ThreeTop) = true\nBase.isless(::ThreeTop, ::ThreeBot) = false\nBase.isless(::ThreeUnknown, ::ThreeBot) = false\nBase.isless(::ThreeTop, ::ThreeUnknown) = false\n\nNote that Base.isless is used to define the (partial) order between Truth values.\n\nSee also Connective, BooleanTruth.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Similarly to the Connectives case, Truth explanation could be unfamiliar at first sight. At the moment, what is of our interest is that SoleLogics provides us a simple interface to create custom, complex at will, algebras without worrying about adapting all the underlying algorithms (e.g., formulas generation, parsing, model checking etc.).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"istop(t::Truth)\nisbot(t::Truth)\ntruthsupertype(T::Type{<:Truth})","category":"page"},{"location":"getting-started/#SoleLogics.istop-Tuple{Truth}","page":"Getting started","title":"SoleLogics.istop","text":"istop(::Truth)::Bool\n\nReturn true if the Truth value is the top of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nistop(t::Bool)::Bool = (t == true)\n\nSee also isbot, Truth.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.isbot-Tuple{Truth}","page":"Getting started","title":"SoleLogics.isbot","text":"isbot(::Truth)::Bool\n\nReturn true if the Truth value is the bottom of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nisbot(t::Bool)::Bool = (t == false)\n\nSee also istop, Truth.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.truthsupertype-Tuple{Type{<:Truth}}","page":"Getting started","title":"SoleLogics.truthsupertype","text":"truthsupertype(T::Type{<:Truth})::Type\n\nReturn the supertype of a Truth type that includes all values of the same algebra.\n\nExamples\n\njulia> truthsupertype(typeof(TOP))\nBooleanTruth\n\nSee also Truth, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The union of Connectives and Truth values are exactly what is called logical operators, or simply Operator. In SoleLogics, logical operators are splitted in two parts to highlight some differences that always holds (e.g., truth values arity is always 0, while connectives arity is always greater than 0); apart from this technical decision, many dispatches are defined using the more general union type Operator.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Operator","category":"page"},{"location":"getting-started/#SoleLogics.Operator","page":"Getting started","title":"SoleLogics.Operator","text":"const Operator = Union{Connective,Truth}\n\nUnion type for logical constants of any ariety (zero for Truth values, non-zero for Connectives).\n\nSee also Connective, Truth.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"An Operator can be used to compose syntax tokens (e.g., Atoms), SyntaxTrees and/or Formulas.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"    ¬(Atom(1)) ∨ Atom(1) ∧ ⊤\n    ∧(⊤,⊤)\n    ⊤()","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The internal nodes in a SyntaxTree definitely have ariety greater than 0, and thus, cannot wrap Atoms nor Truth values. To clearly distinguish internal nodes and leaves, the SyntaxBranch type is defined, making each SyntaxTree arity-complaint.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SyntaxBranch\nchildren(φ::SyntaxBranch)\ntoken(φ::SyntaxBranch)","category":"page"},{"location":"getting-started/#SoleLogics.SyntaxBranch","page":"Getting started","title":"SoleLogics.SyntaxBranch","text":"struct SyntaxBranch{T<:Connective} <: SyntaxTree\n    token::T\n    children::NTuple{N,SyntaxTree} where {N}\nend\n\nAn internal node of a syntax tree encoding a logical formula. Such a node holds a syntax token (a Connective, and has as many children as the arity of the token.\n\nThis implementation is arity-compliant, in that, upon construction, the arity of the token is checked against the number of children provided.\n\nExamples\n\njulia> p,q = Atom.([p, q])\n2-element Vector{Atom{String}}:\n Atom{String}: p\n Atom{String}: q\n\njulia> branch = SyntaxBranch(CONJUNCTION, p, q)\nSyntaxBranch{NamedConnective{:∧}}: p ∧ q\n\njulia> token(branch)\n∧\n\njulia> syntaxstring.(children(branch))\n(p, q)\n\njulia> ntokens(a) == nconnectives(a) + nleaves(a)\ntrue\n\njulia> arity(a)\n2\n\njulia> height(a)\n1\n\nSee also token, children, arity, Connective, height, atoms, natoms, operators, noperators, tokens, ntokens,\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#AbstractTrees.children-Tuple{SyntaxBranch}","page":"Getting started","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nGetter for φ children.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.token-Tuple{SyntaxBranch}","page":"Getting started","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nGetter for the token wrapped in a SyntaxTree.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#semantics-base-definitions","page":"Getting started","title":"Semantics Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractInterpretation\ninterpret(φ::Formula, i::AbstractInterpretation, args...; kwargs...)\ncheck(φ::Formula, i::AbstractInterpretation, args...; kwargs...)","category":"page"},{"location":"getting-started/#SoleLogics.AbstractInterpretation","page":"Getting started","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Getting started","title":"SoleLogics.interpret","text":"interpret(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Formula\n\nReturn the truth value for a formula on a logical interpretation (or model).\n\nExamples\n\njulia> @atoms p q\n2-element Vector{Atom{String}}:\n p\n q\n\njulia> td = TruthDict([p => true, q => false])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> interpret(CONJUNCTION(p,q), td)\n⊥\n\nSee also check, Formula, AbstractInterpretation, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Getting started","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"wip/","page":"Work in progress","title":"Work in progress","text":"CurrentModule = SoleLogics","category":"page"},{"location":"wip/","page":"Work in progress","title":"Work in progress","text":"Pages = [\"wip.md\"]","category":"page"},{"location":"wip/","page":"Work in progress","title":"Work in progress","text":"TODO: syntax-utils.jl  TODO: interpretation-sets.jl TODO: anchored-formula.jl","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Pages = [\"base-logic.md\"]","category":"page"},{"location":"base-logic/#base-logic-introduction","page":"Introduction to Logics and Propositional Logic","title":"Introduction","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"At the end of this chapter, you are going to understand how Atoms and Truth values are organized in alphabets, and how grammars are defined. ","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"You will also get an in-depth view of how boolean truth values and boolean Connective's are defined from both a syntax and a syntactical standpoint of view.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"The end of this chapter is dedicated to modal logic, which is one of the most hot topics covered by SoleLogics.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Recalling the type hierarchy presented in man-core, it is here enriched with the following new types and structures.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Truth\nBooleanTruth (new)\nTop\nBot","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Connective\nNamedConnective (new)\nNEGATION\nCONJUNCTION \nDISJUNCTION\nIMPLICATION\nDIAMOND\nBOX","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlphabet{V} (new)\nExplicitAlphabet{V}\nAlphabetOfAny{V}","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractGrammar{V<:AbstractAlphabet,O<:Operator} (new)\nCompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator}","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlgebra{T<:Truth} (new)\nBooleanAlgebra","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractLogic{G<:AbstractGrammar,V<:AbstractAlgebra} (new)\n[BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra}]","category":"page"},{"location":"base-logic/#alphabets","page":"Introduction to Logics and Propositional Logic","title":"Alphabet","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlphabet{V}\nBase.isfinite(::Type{<:AbstractAlphabet})\natoms(a::AbstractAlphabet)\nBase.in(p::Atom, a::AbstractAlphabet)\nBase.length(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet)\n\nExplicitAlphabet{V}\nAlphabetOfAny{V}","category":"page"},{"location":"base-logic/#SoleLogics.AbstractAlphabet","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, Atom, ExplicitAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#Base.isfinite-Tuple{Type{<:SoleLogics.AbstractAlphabet}}","page":"Introduction to Logics and Propositional Logic","title":"Base.isfinite","text":"Base.isfinite(a::AbstractAlphabet)\n\nReturn true if the alphabet is finite, false otherwise.\n\nSee AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.atoms","text":"atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nList the atoms of a finite alphabet.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"Base.in","text":"Base.in(p::Atom, a::AbstractAlphabet)::Bool\n\nReturn whether an atom belongs to an alphabet.\n\nSee also AbstractAlphabet, Atom.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.length-Tuple{SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"Base.length","text":"Base.length(a::AbstractAlphabet)::Bool\n\nReturn the alphabet length, if it is finite.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"Base.iterate","text":"Base.iterate(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet, state)\n\nReturn an iterator to the next element in an alhabet.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.ExplicitAlphabet","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.ExplicitAlphabet","text":"struct ExplicitAlphabet{V} <: AbstractAlphabet{V}\n    atoms::Vector{Atom{V}}\nend\n\nAn alphabet wrapping atoms in a (finite) Vector.\n\nSee also AbstractAlphabet, atoms.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.AlphabetOfAny","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AlphabetOfAny","text":"struct AlphabetOfAny{V} <: AbstractAlphabet{V} end\n\nAn implicit, infinite alphabet that includes all atoms with values of a subtype of V.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#grammars","page":"Introduction to Logics and Propositional Logic","title":"Grammar","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractGrammar{V<:AbstractAlphabet,O<:Operator} \nalphabet(g::AbstractGrammar{V} where {V})\nBase.in(φ::SyntaxTree, g::AbstractGrammar)\nformulas(g::AbstractGrammar; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing, args...)\n\nCompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator}\nconnectives(g::AbstractGrammar)\nleaves(g::AbstractGrammar)\n\nformulas(g::CompleteFlatGrammar{V,O} where {V,O}; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing)","category":"page"},{"location":"base-logic/#SoleLogics.AbstractGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractGrammar","text":"abstract type AbstractGrammar{V<:AbstractAlphabet,O<:Operator} end\n\nAbstract type for representing a context-free grammar based on a single alphabet of type V, and a set of operators that consists of all the (singleton) child types of O. V context-free grammar is a simple structure for defining formulas inductively.\n\nSee also alphabet, AbstractAlphabet, Operator.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{V} where {V})::V\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"Base.in","text":"Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxBranch}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.CompleteFlatGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.CompleteFlatGrammar","text":"struct CompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator} <: AbstractGrammar{V,O}\n    alphabet::V\n    operators::Vector{<:O}\nend\n\nV grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type V, and all operators in operators. With n operators, this grammar has exactly n+1 production rules. For example, with operators = [∧,∨], the grammar (in Backus-Naur form) is:\n\nφ ::= p | φ ∧ φ | φ ∨ φ\n\nwith p ∈ alphabet. Note: it is flat in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.\n\nSee also AbstractGrammar, Operator, alphabet, formulas, connectives, operators, leaves.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.connectives","text":"connectives(g::AbstractGrammar)\n\nList all connectives appearing in a grammar.\n\nSee also Connective, nconnectives.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.leaves","text":"leaves(g::AbstractGrammar)\n\nList all leaves appearing in a grammar.\n\nSee also SyntaxLeaf, nleaves.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{V,O} where {V,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxBranch}\n\nGenerate all formulas whose SyntaxBranchs that are not taller than a given maxdepth.\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#algebra","page":"Introduction to Logics and Propositional Logic","title":"Algebra","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlgebra{T<:Truth}\ntruthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth}\ndomain(a::AbstractAlgebra)\ntop(a::AbstractAlgebra{T} where {T})\nbot(a::AbstractAlgebra)\niscrisp(a::AbstractAlgebra)","category":"page"},{"location":"base-logic/#SoleLogics.AbstractAlgebra","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractAlgebra","text":"abstract type AbstractAlgebra{T<:Truth} end\n\nAbstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a lattice structure where two elements(or nodes) ⊤ and ⊥ are referred to as TOP (or maximum) and bot (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.\n\nImplementation\n\nWhen implementing a new algebra type, the methods domain, TOP, and bot should be implemented.\n\nSee also bot, BooleanAlgebra, Operator, TOP, collatetruth, domain, iscrisp, truthtype.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T<:Truth","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth} = T\ntruthtype(a::AbstractAlgebra) = truthtype(typeof(a))\n\nThe Julia type for representing truth values of the algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.domain","text":"domain(a::AbstractAlgebra)\n\nReturn an iterator to the values in the domain of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.top","text":"top(a::AbstractAlgebra)\n\nReturn the top of a given algebra.\n\nSee also bot, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.bot","text":"bot(a::AbstractAlgebra)\n\nReturn the bottom of a given algebra.\n\nSee also top, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.iscrisp","text":"iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))\n\nAn algebra is crisp (or boolean) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is fuzzy.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#logic","page":"Introduction to Logics and Propositional Logic","title":"Logic","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractLogic{G<:AbstractGrammar,V<:AbstractAlgebra}\ngrammar(l::AbstractLogic{G}) where {G<:AbstractGrammar}\nalgebra(l::AbstractLogic{G,V}) where {G,V}","category":"page"},{"location":"base-logic/#SoleLogics.AbstractLogic","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractLogic","text":"abstract type AbstractLogic{G<:AbstractGrammar,V<:AbstractAlgebra} end\n\nAbstract type of a logic, which comprehends a context-free grammar (syntax) and an algebra (semantics).\n\nImplementation\n\nWhen implementing a new logic type, the methods grammar and algebra should be implemented.\n\nSee also AbstractAlgebra, AbstractGrammar.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G<:SoleLogics.AbstractGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.grammar","text":"grammar(l::AbstractLogic{G})::G where {G<:AbstractGrammar}\n\nReturn the grammar of a given logic.\n\nSee also AbstractGrammar, AbstractLogic, algebra, alphabet, formulas, grammar, operators, truthtype.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.algebra","text":"algebra(l::AbstractLogic{G,V})::V where {G,V}\n\nReturn the algebra of a given logic.\n\nSee also AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#more-about-connectives","page":"Introduction to Logics and Propositional Logic","title":"More about Connectives","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"NamedConnective{Symbol}\ncollatetruth(c::Connective, ts::NTuple{N,T where T<:Truth}) where {N}\nsimplify(c::Connective, ts::NTuple{N,F where F<:Formula}) where {N}","category":"page"},{"location":"base-logic/#SoleLogics.NamedConnective","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.NamedConnective","text":"struct NamedConnective{Symbol} <: Connective end\n\nA singleton type for representing connectives defined by a name or a symbol.\n\nExamples\n\nThe AND connective (i.e., the logical conjunction) is defined as the subtype:\n\nconst CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.collatetruth","text":"collatetruth(c::Connective, ts::NTuple{N,T where T<:Truth})::Truth where {N}\n\nReturn the truth value for a composed formula c(t1, ..., tN), given the N with t1, ..., tN being Truth values.\n\nSee also simplify, Connective, Truth.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.simplify","text":"simplify(c::Connective, ts::NTuple{N,F where F<:Formula})::Truth where {N}\n\nReturn a formula with the same semantics of a composed formula c(φ1, ..., φN), given the N immediate sub-formulas.\n\nSee also collatetruth, Connective, Formula.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#boolean-algebra","page":"Introduction to Logics and Propositional Logic","title":"Boolean logic","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"NEGATION\nCONJUNCTION\nDISJUNCTION\nIMPLICATION","category":"page"},{"location":"base-logic/#SoleLogics.NEGATION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.NEGATION","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.CONJUNCTION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.DISJUNCTION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.IMPLICATION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.IMPLICATION","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Boolean logic Connectives are regrouped in a single collection.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BASE_CONNECTIVES","category":"page"},{"location":"base-logic/#SoleLogics.BASE_CONNECTIVES","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BASE_CONNECTIVES","text":"const BASE_CONNECTIVES = [¬, ∧, ∨, →]\n\nBasic logical operators.\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BooleanTruth\nTop\nBot","category":"page"},{"location":"base-logic/#SoleLogics.BooleanTruth","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BooleanTruth","text":"abstract type BooleanTruth <: Truth end\n\nSupertype of Top and Bot, the two truth values of BooleanAlgebra\n\nSee also Bot, Top, BooleanAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.Top","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.Top","text":"struct Top <: Truth end\nconst TOP = Top()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.Bot","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.Bot","text":"struct Bot <: Truth end\nconst BOT = Bot()\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BooleanAlgebra\nBaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra}","category":"page"},{"location":"base-logic/#SoleLogics.BooleanAlgebra","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BooleanAlgebra","text":"struct BooleanAlgebra <: AbstractAlgebra{Bool} end\n\nA Boolean algebra, defined on the values Top (representing true) and Bot (for bottom, representing false). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of true and false, respectively.\n\nSee also Truth.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.BaseLogic","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BaseLogic","text":"struct BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra} <: AbstractLogic{G,A}\n    grammar::G\n    algebra::A\nend\n\nA basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.\n\nSee also grammar, algebra, AbstractGrammar, AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = SoleLogics","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"utilities.md\"]","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"TODO: random.jl TODO: parse.jl","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Pages = [\"modal-logic.md\"]","category":"page"},{"location":"modal-logic/#modal-logic-introduction","page":"Modal Logic","title":"Introduction","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"At the end of this chapter, you are going to understand what modal logic is, and why it is so important from a computational standpoint of view, with respect to propositional logic and first order logic. For those of you who want to fully immerse in the topic, we recommend reading the thesis Foundations of Modal Symbolic Learning, by Stan Ionel Eduard. ","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Recalling the type hierarchy presented in man-core, it is here enriched with the following new types and structures.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Connective\nNamedConnective\n...\nDIAMOND (new)\nBOX (new)\nAbstractRelationalConnective (new)\nDiamondRelationalConnective\nBoxRelationalConnective","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractWorld (new)\nWorld{T}","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractFrame{W<:AbstractWorld} (new)\nAbstractUniModalFrame{W<:AbstractWorld}\nAbstractMultiModalFrame{W<:AbstractWorld}\n[WrapperMultiModalFrame{W<:AbstractWorld, D<:AbstractDict{<:AbstractRelation,<:AbstractUniModalFrame{W}}}]","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractRelation (new)","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractInterpretation\nAbstractKripkeStructure (new)\nKripkeStructure{FR<:AbstractFrame, MAS<:AbstractDict}","category":"page"},{"location":"modal-logic/#modal-logic-pills","page":"Modal Logic","title":"Pills of Modal Logic","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Modal logic is, essentially, Propositional Logic enriched with (a set of) modal connectives (or modalities, called modal connectives in SoleLogics). Narrow speaking, modal logic was initially investigated as the logic of necessary and possible truths judgments due to Aristotle's foresighted analysis of statements containing the words \"necessary\" and \"possible\".","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Modal Logic allows us to characterize the validity of arguments with modal premises and conclusions. The well-formed formulas of Propositional Modal Logic, or Archetypal Modal Logic are generated by the following grammar etc...","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"TODO: by Mauro, I don't know how much deeper we want to go here.","category":"page"},{"location":"modal-logic/#modal-logic-worlds-and-frames","page":"Modal Logic","title":"Worlds and Frames","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractWorld\nWorld{T}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractWorld","page":"Modal Logic","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.World","page":"Modal Logic","title":"SoleLogics.World","text":"struct World{T} <: AbstractWorld\n    name::T\nend\n\nA world that is solely identified by its name. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.\n\nSee also OneWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractFrame{W<:AbstractWorld}\nworldtype(::Type{<:AbstractFrame{W}}) where {W<:AbstractWorld}\nallworlds(fr::AbstractFrame{W}) where {W<:AbstractWorld}\nnworlds(fr::AbstractFrame)\n\nAbstractUniModalFrame{W<:AbstractWorld}\naccessibles(fr::AbstractUniModalFrame{W}, w::W) where {W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractFrame","page":"Modal Logic","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures's). A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.worldtype","text":"worldtype(fr::AbstractFrame)\nworldtype(i::AbstractKripkeStructure)\n\nReturn the world type of the Kripke frame/structure.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.allworlds","text":"allworlds(fr::AbstractFrame{W})::AbstractVector{<:W} where {W<:AbstractWorld}\n\nReturn all worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}","page":"Modal Logic","title":"SoleLogics.nworlds","text":"nworlds(fr::AbstractFrame)::Integer\n\nReturn the number of worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.AbstractUniModalFrame","page":"Modal Logic","title":"SoleLogics.AbstractUniModalFrame","text":"abstract type AbstractUniModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a modal logic based on a single (implicit) accessibility relation.\n\nSee also AbstractMultiModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-relations","page":"Modal Logic","title":"Relations","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractRelation\narity(r::AbstractRelation)\nconverse(r::AbstractRelation)\nistoone(r::AbstractRelation)\nissymmetric(r::AbstractRelation)\nisreflexive(::AbstractRelation)\nistransitive(::AbstractRelation)\nisgrounding(::AbstractRelation)","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractRelation","page":"Modal Logic","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, identityrel, globalrel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.arity-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.arity","text":"arity(::AbstractRelation)::Integer\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.converse-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.converse","text":"hasconverse(r::AbstractRelation)::Bool\nconverse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.istoone-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.istoone","text":"istoone(r::AbstractRelation) = false\n\nReturn whether it is known that a relation is istoone.\n\nSee also hasconverse, converse, issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.issymmetric-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.issymmetric","text":"issymmetric(r::AbstractRelation) = hasconverse(r) ? converse(r) == r : false\n\nReturn whether it is known that a relation is symmetric.\n\nSee also hasconverse, converse, isreflexive, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isreflexive-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.isreflexive","text":"isreflexive(::AbstractRelation)\n\nReturn whether it is known that a relation is reflexive.\n\nSee also issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.istransitive-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.istransitive","text":"istransitive(::AbstractRelation)\n\nReturn whether it is known that a relation is transitive.\n\nSee also istoone, issymmetric, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isgrounding-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.isgrounding","text":"isgrounding(::AbstractRelation)\n\nReturn whether it is known that a relation is grounding. A relation R is grounding if ∀x,y R(x,y) ⇔ R(z,y).\n\nSee also isreflexive, issymmetric, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-kripke-structures","page":"Modal Logic","title":"More on Frames and Kripke Structures","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractMultiModalFrame{W<:AbstractWorld}\naccessibles(fr::AbstractMultiModalFrame{W}, w::W, r::AbstractRelation) where {W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractMultiModalFrame","page":"Modal Logic","title":"SoleLogics.AbstractMultiModalFrame","text":"abstract type AbstractMultiModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.\n\nImplementation\n\nWhen implementing a new multi-modal frame type, the logical semantics for the frame should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractUniModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.accessibles","text":"accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractKripkeStructure\n\ncheck(φ::SyntaxTree, i::AbstractKripkeStructure, w::Union{Nothing,<:AbstractWorld} = nothing; use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing, perform_normalization::Bool = true, memo_max_height::Union{Nothing,Int} = nothing)\n\nKripkeStructure{FR<:AbstractFrame, MAS<:AbstractDict}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractKripkeStructure","page":"Modal Logic","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's). It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.check","page":"Modal Logic","title":"SoleLogics.check","text":"function check(\n    φ::SyntaxTree,\n    i::AbstractKripkeStructure,\n    w::Union{Nothing,<:AbstractWorld} = nothing;\n    use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing,\n    perform_normalization::Bool = true,\n    memo_max_height::Union{Nothing,Int} = nothing,\n)::Bool\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Structure\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\n","category":"function"},{"location":"modal-logic/#SoleLogics.KripkeStructure","page":"Modal Logic","title":"SoleLogics.KripkeStructure","text":"struct KripkeStructure{\n    FR<:AbstractFrame,\n    MAS<:AbstractDict\n} <: AbstractKripkeStructure\n    frame::FR\n    assignment::AS\nend\n\nType for representing Kripke structures's). explicitly; it wraps a frame, and an abstract dictionary that assigns an interpretation to each world.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#modal-logic-connectives","page":"Modal Logic","title":"Modal Connectives","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"ismodal(::Type{<:Connective})\nisbox(::Type{<:Connective})","category":"page"},{"location":"modal-logic/#SoleLogics.ismodal-Tuple{Type{<:Connective}}","page":"Modal Logic","title":"SoleLogics.ismodal","text":"ismodal(::Type{<:Connective})::Bool = false\nismodal(c::Connective)::Bool = ismodal(typeof(c))\n\nReturn whether it is known that an Connective is modal.\n\nExamples\n\njulia> ismodal(◊)\ntrue\n\njulia> ismodal(∧)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isbox-Tuple{Type{<:Connective}}","page":"Modal Logic","title":"SoleLogics.isbox","text":"isbox(::Type{<:Connective})::Bool = false\nisbox(c::Connective)::Bool = isbox(typeof(c))\n\nReturn whether it is known that an Connective is a box (i.e., universal) connective.\n\nExamples\n\njulia> SoleLogics.isbox(◊)\nfalse\n\njulia> SoleLogics.isbox(∧)\nfalse\n\njulia> SoleLogics.isbox(□)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"DIAMOND\nBOX","category":"page"},{"location":"modal-logic/#SoleLogics.DIAMOND","page":"Modal Logic","title":"SoleLogics.DIAMOND","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::NamedConnective{:◊}) = true\narity(::typeof(◊)) = 1\n\nLogical diamond connective, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"modal-logic/#SoleLogics.BOX","page":"Modal Logic","title":"SoleLogics.BOX","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box connective, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"modal-logic/#modal-logic-relational-connectives","page":"Modal Logic","title":"Relational Connectives","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractRelationalConnective{R<:AbstractRelation}\nrelationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation}\nDiamondRelationalConnective{R<:AbstractRelation}\n\ndiamond()\nbox()","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractRelationalConnective","page":"Modal Logic","title":"SoleLogics.AbstractRelationalConnective","text":"abstract type AbstractRelationalConnective{R<:AbstractRelation} <: Connective end\n\nAbstract type for relational logical connectives. A relational connective allows for semantic quantification across relational structures (e.g., Kripke structures). It has arity equal to the arity of its underlying relation minus one.\n\nSee, for example temporal modal logic.\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.relationtype-Union{Tuple{SoleLogics.AbstractRelationalConnective{R}}, Tuple{R}} where R<:AbstractRelation","page":"Modal Logic","title":"SoleLogics.relationtype","text":"relationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalConnective) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational connective.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.DiamondRelationalConnective","page":"Modal Logic","title":"SoleLogics.DiamondRelationalConnective","text":"struct DiamondRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\nstruct BoxRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\n\nSingleton types for relational connectives, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth connectives can be easily instantiated with relation instances, such as DiamondRelationalConnective(rel), which is a shortcut for DiamondRelationalConnective{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalConnective(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalConnective(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalConnective(IA_A) == SoleLogics.dual(BoxRelationalConnective(IA_A))\n\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.diamond-Tuple{}","page":"Modal Logic","title":"SoleLogics.diamond","text":"diamond() = DIAMOND\ndiamond(r::AbstractRelation) = DiamondRelationalConnective(r)\n\nReturn either the diamond modal connective from unimodal logic (i.e., ◊), or a a diamond relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also DiamondRelationalConnective, diamond, DIAMOND.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.box-Tuple{}","page":"Modal Logic","title":"SoleLogics.box","text":"box() = BOX\nbox(r::AbstractRelation) = BoxRelationalConnective(r)\n\nReturn either the box modal connective from unimodal logic (i.e., □), or a a box relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also BoxRelationalConnective, box, BOX.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-final-steps","page":"Modal Logic","title":"Final steps","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"modallogic(; alphabet::Union{Nothing,Vector,AbstractAlphabet} = nothing, operators::Union{Nothing,Vector{<:Connective}} = nothing, grammar::Union{Nothing,AbstractGrammar} = nothing, algebra::Union{Nothing,AbstractAlgebra} = nothing, default_operators = BASE_MODAL_CONNECTIVES)\n\ncollateworlds(fr::AbstractFrame{W}, op::Operator, t::NTuple{N,<:AbstractWorlds}) where {N,W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.modallogic-Tuple{}","page":"Modal Logic","title":"SoleLogics.modallogic","text":"modallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a modal logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic(; operators = [¬, ∨]))\n┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedConnective[¬, ∨]). Consider using propositionallogic instead.\n└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642\nfalse\n\njulia> modallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> modallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also propositionallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, Tuple{Vararg{var\"#s1\", N}} where var\"#s1\"<:(AbstractVector{W} where W<:AbstractWorld)}} where {N, W<:AbstractWorld}","page":"Modal Logic","title":"SoleLogics.collateworlds","text":"collateworlds(\n    fr::AbstractFrame{W},\n    op::Operator,\n    t::NTuple{N,WS},\n)::AbstractVector{<:W} where {N,W<:AbstractWorld,WS<:AbstractWorlds}\n\nFor a given crisp frame (truthtype == Bool), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the N sets of worlds where the each immediate sub-formula is true.\n\nSee also check, iscrisp, Operator, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleLogics","category":"page"},{"location":"#SoleLogics","page":"Home","title":"SoleLogics","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleLogics, a Julia package for computational logic. SoleLogics.jl lays the logical foundations for Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleLogics.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleLogics\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl allows easy manipulation of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Syntax tokens (e.g., atoms, logical constants/connectives, etc.);\nAlphabets, grammars, algebras (e.g., crisp, fuzzy), logics (e.g., propositional and (multi)modal);\nFormulas (e.g., syntax trees, DNFs, CNFs): random generation, parsing, minimization;\nInterpretations (e.g., propositional assignments, Kripke structures);\nAlgorithms for evaluating the: validity/satisfiability of a formula, and truth of a formula on an interpretation (model checking).","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl lays the logical foundations for Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thanks to Jakob Peters (PAndQ.jl) for the interesting discussions and ideas.","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleData.jl\nSoleFeatures.jl \nSoleModels.jl\nSolePostHoc.jl","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"CurrentModule = SoleLogics","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"Pages = [\"hands-on.md\"]","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"TODO: get inspiration from Gio pluto tutorial","category":"page"}]
}
