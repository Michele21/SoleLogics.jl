```@meta
CurrentModule = SoleLogics
```

```@contents
Pages = ["modal-logic.md"]
```
# [Introduction](@id modal-logic-introduction)
At the end of this chapter, you are going to understand what modal logic is, and why it is so important from a computational standpoint of view, with respect to propositional logic and first order logic. For those of you who want to fully immerse in the topic, we recommend reading the thesis [Foundations of Modal Symbolic Learning](https://eduardstan.github.io/assets/pdf/publications/theses/phd_thesis2023.pdf), by Stan Ionel Eduard. 

Recalling the type hierarchy presented in [man-core](@ref), it is here enriched with the following new types and structures.

- [`Connective`](@ref)
    - [`NamedConnective`](@ref)
        - [`DIAMOND`](@ref) **(new)**
        - [`BOX`](@ref) **(new)**
    - [`AbstractRelationalConnective`](@ref) **(new)**
        - [`DiamondRelationalConnective`](@ref)
        - [`BoxRelationalConnective`](@ref)
---

- [`AbstractWorld`](@ref) **(new)**
    - [`World{T}`](@ref)

---

- [`AbstractFrame{W<:AbstractWorld}`](@ref) **(new)**
    - [`AbstractUniModalFrame{W<:AbstractWorld}`](@ref)
    - [`AbstractMultiModalFrame{W<:AbstractWorld}`](@ref)
    - [`WrapperMultiModalFrame{W<:AbstractWorld, D<:AbstractDict{<:AbstractRelation,<:AbstractUniModalFrame{W}}}`](@ref)

---

- [`AbstractRelation`](@ref) **(new)**

---

- [`AbstractInterpretation`](@ref)
    - [`AbstractKripkeStructure`](@ref) **(new)**
        - [`KripkeStructure{FR<:AbstractFrame, MAS<:AbstractDict}`](@ref)

# [Pills of Modal Logic](@id modal-logic-pills)
Modal logic is, essentially, Propositional Logic enriched with (a set of) *modal connectives* (or *modalities*, called *modal connectives* in SoleLogics). Narrow speaking, modal logic was initially investigated as the logic of *necessary* and *possible* truths judgments due to Aristotle's foresighted analysis of statements containing the words "necessary" and "possible".

Modal Logic allows us to characterize the validity of arguments with *modal* premises and conclusions. The well-formed formulas of *Propositional Modal Logic*, or *Archetypal Modal Logic* are generated by the following grammar etc...

TODO: by Mauro, I don't know how much deeper we want to go here.

# [Worlds and Frames](@id modal-logic-worlds-and-frames)

```@docs
AbstractWorld
World{T}
```

```@docs
AbstractFrame{W<:AbstractWorld}
worldtype(::Type{<:AbstractFrame{W}}) where {W<:AbstractWorld}
allworlds(fr::AbstractFrame{W}) where {W<:AbstractWorld}
nworlds(fr::AbstractFrame)

AbstractUniModalFrame{W<:AbstractWorld}
accessibles(fr::AbstractUniModalFrame{W}, w::W) where {W<:AbstractWorld}
```

# [Relations](@id modal-logic-relations)

```@docs
AbstractRelation
arity(r::AbstractRelation)
converse(r::AbstractRelation)
istoone(r::AbstractRelation)
issymmetric(r::AbstractRelation)
isreflexive(::AbstractRelation)
istransitive(::AbstractRelation)
isgrounding(::AbstractRelation)
```

# [More on Frames and Kripke Structures](@id modal-logic-kripke-structures)

```@docs
AbstractMultiModalFrame{W<:AbstractWorld}
accessibles(fr::AbstractMultiModalFrame{W}, w::W, r::AbstractRelation) where {W<:AbstractWorld}
```

```@docs
AbstractKripkeStructure

check(Ï†::SyntaxTree, i::AbstractKripkeStructure, w::Union{Nothing,<:AbstractWorld} = nothing; use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing, perform_normalization::Bool = true, memo_max_height::Union{Nothing,Int} = nothing)

KripkeStructure{FR<:AbstractFrame, MAS<:AbstractDict}
```

# [Modal Connectives](@id modal-logic-connectives)

```@docs
ismodal(::Type{<:Connective})
isbox(::Type{<:Connective})
```

```@docs
DIAMOND
BOX
```

# [Relational Connectives](@id modal-logic-relational-connectives)

```@docs
AbstractRelationalConnective{R<:AbstractRelation}
relationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation}
DiamondRelationalConnective{R<:AbstractRelation}

diamond()
box()
```

# [Final steps](@id modal-logic-final-steps)

```@docs
modallogic(; alphabet::Union{Nothing,Vector,AbstractAlphabet} = nothing, operators::Union{Nothing,Vector{<:Connective}} = nothing, grammar::Union{Nothing,AbstractGrammar} = nothing, algebra::Union{Nothing,AbstractAlgebra} = nothing, default_operators = BASE_MODAL_CONNECTIVES)

collateworlds(fr::AbstractFrame{W}, op::Operator, t::NTuple{N,<:AbstractWorlds}) where {N,W<:AbstractWorld}
```
