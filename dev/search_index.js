var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleLogics","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#syntactical-base-definitions","page":"Getting started","title":"Syntax Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Logical formulas are synctactical objects representing statements which level of truth can be assessed. Formulas arise from formal grammars (e.g., context-free grammars), and are most commonly represented as syntax trees. At the leaf nodes of a syntax tree are atoms (simple, atomic statements) or truth values (e.g., ⊤, representing truth), while at the internal nodes are logical connectives that allow for the composition of formulas to represent complex concepts.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In SoleLogics, an Atom is a wrapper for any value (accessible via the value method).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"arity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Atom\nTruthValue\nAbstractOperator\nSyntaxTree","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let's review these concepts with a simple example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"julia> p = Atom(\"p\")\nAtom{String}(\"p\")\n\njulia> q = Atom(\"q\")\nAtom{String}(\"q\")\n\njulia> value(p)\n\"p\"\n\n# Operators are syntax tokens too\njulia> CONJUNCTION\n∧\n\n# SyntaxTree's are arity-compliant\njulia> st = SyntaxTree(CONJUNCTION, p)\nERROR: AssertionError: Cannot instantiate SyntaxTree{SoleLogics.NamedOperator{:∧}} \nwith token ∧ of arity 2 and 1 children.\n\n# In fact, the conjunction operator in a syntax tree must have exactly 2 children \njulia> arity(CONJUNCTION)\n2\n\njulia> stree = SyntaxTree(CONJUNCTION, (p,q))\nSyntaxTree: p ∧ q\n\n# Get the token of the root node\njulia> token(st)\n∧\n\n# Get the first subtree, containing only an atom\njulia> leftree = children(st)[1]; \nSyntaxTree: p\n\njulia> typeof(leftree)\nSyntaxTree{Atom{String}}\n\n# Atoms are necessarily at the leaves; in fact their arity is 0\njulia> leftree |> token |> arity\n0","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractSyntaxStructure\nAbstractSyntaxToken\nSoleLogics.arity(::Type{<:AbstractSyntaxToken})","category":"page"},{"location":"getting-started/#SoleLogics.arity-Tuple{Type{<:AbstractSyntaxToken}}","page":"Getting started","title":"SoleLogics.arity","text":"arity(::Type{<:AbstractSyntaxToken})::Integer\narity(tok::AbstractSyntaxToken)::Integer = arity(typeof(tok))\n\nReturn the arity of a syntax token. The arity of a syntax token is an integer representing the number of allowed children in a SyntaxTree. Tokens with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively.\n\nSee also AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Connectives","page":"Getting started","title":"Connectives","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"TODO","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.AbstractOperator","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement custom operators. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.NamedOperator\nBase.operator_precedence(op::AbstractOperator)\nSoleLogics.isrightassociative\nSoleLogics.iscommutative","category":"page"},{"location":"getting-started/#SoleLogics.isrightassociative","page":"Getting started","title":"SoleLogics.isrightassociative","text":"isrightassociative(::Type{AbstractOperator})\nisrightassociative(o::AbstractOperator) = isrightassociative(typeof(o))\n\nReturn whether an AbstractOperator is right associative or no.\n\nAssociativity establishes how operators of the same precedence are grouped in the absence of the parentheses.\n\nConjunction and disjunction are commutative operators, thus, the left associativity case \"(p ∧ q) ∧ r\" and the right associativity case \"p ∧ (q ∧ r)\" are equivalent; by convention we consider the latter form. Implication is right associative, meaning that \"p → q → r\" is grouped as \"p → (q → r)\".\n\nBy default, an operator is right associative.\n\nExamples\n\njulia> isrightassociative(∧)\ntrue\n\njulia> isrightassociative(→)\ntrue\n\nSee also AbstractOperator.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.iscommutative","page":"Getting started","title":"SoleLogics.iscommutative","text":"iscommutative(::Type{AbstractOperator})\niscommutative(o::AbstractOperator) = iscommutative(typeof(o))\n\nReturn whether an operator is known to be commutative.\n\nExamples\n\njulia> iscommutative(∧)\ntrue\n\njulia> iscommutative(→)\nfalse\n\nNote that nullary and unary operators are considered commutative.\n\nSee also AbstractOperator.\n\nImplementation\n\nWhen implementing a new type for a commutative operator O with arity higher than 1, please provide a method iscommutative(::Type{O}). This can help model checking operations.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To learn more about operators, refer to Propositional Logic and Modal Logic chapters.","category":"page"},{"location":"getting-started/#Formulas","page":"Getting started","title":"Formulas","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"TODO: the following definition might be unclear, since \"evaluation\" and \"logic\" are not concepts already read by the user. When the Logic structure will be removed from SoleLogics, this section will be expanded with semantics-related concepts.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractFormula","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement a custom Formula type. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"joinformulas\ntokens(f::AbstractFormula)\nSoleLogics.height(t::SyntaxTree)\nSoleLogics.tree(f::AbstractFormula)","category":"page"},{"location":"getting-started/#SoleLogics.joinformulas","page":"Getting started","title":"SoleLogics.joinformulas","text":"joinformulas(\n    op::AbstractOperator,\n    ::NTuple{N,F}\n)::F where {N,F<:AbstractFormula}\n\nReturn a new formula of type F by composing N formulas of the same type via an operator op. This function allows one to use operators for flexibly composing formulas (see Implementation).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxTree: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;)\nSyntaxTree: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxTree: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon joinformulas lies a flexible way of using operators for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (op::AbstractOperator)(\n    children::NTuple{N,Union{AbstractSyntaxToken,AbstractFormula}},\n) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of AbstractFormula, a new method for joinformulas should be defined, together with promotion from/to other AbstractFormulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) operator to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined operator op, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Union{AbstractSyntaxToken,AbstractFormula},\n    c2::Union{AbstractSyntaxToken,AbstractFormula},\n    c3::Union{AbstractSyntaxToken,AbstractFormula},\n    cs::Union{AbstractSyntaxToken,AbstractFormula}...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Union{AbstractSyntaxToken,AbstractFormula},\n    c2::Union{AbstractSyntaxToken,AbstractFormula},\n    c3::Union{AbstractSyntaxToken,AbstractFormula},\n    cs::Union{AbstractSyntaxToken,AbstractFormula}...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nSee also AbstractFormula, AbstractOperator.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Parsing-and-Printing","page":"Getting started","title":"Parsing & Printing","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.jl allows you to: ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Extract the string representation of a formula (via syntaxstring);\nParse formulas from strings (via parsetree).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"These features are highly customizable, and leverage three properties of syntactical tokens: arity, operator precedence (operator_precedence) and operator associativity (isrightassociative).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"syntaxstring\nparsetree","category":"page"},{"location":"getting-started/#SoleLogics.syntaxstring","page":"Getting started","title":"SoleLogics.syntaxstring","text":"syntaxstring(φ::AbstractFormula; kwargs...)::String\nsyntaxstring(tok::AbstractSyntaxToken; kwargs...)::String\n\nProduce the string representation of a formula or syntax token by performing a tree traversal of the syntax tree representation of the formula. Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leafs of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(p, ∧(q, ∧(r, ∧(s, t))))\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"(p) ∧ ((q) ∧ ((r) ∧ ((s) ∧ (t))))\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parsebaseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parsebaseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parsebaseformula, parsetree, SyntaxTree, AbstractSyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including kwargs...) for every newly defined AbstractSyntaxToken (e.g., operators and Atoms), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(p::Atom; kwargs...) = syntaxstring(value(p); kwargs...)\n\nThen, the syntaxstring for a given value can be defined. For example, with String (or Number) values, it defaults to:\n\nsyntaxstring(value::String; kwargs...) = value\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (','). See also parsebaseformula.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.parsetree","page":"Getting started","title":"SoleLogics.parsetree","text":"parsetree(\n    expression::String,\n    additional_operators::Union{Nothing,Vector{<:AbstractOperator}} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)\n\nReturn a SyntaxTree which is the result of parsing expression  via the Shunting yard  algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS (see arguments section); additional operators may be provided as a second argument.\n\nArguments\n\nexpression::String: expression to be parsed;\nadditional_operators::Vector{<:AbstractOperator}: additional, non-standard operators   needed to correctly parse the expression.   When left unset, only the operators in SoleLogics.BASE_PARSABLE_OPERATORS are   correctly parsed: S, o, l, e, L, o, g, i, c, s, ., A, b, s, t, r, a, c, t, O, p, e, r, a, t, o, r, [, ⊤, ,,  , ⊥, ,,  , ¬, ,,  , ∧, ,,  , ∨, ,,  , →, ,,  , ◊, ,,  , □, ,,  , ⟨, G, ⟩, ,,  , [, G, ], ,,  , ⟨, =, ⟩, ,,  , [, =, ], ];   note that, in case of clashing syntaxstring's,   the provided additional operators will override these.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g, \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g, \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parsetree(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parsetree(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parsetree(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nSee also SyntaxTree, syntaxstring, [].\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Grammar","page":"Getting started","title":"Grammar","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractAlphabet","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement a custom AbstractAlphabet concrete type. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"atoms(a::AbstractAlphabet)\n\nBase.in(p::Atom, a::AbstractAlphabet)\nBase.length(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet)\nExplicitAlphabet\nAlphabetOfAny\n\nAbstractGrammar\nalphabet(g::AbstractGrammar{A} where {A})\nBase.in(t::SyntaxTree, g::AbstractGrammar)\nformulas(g::AbstractGrammar; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing, args...)\n\nCompleteFlatGrammar{A<:AbstractAlphabet,O<:AbstractOperator}\nformulas(g::CompleteFlatGrammar{A,O} where {A,O}; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing)","category":"page"},{"location":"getting-started/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}","page":"Getting started","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxTree}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Semantics","page":"Getting started","title":"Semantics","text":"","category":"section"},{"location":"getting-started/#customization-section","page":"Getting started","title":"Customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc justo justo, finibus ac odio in, tempor fermentum augue. Vivamus ullamcorper lacus eget enim imperdiet, ac lobortis turpis elementum. Fusce non auctor eros. Duis scelerisque auctor volutpat. Morbi non luctus est. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Pellentesque porttitor a est sit amet ornare. Aliquam faucibus fringilla imperdiet.","category":"page"},{"location":"propositional-logic/","page":"Propositional logic","title":"Propositional logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"propositional-logic/","page":"Propositional logic","title":"Propositional logic","text":"Pages = [\"propositional-logic.md\"]","category":"page"},{"location":"propositional-logic/#propositional-logic","page":"Propositional logic","title":"Propositional Logic","text":"","category":"section"},{"location":"modal-logic/","page":"Modal logic","title":"Modal logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"modal-logic/","page":"Modal logic","title":"Modal logic","text":"Pages = [\"modal-logic.md\"]","category":"page"},{"location":"modal-logic/#modal-logic","page":"Modal logic","title":"Modal Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleLogics","category":"page"},{"location":"#SoleLogics","page":"Home","title":"SoleLogics","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleLogics, a Julia package for computational logic. SoleLogics.jl lays the logical foundations for Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleLogics.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleLogics\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl allows easy manipulation of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Syntax tokens (e.g., atoms, logical constants/connectives, etc.);\nAlphabets, grammars, algebras (e.g., crisp, fuzzy), logics (e.g., propositional and (multi)modal);\nFormulas (e.g., syntax trees, DNFs, CNFs): random generation, parsing, minimization;\nInterpretations (e.g., propositional assignments, Kripke structures);\nAlgorithms for evaluating the: validity/satisfiability of a formula, and truth of a formula on an interpretation (model checking).","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"CurrentModule = SoleLogics","category":"page"},{"location":"autodocs/#Full-reference-for-SoleLogics.jl","page":"Full reference","title":"Full reference for SoleLogics.jl","text":"","category":"section"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"Auto documentation for SoleLogics.jl.","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"Modules = [SoleLogics]","category":"page"},{"location":"autodocs/#SoleLogics.:¬","page":"Full reference","title":"SoleLogics.:¬","text":"const NEGATION = NamedOperator{:¬}()\nconst ¬ = NEGATION\narity(::Type{typeof(¬)}) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:→","page":"Full reference","title":"SoleLogics.:→","text":"const IMPLICATION = NamedOperator{:→}()\nconst → = IMPLICATION\narity(::Type{typeof(→)}) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:∧","page":"Full reference","title":"SoleLogics.:∧","text":"const CONJUNCTION = NamedOperator{:∧}()\nconst ∧ = CONJUNCTION\narity(::Type{typeof(∧)}) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:∨","page":"Full reference","title":"SoleLogics.:∨","text":"const DISJUNCTION = NamedOperator{:∨}()\nconst ∨ = DISJUNCTION\narity(::Type{typeof(∨)}) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.AbstractWorldSet","page":"Full reference","title":"SoleLogics.AbstractWorldSet","text":"const AbstractWorldSet{W} = Union{AbstractVector{W},AbstractSet{W}} where {W<:AbstractWorld}\nconst WorldSet{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases.\n\nSee also WorldSet, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BASE_OPERATORS","page":"Full reference","title":"SoleLogics.BASE_OPERATORS","text":"const BASE_OPERATORS = [⊤, ⊥, ¬, ∧, ∨, →]\n\nBasic logical operators.\n\nSee also TOP, BOTTOM, NEGATION, CONJUCTION, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BASE_PARSABLE_OPERATORS","page":"Full reference","title":"SoleLogics.BASE_PARSABLE_OPERATORS","text":"Operators considered valid by default, when parsing. Those are the vector SoleLogics.AbstractOperator[⊤, ⊥, ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=]].\n\nSee also parsetree.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BASE_PRECEDENCE","page":"Full reference","title":"SoleLogics.BASE_PRECEDENCE","text":"const MAX_PRECEDENCE  = Base.operator_precedence(:(::))\nconst HIGH_PRECEDENCE = Base.operator_precedence(:^)\nconst BASE_PRECEDENCE = Base.operator_precedence(:*)\nconst LOW_PRECEDENCE  = Base.operator_precedence(:+)\n\nStandard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.\n\nBy default, all operators are assigned a BASE_PRECEDENCE, except for:\n\nnullary operators (e.g., ⊤, ⊥), that are assigned a MAX_PRECEDENCE;\nunary operators (e.g., ¬, ◊), that are assigned a HIGH_PRECEDENCE;\nthe implication (→), that is assigned a LOW_PRECEDENCE.\n\nIn case of tie, operators are evaluated in the left-to-right order.\n\nIt is possible to assign a specific precedence to an operator type O by providing a method Base.operator_precedence(::Type{O}).\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also parseformula, syntaxstring.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BOTTOM","page":"Full reference","title":"SoleLogics.BOTTOM","text":"struct BottomOperator <: AbstractTruthOperator end\nconst BOTTOM = BottomOperator()\nconst ⊥ = BOTTOM\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BOX","page":"Full reference","title":"SoleLogics.BOX","text":"const BOX = NamedOperator{:□}()\nconst □ = BOX\narity(::Type{typeof(□)}) = 1\n\nLogical box operator, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.CONJUNCTION","page":"Full reference","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedOperator{:∧}()\nconst ∧ = CONJUNCTION\narity(::Type{typeof(∧)}) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.DIAMOND","page":"Full reference","title":"SoleLogics.DIAMOND","text":"const DIAMOND = NamedOperator{:◊}()\nconst ◊ = DIAMOND\nismodal(::NamedOperator{:◊}) = true\narity(::Type{typeof(◊)}) = 1\n\nLogical diamond operator, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.DISJUNCTION","page":"Full reference","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedOperator{:∨}()\nconst ∨ = DISJUNCTION\narity(::Type{typeof(∨)}) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.HIGH_PRECEDENCE","page":"Full reference","title":"SoleLogics.HIGH_PRECEDENCE","text":"const MAX_PRECEDENCE  = Base.operator_precedence(:(::))\nconst HIGH_PRECEDENCE = Base.operator_precedence(:^)\nconst BASE_PRECEDENCE = Base.operator_precedence(:*)\nconst LOW_PRECEDENCE  = Base.operator_precedence(:+)\n\nStandard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.\n\nBy default, all operators are assigned a BASE_PRECEDENCE, except for:\n\nnullary operators (e.g., ⊤, ⊥), that are assigned a MAX_PRECEDENCE;\nunary operators (e.g., ¬, ◊), that are assigned a HIGH_PRECEDENCE;\nthe implication (→), that is assigned a LOW_PRECEDENCE.\n\nIn case of tie, operators are evaluated in the left-to-right order.\n\nIt is possible to assign a specific precedence to an operator type O by providing a method Base.operator_precedence(::Type{O}).\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also parseformula, syntaxstring.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IA3Relations","page":"Full reference","title":"SoleLogics.IA3Relations","text":"const IA3Relations = [IA_I, IA_L, IA_Li]\n\nVector of 3 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA7Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IA7Relations","page":"Full reference","title":"SoleLogics.IA7Relations","text":"const IA7Relations = [IA_AorO,   IA_L,  IA_DorBorE,\n                      IA_AiorOi, IA_Li, IA_DiorBiorEi]\n\nVector of 7 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA3Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IABase","page":"Full reference","title":"SoleLogics.IABase","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IARelations","page":"Full reference","title":"SoleLogics.IARelations","text":"const IARelations = [IA_A,  IA_L,  IA_B,  IA_E,  IA_D,  IA_O,\n                     IA_Ai, IA_Li, IA_Bi, IA_Ei, IA_Di, IA_Oi]\n\nVector of the 12 interval relations from Allen's interval algebra.\n\nSee also IA7Relations, IA3Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IMPLICATION","page":"Full reference","title":"SoleLogics.IMPLICATION","text":"const IMPLICATION = NamedOperator{:→}()\nconst → = IMPLICATION\narity(::Type{typeof(→)}) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.LOW_PRECEDENCE","page":"Full reference","title":"SoleLogics.LOW_PRECEDENCE","text":"const MAX_PRECEDENCE  = Base.operator_precedence(:(::))\nconst HIGH_PRECEDENCE = Base.operator_precedence(:^)\nconst BASE_PRECEDENCE = Base.operator_precedence(:*)\nconst LOW_PRECEDENCE  = Base.operator_precedence(:+)\n\nStandard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.\n\nBy default, all operators are assigned a BASE_PRECEDENCE, except for:\n\nnullary operators (e.g., ⊤, ⊥), that are assigned a MAX_PRECEDENCE;\nunary operators (e.g., ¬, ◊), that are assigned a HIGH_PRECEDENCE;\nthe implication (→), that is assigned a LOW_PRECEDENCE.\n\nIn case of tie, operators are evaluated in the left-to-right order.\n\nIt is possible to assign a specific precedence to an operator type O by providing a method Base.operator_precedence(::Type{O}).\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also parseformula, syntaxstring.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.MAX_PRECEDENCE","page":"Full reference","title":"SoleLogics.MAX_PRECEDENCE","text":"const MAX_PRECEDENCE  = Base.operator_precedence(:(::))\nconst HIGH_PRECEDENCE = Base.operator_precedence(:^)\nconst BASE_PRECEDENCE = Base.operator_precedence(:*)\nconst LOW_PRECEDENCE  = Base.operator_precedence(:+)\n\nStandard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.\n\nBy default, all operators are assigned a BASE_PRECEDENCE, except for:\n\nnullary operators (e.g., ⊤, ⊥), that are assigned a MAX_PRECEDENCE;\nunary operators (e.g., ¬, ◊), that are assigned a HIGH_PRECEDENCE;\nthe implication (→), that is assigned a LOW_PRECEDENCE.\n\nIn case of tie, operators are evaluated in the left-to-right order.\n\nIt is possible to assign a specific precedence to an operator type O by providing a method Base.operator_precedence(::Type{O}).\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also parseformula, syntaxstring.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.NEGATION","page":"Full reference","title":"SoleLogics.NEGATION","text":"const NEGATION = NamedOperator{:¬}()\nconst ¬ = NEGATION\narity(::Type{typeof(¬)}) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.RCC5Relations","page":"Full reference","title":"SoleLogics.RCC5Relations","text":"const RCC5Relations = [Topo_DR, Topo_PO, Topo_PP, Topo_PPi]\n\nVector of the 4 relations from RCC5.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.RCC8Relations","page":"Full reference","title":"SoleLogics.RCC8Relations","text":"const RCC8Relations = [Topo_DC, Topo_EC, Topo_PO, Topo_TPP, Topo_TPPi, Topo_NTPP, Topo_NTPPi]\n\nVector of the 7 relations from RCC8.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.SYNTACTICAL","page":"Full reference","title":"SoleLogics.SYNTACTICAL","text":"const SYNTACTICAL = Union{AbstractSyntaxStructure,AbstractSyntaxToken}\n\nUnion type representing a generic AbstractSyntaxStructure or a single token in it.\n\nSee also AbstractSyntaxStructure, AbstractSyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TOP","page":"Full reference","title":"SoleLogics.TOP","text":"struct TopOperator <: AbstractTruthOperator end\nconst TOP = TopOperator()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOTTOM, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.globalrel","page":"Full reference","title":"SoleLogics.globalrel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(GlobalRel)\nGlobalRel\n\nSee also IdentityRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.identityrel","page":"Full reference","title":"SoleLogics.identityrel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(IdentityRel)\nIdentityRel\n\nSee also GlobalRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.tocenterrel","page":"Full reference","title":"SoleLogics.tocenterrel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also IdentityRel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.⊤","page":"Full reference","title":"SoleLogics.⊤","text":"struct TopOperator <: AbstractTruthOperator end\nconst TOP = TopOperator()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOTTOM, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.⊥","page":"Full reference","title":"SoleLogics.⊥","text":"struct BottomOperator <: AbstractTruthOperator end\nconst BOTTOM = BottomOperator()\nconst ⊥ = BOTTOM\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.□","page":"Full reference","title":"SoleLogics.□","text":"const BOX = NamedOperator{:□}()\nconst □ = BOX\narity(::Type{typeof(□)}) = 1\n\nLogical box operator, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.◊","page":"Full reference","title":"SoleLogics.◊","text":"const DIAMOND = NamedOperator{:◊}()\nconst ◊ = DIAMOND\nismodal(::NamedOperator{:◊}) = true\narity(::Type{typeof(◊)}) = 1\n\nLogical diamond operator, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedOperator, AbstractOperator.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.AbstractAlgebra","page":"Full reference","title":"SoleLogics.AbstractAlgebra","text":"abstract type AbstractAlgebra{T<:TruthValue} end\n\nAbstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a lattice structure where two elements(or nodes) ⊤ and ⊥ are referred to as top (or maximum) and bottom (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.\n\nImplementation\n\nWhen implementing a new algebra type, the methods domain, top, and bottom should be implemented.\n\nSee also domain, top, bottom, truthtype, iscrisp, `BooleanAlgebra, AbstractOperator, collatetruth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractAlphabet","page":"Full reference","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{A} end\n\nAbstract type for representing an alphabet of atoms with values of type A. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nSee also ExplicitAlphabet, AlphabetOfAny, atomstype, valuetype, Atom, AbstractGrammar.\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractAlphabet-Union{Tuple{Any}, Tuple{A}} where A","page":"Full reference","title":"SoleLogics.AbstractAlphabet","text":"An alphabet of valuetype A can be used for instantiating atoms of valuetype A.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.AbstractAssignment","page":"Full reference","title":"SoleLogics.AbstractAssignment","text":"abstract type AbstractAssignment{A,T<:TruthValue} <: AbstractInterpretation{A,T} end\n\nA propositional assigment (or, simply, an assigment) is a propositional interpretation, encoding a mapping from Atoms of value type A to truth values of type T.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractDimensionalFrame","page":"Full reference","title":"SoleLogics.AbstractDimensionalFrame","text":"abstract type AbstractDimensionalFrame{\n    N,\n    W<:AbstractWorld,\n} <: AbstractMultiModalFrame{W} end\n\nAbstract type for dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding dimensional frame is a graph where each vertex is an N-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).\n\nSee also  Interval, Interval2D, IntervalRelation, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractFormula","page":"Full reference","title":"SoleLogics.AbstractFormula","text":"abstract type AbstractFormula end\n\nA logical formula encoding a statement which truth can be evaluated on interpretations (or models) of the logic.\n\nIts syntactic component is canonically encoded via a syntax tree (see SyntaxTree), and it can be anchored to a logic (see Formula).\n\nImplementation\n\nWhen implementing a new formula type MyCustomFormulaType, please provide a method tree for extracting its syntax tree representation:\n\nfunction tree(f::MyCustomFormulaType)::SyntaxTree\n    ...\nend\n\nAs well as a method used for composing formulas:\n\nfunction (op::AbstractOperator)(\n    children::NTuple{N,Union{AbstractSyntaxToken,MyCustomFormulaType}},\n)::AbstractFormula where {N}\n    # Composed formula\nend\n\nSee also Formula, SyntaxTree, AbstractSyntaxStructure, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractFrame","page":"Full reference","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the structure to Kripke structures's).\n\nSee also truthtype, worldtype, allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractGrammar","page":"Full reference","title":"SoleLogics.AbstractGrammar","text":"abstract type AbstractGrammar{A<:AbstractAlphabet,O<:AbstractOperator} end\n\nAbstract type for representing a context-free grammar based on a single alphabet of type A, and a set of operators that consists of all the (singleton) child types of O. A context-free grammar is a simple structure for defining formulas inductively.\n\nSee also alphabet, atomstype, tokenstype, operatorstype, alphabettype, AbstractAlphabet, AbstractOperator.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractInterpretation","page":"Full reference","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation{A,T<:TruthValue} end\n\nAbstract type for representing a propositional interpretation (or propositional model) that associates truth values of a type T to atoms of value type A. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractInterpretationSet","page":"Full reference","title":"SoleLogics.AbstractInterpretationSet","text":"abstract type AbstractInterpretationSet{M<:AbstractInterpretation} <: AbstractDataset end\n\nAbstract type for ordered sets of interpretations. A set of interpretations, also referred to as a dataset in this context, is a collection of instances, each of which is an interpretation, and is identified by an index iinstance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Modelchecking).\n\nSee also valuetype, truthtype, InterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractKripkeStructure","page":"Full reference","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure{\n    W<:AbstractWorld,\n    A,\n    T<:TruthValue,\n    FR<:AbstractFrame{W},\n} <: AbstractInterpretation{A,T} end\n\nAbstract type for representing Kripke structures's). It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms of value type A to truth values of type T.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractLogic","page":"Full reference","title":"SoleLogics.AbstractLogic","text":"abstract type AbstractLogic{G<:AbstractGrammar,A<:AbstractAlgebra} end\n\nAbstract type of a logic, which comprehends a context-free grammar (syntax) and an algebra (semantics).\n\nImplementation\n\nWhen implementing a new logic type, the methods grammar and algebra should be implemented.\n\nSee also AbstractGrammar, AbstractAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractMultiModalFrame","page":"Full reference","title":"SoleLogics.AbstractMultiModalFrame","text":"abstract type AbstractMultiModalFrame{\n    W<:AbstractWorld,\n} <: AbstractFrame{W} end\n\nA frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.\n\nImplementation\n\nWhen implementing a new multi-modal frame type, the logical semantics for the frame should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractUniModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractOperator","page":"Full reference","title":"SoleLogics.AbstractOperator","text":"abstract type AbstractOperator <: AbstractSyntaxToken end\n\nAn operator is a logical constant which establishes a relation between atoms (i.e., facts). For example, the boolean operators AND, OR and IMPLIES (stylized as ∧, ∨ and →) are used to connect atoms and/or formulas to express derived concepts.\n\nSince operators often display very different algorithmic behaviors, leaf subtypes of AbstractOperator are often singleton types, which can be easily dispatched upon.\n\nImplementation\n\nWhen implementing a new custom operator, think about changing its default precedence and associativity by providing the methods Base.operator_precedence(::Type{AbstractOperator}) and isrightassociative(::Type{AbstractOperator}).\n\nWhen implementing a new type for a commutative operator O with arity higher than 1, please provide a method iscommutative(::Type{O}). This can help model checking operations.\n\nSee also AbstractSyntaxToken, NamedOperator, Base.operator_precedence, isrightassociative, iscommutative, check.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractOperator-Tuple{Any}","page":"Full reference","title":"SoleLogics.AbstractOperator","text":"An operator can be used to compose syntax tokens (e.g., atoms), syntax trees and/or formulas. This is quite handy, try it:\n\n¬(Atom(1)) ∨ Atom(1) ∧ ⊤\n∧(⊤,⊤)\n⊤()\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.AbstractRelation","page":"Full reference","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::Type{R})::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric relation, please specify its converse relation CR with:\n\nhasconverse(::Type{R}) = true\nconverse(::Type{R}) = CR\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::Type{R}) = true\nistransitive(::Type{R}) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, IdentityRel, GlobalRel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractRelationalOperator","page":"Full reference","title":"SoleLogics.AbstractRelationalOperator","text":"abstract type AbstractRelationalOperator{R<:AbstractRelation} <: AbstractOperator end\n\nAbstract type for relational logical operators. A relational operator allows for semantic quantification across relational structures (e.g., Krikpe structures). It has arity equal to the arity of its underlying relation minus one.\n\nSee, for example temporal modal logic.\n\nSee also DiamondRelationalOperator, BoxRelationalOperator, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractSyntaxStructure","page":"Full reference","title":"SoleLogics.AbstractSyntaxStructure","text":"abstract type AbstractSyntaxStructure <: AbstractFormula end\n\nA logical formula, represented by its syntactic component. The typical representation is the SyntaxTree; however, different implementations can cover specific synctactic forms (e.g., conjuctive/disjuctive normal forms).\n\nSee also tree, SyntaxTree, AbstractFormula, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractSyntaxToken","page":"Full reference","title":"SoleLogics.AbstractSyntaxToken","text":"abstract type AbstractSyntaxToken end\n\nA token in a syntactic structure.\n\nSee also SyntaxTree, AbstractSyntaxStructure, arity, syntaxstring.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractTruthOperator","page":"Full reference","title":"SoleLogics.AbstractTruthOperator","text":"abstract type AbstractTruthOperator <: AbstractOperator end\n\nA nullary operator wrapping a truth value; in fact, truth values can be used in formulas. Two canonical truth values that are used as nullary operators are ⊤ (top) and ⊥ (bottom), representing truth (true) and falsity (false), respectively.\n\nSee also TOP, BOTTOM, TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractUniModalFrame","page":"Full reference","title":"SoleLogics.AbstractUniModalFrame","text":"abstract type AbstractUniModalFrame{\n    W<:AbstractWorld,\n} <: AbstractFrame{W} end\n\nA frame of a modal logic based on a single (implicit) accessibility relation.\n\nSee also AbstractMultiModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractWorld","page":"Full reference","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semanticsu should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AlphabetOfAny","page":"Full reference","title":"SoleLogics.AlphabetOfAny","text":"struct AlphabetOfAny{A} <: AbstractAlphabet{A} end\n\nAn implicit, infinite alphabet that includes all atoms with values of a subtype of A.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Atom","page":"Full reference","title":"SoleLogics.Atom","text":"struct Atom{A} <: AbstractSyntaxToken\n    value::A\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{A} wraps a value::A representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractSyntaxToken, AbstractInterpretation, check.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BaseLogic","page":"Full reference","title":"SoleLogics.BaseLogic","text":"struct BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra} <: AbstractLogic{G,A}\n    grammar::G\n    algebra::A\nend\n\nA basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.\n\nSee also grammar, algebra, AbstractGrammar, AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BooleanAlgebra","page":"Full reference","title":"SoleLogics.BooleanAlgebra","text":"struct BooleanAlgebra <: AbstractAlgebra{Bool} end\n\nA boolean algebra, defined on the values true (for top) and false (for bottom). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, respectively.\n\nSee also TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BottomOperator","page":"Full reference","title":"SoleLogics.BottomOperator","text":"struct BottomOperator <: AbstractTruthOperator end\nconst BOTTOM = BottomOperator()\nconst ⊥ = BOTTOM\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.CNF","page":"Full reference","title":"SoleLogics.CNF","text":"struct LeftmostLinearForm{O<:AbstractOperator,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of an operator O. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.CompleteFlatGrammar","page":"Full reference","title":"SoleLogics.CompleteFlatGrammar","text":"struct CompleteFlatGrammar{A<:AbstractAlphabet,O<:AbstractOperator} <: AbstractGrammar{A,O}\n    alphabet::A\n    operators::Vector{<:O}\nend\n\nA grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type A, and all operators in operators. With n operators, this grammar has exactly n+1 production rules. For example, with operators = [⊥,∧,∨], the grammar (in Backus-Naur form) is:\n\nφ ::= p | ⊥ | φ ∧ φ | φ ∨ φ\n\nwith p ∈ alphabet. Note: it is flat in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.\n\nSee also alphabet, operators, nonterminals, terminals, formulas, AbstractOperator, AbstractGrammar.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DNF","page":"Full reference","title":"SoleLogics.DNF","text":"struct LeftmostLinearForm{O<:AbstractOperator,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of an operator O. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DefaultedTruthDict","page":"Full reference","title":"SoleLogics.DefaultedTruthDict","text":"struct DefaultedTruthDict{\n    A,\n    T<:TruthValue,\n    D<:AbstractDict{<:Atom{<:A},T}\n} <: AbstractAssignment{A,T}\n    truth::D\n    default_truth::T\nend\n\nA truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns default_truth.\n\nExamples\n\njulia> t1 = DefaultedTruthDict(string.(1:4), false); t1[\"5\"] = false; t1\nDefaultedTruthDict with default truth `false` and values:\n┌────────┬────────┬────────┬────────┬────────┐\n│      4 │      1 │      5 │      2 │      3 │\n│ String │ String │ String │ String │ String │\n├────────┼────────┼────────┼────────┼────────┤\n│   true │   true │  false │   true │   true │\n└────────┴────────┴────────┴────────┴────────┘\n\n\njulia> check(parsebaseformula(\"1 ∨ 2\"), t1)\ntrue\n\njulia> check(parsebaseformula(\"1 ∧ 5\"), t1)\nfalse\n\n\nSee also TruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DiamondRelationalOperator","page":"Full reference","title":"SoleLogics.DiamondRelationalOperator","text":"struct DiamondRelationalOperator{R<:AbstractRelation} <: AbstractRelationalOperator{R} end\nstruct BoxRelationalOperator{R<:AbstractRelation} <: AbstractRelationalOperator{R} end\n\nSingleton types for relational operators, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth operators can be easily instantiated with relation instances, such as DiamondRelationalOperator(rel), which is a shortcut for DiamondRelationalOperator{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalOperator(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalOperator(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalOperator(IA_A) == SoleLogics.dual(BoxRelationalOperator(IA_A))\n\n\nSee also DiamondRelationalOperator, BoxRelationalOperator, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ExplicitAlphabet","page":"Full reference","title":"SoleLogics.ExplicitAlphabet","text":"struct ExplicitAlphabet{A} <: AbstractAlphabet{A}\n    atoms::Vector{Atom{A}}\nend\n\nAn alphabet wrapping atoms in a (finite) Vector.\n\nSee also atoms, AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ExplicitCrispUniModalFrame","page":"Full reference","title":"SoleLogics.ExplicitCrispUniModalFrame","text":"TODO\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Formula","page":"Full reference","title":"SoleLogics.Formula","text":"struct Formula{L<:AbstractLogic} <: AbstractFormula\n    _logic::Base.RefValue{L}\n    synstruct::AbstractSyntaxStructure\nend\n\nA formula anchored to a logic of type L, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.\n\nUpon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:\n\ncheck_atoms::Bool = false: whether to perform or not a check that the atoms   belong to the alphabet of the logic;\ncheck_tree::Bool = false: whether to perform or not a check that the formula's syntactic structure   honors the grammar (includes the check performed with check_atoms = true) (TODO);\n\nCool feature: a Formula can be used for instating other formulas of the same logic. See the examples.\n\nExamples\n\njulia> f = parsebaseformula(\"◊(p→q)\");\n\njulia> f2 = f(parseformula(\"p\"));\n\njulia> syntaxstring(f)\n\"◊(→(p, q))\"\n\njulia> syntaxstring(f2)\n\"p\"\n\njulia> @assert logic(f) == logic(f2)\n\njulia> @assert ◊ in operators(logic(f2))\n\njulia> @assert ◊ isa operatorstype(logic(f2))\n\n\nSee also tree, logic, AbstractSyntaxToken, SyntaxTree, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.FullDimensionalFrame","page":"Full reference","title":"SoleLogics.FullDimensionalFrame","text":"struct FullDimensionalFrame{N,W<:AbstractWorld} <: AbstractDimensionalFrame{N,W}\n    channelsize::NTuple{N,Int}\nend\n\nAbstract type for full dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding full dimensional frame is a graph where there is exactly one vertex for each N-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).\n\nHere, a N-hyperrectangle is an N tuple of intervals, where each interval is a pair of natural numbers (x,y) where: i) x > 0; ii) y > 0; iii) x < y.\n\nThe current implementation can handle N ∈ {0,1,2}.\n\nExamples\n\njulia> SoleLogics.allworlds(SoleLogics.FullDimensionalFrame((),))\n1-element Vector{OneWorld}:\n −\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,),))\n55\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,10),))\n3025\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also  OneWorld, Interval, Interval2D, IntervalRelation, IntervalRelation2D, accessibles, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GeometricalRelation","page":"Full reference","title":"SoleLogics.GeometricalRelation","text":"abstract type GeometricalWorld <: AbstractRelation end\n\nAbstract type for relations with a geometrical interpretation.\n\nSee also istopological, IntervalRelation, RectangleRelation, RCCRelation, AbstractRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GeometricalWorld","page":"Full reference","title":"SoleLogics.GeometricalWorld","text":"abstract type GeometricalWorld <: AbstractWorld end\n\nAbstract type for worlds with a geometrical interpretation.\n\nSee also Point, Interval, Interval2D, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GlobalRel","page":"Full reference","title":"SoleLogics.GlobalRel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(GlobalRel)\nGlobalRel\n\nSee also IdentityRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IdentityRel","page":"Full reference","title":"SoleLogics.IdentityRel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(IdentityRel)\nIdentityRel\n\nSee also GlobalRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.InterpretationSet","page":"Full reference","title":"SoleLogics.InterpretationSet","text":"struct InterpretationSet{M<:AbstractInterpretation} <: AbstractInterpretationSet{M}\n    instances::Vector{M}\nend\n\nA dataset of interpretations instantiated as a vector.\n\nAbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Interval","page":"Full reference","title":"SoleLogics.Interval","text":"struct Interval{T} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Interval2D","page":"Full reference","title":"SoleLogics.Interval2D","text":"struct Interval2D{T} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IntervalRelation","page":"Full reference","title":"SoleLogics.IntervalRelation","text":"abstract type IntervalRelation <: GeometricalRelation end\n\nAbstract type for interval binary relations. Originally defined by Allen in 1983, interval algebra comprehends 12 directional relations between intervals, plus the identity (i.e., identityrel).\n\nThe 12 relations are the 6 relations after, later, begins, ends, during, overlaps, and their inverses.\n\nIf we consider a reference interval (x,y), we can graphically represent the 6 base relations by providing an example of a world (z,t) that is accessible via each of them:\n\nRELATION    ABBR.     x                   y                     PROPERTY                                         |–––––––––-|                                                                      .                   .                                                                      .                   z        t            y = z                      After       (A)       .                   |––––|                                                             .                   .                                                                      .                   .   z         t       y < z                      Later       (L)       .                   .   |––––-|                                                        .                   .                                                                      z     t             .                     x = z, t < y               Begins      (B)       |––-|             .                                                                      .                   .                                                                      .             z     t                     y = t, x < z               Ends        (E)       .             |––-|                                                                      .                   .                                                                      .   z        t      .                     x < z, t < y               During      (D)       .   |––––|      .                                                                      .                   .                                                                      .           z       .    t                x < z < y < t              Overlaps    (O)       .           |––––––|                                          \n\nCoarser relations can be defined by union of these 12 relations.\n\nExamples\n\njulia> IARelations\n12-element Vector{IntervalRelation}:\n _IA_A()\n _IA_L()\n _IA_B()\n _IA_E()\n _IA_D()\n _IA_O()\n _IA_Ai()\n _IA_Li()\n _IA_Bi()\n _IA_Ei()\n _IA_Di()\n _IA_Oi()\n\njulia> @assert SoleLogics._IA_L() == IA_L\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(2,5), IA_L))\n15-element Vector{Interval{Int64}}:\n (6−7)\n (6−8)\n (7−8)\n (6−9)\n (7−9)\n (8−9)\n (6−10)\n (7−10)\n (8−10)\n (9−10)\n (6−11)\n (7−11)\n (8−11)\n (9−11)\n (10−11)\n\njulia> syntaxstring.(IARelations)\n12-element Vector{String}:\n \"A\"\n \"L\"\n \"B\"\n \"E\"\n \"D\"\n \"O\"\n \"A̅\"\n \"L̅\"\n \"B̅\"\n \"E̅\"\n \"D̅\"\n \"O̅\"\n\njulia> syntaxstring.(IA7Relations)\n6-element Vector{String}:\n \"A∨O\"\n \"L\"\n \"D∨B∨E\"\n \"A̅∨O̅\"\n \"L̅\"\n \"D̅∨B̅∨E̅\"\n\njulia> syntaxstring.(SoleLogics.IA3Relations)\n3-element Vector{String}:\n \"I\"\n \"L\"\n \"L̅\"\n\n\nSee also IARelations, IA7Relations, IA3Relations, Interval, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.KripkeStructure","page":"Full reference","title":"SoleLogics.KripkeStructure","text":"struct KripkeStructure{\n    W<:AbstractWorld,\n    A,\n    T<:TruthValue,\n    FR<:AbstractFrame{W},\n    AS<:AbstractDict{W,A where A<:AbstractAssignment{A,T}}\n} <: AbstractKripkeStructure{W,A,T,FR}\n    frame::FR\n    assignment::AS\nend\n\nType for representing Kripke structures's). explicitly; it wraps a frame, and an abstract dictionary that assigns an interpretation to each world.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostConjunctiveForm","page":"Full reference","title":"SoleLogics.LeftmostConjunctiveForm","text":"struct LeftmostLinearForm{O<:AbstractOperator,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of an operator O. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostDisjunctiveForm","page":"Full reference","title":"SoleLogics.LeftmostDisjunctiveForm","text":"struct LeftmostLinearForm{O<:AbstractOperator,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of an operator O. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostLinearForm","page":"Full reference","title":"SoleLogics.LeftmostLinearForm","text":"struct LeftmostLinearForm{O<:AbstractOperator,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of an operator O. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\nSee also AbstractSyntaxStructure, SyntaxTree, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, Literal.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Literal","page":"Full reference","title":"SoleLogics.Literal","text":"struct Literal{T<:AbstractSyntaxToken} <: AbstractSyntaxStructure\n    ispos::Bool\n    prop::T\nend\n\nAn atom, or its negation.\n\nSee also CNF, DNF, AbstractSyntaxStructure.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.NamedOperator","page":"Full reference","title":"SoleLogics.NamedOperator","text":"struct NamedOperator{Symbol} <: AbstractOperator end\n\nA singleton type for representing operators defined by a name or a symbol.\n\nExamples\n\nThe AND operator (logical conjuction) is defined as the subtype:\n\nconst CONJUNCTION = NamedOperator{:∧}()\nconst ∧ = CONJUNCTION\narity(::Type{typeof(∧)}) = 2\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, AbstractOperator.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.NamedRelation","page":"Full reference","title":"SoleLogics.NamedRelation","text":"struct NamedRelation{T} <: AbstractRelation\n    name::T\nend\n\nType for relations that are solely defined by their name.\n\nSee also AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.OneWorld","page":"Full reference","title":"SoleLogics.OneWorld","text":"struct OneWorld <: AbstractWorld end\n\nA singleton world to be used in modal frames with a single, unique world. This usage effectively simulates a propositional context. Note that it is compatible with 0-dimensional datasets.\n\nSee also Interval, Interval2D, goeswithdim, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Point","page":"Full reference","title":"SoleLogics.Point","text":"struct Point{N,T} <: GeometricalWorld\n    xyz :: NTuple{N,T}\nend\n\nA point in an N-dimensional space, with integer coordinates.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),3)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),2)\nfalse\n\n\nSee also goeswithdim, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.RCCRelation","page":"Full reference","title":"SoleLogics.RCCRelation","text":"abstract type RCCRelation <: GeometricalRelation end\n\nTopological binary relations from Region Connection Calculus. Region Connection Calculus (RCC) is most famous for RCC8, a set of 8 topological relations, which comprehends the identity relation (i.e., `identityrel'), and the following 7 relations:\n\nExternally connected\nPartially overlapping\nTangential proper part\nTangential proper part inverse\nNon-tangential proper part\nNon-tangential proper part inverse\n\nIf we consider a reference interval (x,y), we can graphically represent the 7  relations by providing an example of a world (z,t) that is accessible via each of them:\n\n                                             x                   y\n\nRELATION                             ABBR.       |–––––––––-|                                                  .                   .                                                  .                   .  z        t Disconnected                         (DC)        .                   . |––––|                                                  .                   .                                                  .                   z         t Externally connected                 (EC)        .                   |––––-|                                                  .                   .                                                  .                z     t Partially overlapping                (PO)        .                |––-|                                                  .                   .                                                  .             z     t Tangential proper part               (TPP)       .             |––-|                                                  .                   .                                                  z                   .     t Tangential proper part inverse       (T̅P̅P̅)       |––––––––––––-|                                                  .                   .                                                  .           z       . Non-tangential proper part           (NTPP)      .           |––-| .                                                  .                   .                                                z .                   . t Non-tangential proper part inverse   (N̅T̅P̅P̅)    |–––––––––––-|\n\nMethods for RCC8 relations and Interval2D's can be obtained by combining their 1D versions, according to the following composition rules:\n\n             .-------------------------------------------------------.\n             |         DC   EC   PO   TPP   T̅P̅P̅   NTPP   N̅T̅P̅P̅    Id  |\n             |-------------------------------------------------------|\n             | DC   |  DC | DC | DC | DC  | DC  |  DC  |  DC  |  DC  |\n             | EC   |  DC | EC | EC | EC  | EC  |  EC  |  EC  |  EC  |\n             | PO   |  DC | EC | PO | PO  | PO  |  PO  |  PO  |  PO  |\n             | TPP  |  DC | EC | PO | TPP | PO  |  TPP |  PO  |  TPP |\n             | T̅P̅P̅  |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  |  T̅P̅P̅ |  T̅P̅P̅ |\n             | NTPP |  DC | EC | PO | TPP | PO  | NTPP |  PO  |  TPP |\n             | N̅T̅P̅P̅ |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  | N̅T̅P̅P̅ |  T̅P̅P̅ |\n             |  Id  |  DC | EC | PO | TPP | T̅P̅P̅ |  TPP |  T̅P̅P̅ |  Id  |\n             '-------------------------------------------------------'\n\nExamples\n\njulia> RCC8Relations\n7-element Vector{RCCRelation}:\n _Topo_DC()\n _Topo_EC()\n _Topo_PO()\n _Topo_TPP()\n _Topo_TPPi()\n _Topo_NTPP()\n _Topo_NTPPi()\n\njulia> @assert SoleLogics._Topo_DC() == Topo_DC\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(4,8), Topo_DC))\n6-element Vector{Interval{Int64}}:\n (9−10)\n (9−11)\n (10−11)\n (1−2)\n (1−3)\n (2−3)\n\njulia> syntaxstring.(RCC8Relations)\n7-element Vector{String}:\n \"DC\"\n \"EC\"\n \"PO\"\n \"TPP\"\n \"T̅P̅P̅\"\n \"NTPP\"\n \"N̅T̅P̅P̅\"\n\njulia> RCC5Relations\n4-element Vector{RCCRelation}:\n _Topo_DR()\n _Topo_PO()\n _Topo_PP()\n _Topo_PPi()\n\nSee also  RCC8Relations, RCC5Relations, Interval, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.RectangleRelation","page":"Full reference","title":"SoleLogics.RectangleRelation","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.SyntaxTree","page":"Full reference","title":"SoleLogics.SyntaxTree","text":"struct SyntaxTree{\n    T<:AbstractSyntaxToken,\n} <: AbstractSyntaxStructure\n    token::T\n    children::NTuple{N,SyntaxTree} where {N}\nend\n\nA syntax tree encoding a logical formula. Each node of the syntax tree holds a token, and has as many children as the arity of the token.\n\nThis implementation is arity-compliant, in that, upon construction, the arity is checked against the number of children provided.\n\nSee also token, children, tokentype, tokens, operators, atoms, ntokens, natoms, height, tokenstype, operatorstype, atomstype, AbstractSyntaxToken, arity, Atom, AbstractOperator.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ToCenteredRel","page":"Full reference","title":"SoleLogics.ToCenteredRel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also IdentityRel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TopOperator","page":"Full reference","title":"SoleLogics.TopOperator","text":"struct TopOperator <: AbstractTruthOperator end\nconst TOP = TopOperator()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOTTOM, AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthDict","page":"Full reference","title":"SoleLogics.TruthDict","text":"struct TruthDict{\n    A,\n    T<:TruthValue,\n    D<:AbstractDict{<:Atom{<:A},T}\n} <: AbstractAssignment{A,T}\n    truth::D\nend\n\nA logical interpretation instantiated as a dictionary, explicitly assigning truth values to a finite set of atoms. If prompted for the value of an unknown atom, it throws an error.\n\nExamples\n\njulia> TruthDict(1:4)\nTruthDict with values:\n┌───────┬───────┬───────┬───────┐\n│     4 │     2 │     3 │     1 │\n│ Int64 │ Int64 │ Int64 │ Int64 │\n├───────┼───────┼───────┼───────┤\n│  true │  true │  true │  true │\n└───────┴───────┴───────┴───────┘\n\n\njulia> t1 = TruthDict(1:4, false); t1[5] = true; t1\nTruthDict with values:\n┌───────┬───────┬───────┬───────┬───────┐\n│     5 │     4 │     2 │     3 │     1 │\n│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │\n├───────┼───────┼───────┼───────┼───────┤\n│  true │ false │ false │ false │ false │\n└───────┴───────┴───────┴───────┴───────┘\n\n\njulia> t2 = TruthDict([\"a\" => true, \"b\" => false, \"c\" => true])\nTruthDict with values:\n┌────────┬────────┬────────┐\n│      c │      b │      a │\n│ String │ String │ String │\n├────────┼────────┼────────┤\n│   true │  false │   true │\n└────────┴────────┴────────┘\n\njulia> check(parsebaseformula(\"a ∨ b\"), t2)\ntrue\n\n\nSee also DefaultedTruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthOperator","page":"Full reference","title":"SoleLogics.TruthOperator","text":"struct TruthOperator{T<:TruthValue} <: AbstractTruthOperator\n    value::T\nend\n\nA truth operator wrapping a truth value of a given type.\n\nSee also AbstractTruthOperator, TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthTable","page":"Full reference","title":"SoleLogics.TruthTable","text":"struct TruthTable{A,T<:TruthValue}\n\nDictionary which associates an AbstractAssignments to the truth value of the assignment itself on a AbstractSyntaxStructure.\n\nSee also AbstractAssignment, AbstractSyntaxStructure, TruthValue.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthValue","page":"Full reference","title":"SoleLogics.TruthValue","text":"Type alias for any Julia type that may instantiate truth values. In the crisp case, Bool values are used. In the fuzzy case, other values can be used. For example, AbstractFloats can be used with chain algebras, and 0.0 and 1.0 are the bottom and top.\n\nSee also top, bottom, istop, isbottom, Algebra.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.World","page":"Full reference","title":"SoleLogics.World","text":"struct World{T} <: AbstractWorld\n    name::T\nend\n\nA world that is solely identified by its name. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.\n\nSee also OneWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.WorldSet","page":"Full reference","title":"SoleLogics.WorldSet","text":"const AbstractWorldSet{W} = Union{AbstractVector{W},AbstractSet{W}} where {W<:AbstractWorld}\nconst WorldSet{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases.\n\nSee also AbstractWorldSet, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.WrapperMultiModalFrame","page":"Full reference","title":"SoleLogics.WrapperMultiModalFrame","text":"struct WrapperMultiModalFrame{\n    W<:AbstractWorld,\n    D<:AbstractDict{<:AbstractRelation,<:AbstractUniModalFrame{W}}\n} <: AbstractMultiModalFrame{W}\n    frames::D\nend\n\nA multi-modal frame that is the superposition of many uni-modal frames. It uses a single AbstractUniModalFrame for each of relations.\n\nSee also AbstractRelation, AbstractUniModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#Base.getindex-Union{Tuple{T}, Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA, T}, Atom, Vararg{Any}}} where {AA, T}","page":"Full reference","title":"Base.getindex","text":"Base.getindex(i::AbstractAssignment{AA,T}, p::Atom, args...)::T where {AA,T<:TruthValue}\n\nReturn the truth value of an atom, given an assignment.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.haskey-Union{Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA}, Atom}} where AA","page":"Full reference","title":"Base.haskey","text":"Base.haskey(::Atom{A}, i::AbstractAssignment{A})::Bool where {A}\n\nReturn whether an assigment has a truth value for a given atom.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{AbstractSyntaxToken, AbstractFormula}","page":"Full reference","title":"Base.in","text":"Base.in(tok::AbstractSyntaxToken, f::AbstractFormula)::Bool\n\nReturn whether a syntax token appears in a formula.\n\nSee also AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{AbstractSyntaxToken, SyntaxTree}","page":"Full reference","title":"Base.in","text":"Base.in(tok::AbstractSyntaxToken, tree::SyntaxTree)::Bool\n\nReturn whether a token appears in a syntax tree or not.\n\nSee also tokens, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.in","text":"Base.in(p::Atom, a::AbstractAlphabet)::Bool\n\nReturn whether an atom belongs to an alphabet.\n\nSee also AbstractAlphabet, Atom.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}","page":"Full reference","title":"Base.in","text":"Base.in(t::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a formula, encoded as a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.iterate","text":"Base.iterate(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet, state)\n\nReturn an iterator to the next element in an alhabet.\n\nSee also AbstractAlphabet, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.length-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.length","text":"Base.length(a::AbstractAlphabet)::Bool\n\nReturn the alphabet length, if it is finite.\n\nSee also AbstractAlphabet, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.operator_precedence-Tuple{SoleLogics.AbstractOperator}","page":"Full reference","title":"Base.operator_precedence","text":"Base.operator_precedence(op::AbstractOperator)\nBase.operator_precedence(::typeof(IMPLICATION))\n\nAssign a precedence to an operator.\n\nSee also AbstractOperator, MAX_PRECEDENCE, HIGH_PRECEDENCE, BASE_PRECEDENCE, LOW_PRECEDENCE.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.rand-Tuple{Any, Vararg{Any}}","page":"Full reference","title":"Base.rand","text":"function Base.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG, ]\n    alphabet,\n    args...;\n    kwargs...\n)::Atom\n\nRandomly sample an atom from an alphabet, according to a uniform distribution.\n\nImplementation\n\nIf the alphabet is finite, the function defaults to rand(rng, atoms(alphabet)); otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also isfinite, `AbstractAlphabet'.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.accessibles","text":"accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractVector{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Vector{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, A}}, Tuple{A}, Tuple{G}} where {G, A}","page":"Full reference","title":"SoleLogics.algebra","text":"algebra(l::AbstractLogic{G,A})::A where {G,A}\n\nReturn the algebra of a given logic.\n\nSee also AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.allworlds","text":"allworlds(fr::AbstractFrame{W})::AbstractVector{<:W} where {W<:AbstractWorld}\n\nReturn all worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}","page":"Full reference","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{A} where {A})::A\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.arity-Tuple{Type{<:AbstractRelation}}","page":"Full reference","title":"SoleLogics.arity","text":"arity(::Type{<:AbstractRelation})::Integer\narity(t::AbstractRelation)::Integer = arity(typeof(t))\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.arity-Tuple{Type{<:AbstractSyntaxToken}}","page":"Full reference","title":"SoleLogics.arity","text":"arity(::Type{<:AbstractSyntaxToken})::Integer\narity(tok::AbstractSyntaxToken)::Integer = arity(typeof(tok))\n\nReturn the arity of a syntax token. The arity of a syntax token is an integer representing the number of allowed children in a SyntaxTree. Tokens with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively.\n\nSee also AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.atoms-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.atoms","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"SoleLogics.atoms","text":"atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nList the atoms of a finite alphabet.\n\nSee also AbstractAlphabet, Base.isfinite.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.atoms-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.atoms","text":"atoms(t::SyntaxTree)::AbstractVector{Atom}\n\nList all atoms appearing in a syntax tree.\n\nSee also natoms, operators, tokens, Atom.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.baseformula-Tuple{Union{AbstractFormula, SYNTACTICAL}}","page":"Full reference","title":"SoleLogics.baseformula","text":"function baseformula(\n    tokf::Union{AbstractSyntaxToken,AbstractFormula};\n    infer_logic = true,\n    additional_operators::Union{Nothing,Vector{<:AbstractOperator}} = nothing,\n    kwargs...,\n)\n\nAttempt at instantiating a Formula from a syntax token/formula, by inferring the logic it belongs to. If infer_logic is true, then a canonical logic (e.g., propositional logic with all the BASE_PROPOSITIONAL_OPERATORS) is inferred; if it's false, then a logic with exactly the operators appearing in the syntax tree, plus the additional_operators is instantiated.\n\nExamples\n\njulia> t = parseformula(\"◊((p∧q)→r)\");\n\njulia> operators(logic(SoleLogics.baseformula(t)))\n3-element Vector{Union{SoleLogics.NamedOperator{:→}, SoleLogics.NamedOperator{:◊}, SoleLogics.NamedOperator{:∧}}}:\n ∧\n ◊\n →\n\njulia> operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_OPERATORS)))\n8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedOperator{:¬}, SoleLogics.NamedOperator{:∧}, SoleLogics.NamedOperator{:∨}, SoleLogics.NamedOperator{:→}, SoleLogics.NamedOperator{:◊}, SoleLogics.NamedOperator{:□}, SoleLogics.TopOperator}}:\n ⊤\n ⊥\n ¬\n ∧\n ∨\n →\n ◊\n □\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.bottom-Tuple{SoleLogics.AbstractAlgebra}","page":"Full reference","title":"SoleLogics.bottom","text":"bottom(a::AbstractAlgebra)\n\nReturn the bottom of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.box-Tuple{}","page":"Full reference","title":"SoleLogics.box","text":"\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Full reference","title":"SoleLogics.centralworld","text":"Return the world at the center of the frame; note that this does not always exist.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}","page":"Full reference","title":"SoleLogics.check","text":"function check(\n    f::AbstractFormula,\n    is::InterpretationSet,\n    i_instance::Integer,\n    args...\n)\n\nDispatch to check a specific AbstractInterpretation in a InterpretationSet over a formula.\n\nSee also AbstractInterpretation, InterpretationSet, AbstractFormula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractAssignment, Vararg{Any}}","page":"Full reference","title":"SoleLogics.check","text":"check(\n    f::AbstractFormula,\n    i::AbstractAssignment::{A,T},\n    args...\n)::T where {A,T<:TruthValue}\n\nCheck a logical formula on an assigment, returning a truth value. The (finite) model checking algorithm depends on the given logic.\n\nSee also TruthDict, SyntaxTree, AbstractFormula, AbstractAlgebra, AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFormula, SoleLogics.AbstractInterpretation{A, T}, Vararg{Any}}} where {A, T}","page":"Full reference","title":"SoleLogics.check","text":"check(\n    f::AbstractFormula,\n    m::AbstractInterpretation{A,T},\n    args...\n)::T where {A,T<:TruthValue}\n\nCheck a formula on a logical interpretation (or model), returning a truth value. This process is referred to as model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => true, q => false])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│  false │   true │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also AbstractFormula, AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{W}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR<:SoleLogics.AbstractFrame{W}}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR<:SoleLogics.AbstractFrame{W}, Union{Nothing, AbstractWorld}}} where {W<:AbstractWorld, A, T}","page":"Full reference","title":"SoleLogics.check","text":"function check(     φ::SyntaxTree,     i::AbstractKripkeStructure{W,A,T},     w::Union{Nothing,<:AbstractWorld} = nothing;     usememo::Union{Nothing,AbstractDict{<:AbstractFormula,<:WorldSet}} = nothing,     performnormalization::Bool = true,     memomaxheight::Union{Nothing,Int} = nothing, )::T where {W<:AbstractWorld,A,T<:TruthValue}\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_OPERATORS)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([ (1, 2), (1, 3), (2, 4), (3, 4), (3, 5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Model (or Kripke Structure)\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.collatetruth-Union{Tuple{T}, Tuple{N}, Tuple{SoleLogics.AbstractAlgebra{T}, SoleLogics.AbstractOperator, Tuple{Vararg{T, N}}}} where {N, T}","page":"Full reference","title":"SoleLogics.collatetruth","text":"collatetruth(\n    a::AbstractAlgebra,\n    op::AbstractOperator,\n    t::NTuple{N,T},\n)::T where {N,T<:TruthValue}\n\nReturn the truth value of a composed formula op(φ1, ..., φN), given the N truth values of its immediate sub-formulas. An algebra must provide a collatetruth method for each operator that can be interpreted on it.\n\nSee also AbstractAlgebra AbstractOperator, TruthValue.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, SoleLogics.AbstractOperator, Tuple{Vararg{var\"#s368\", N}} where var\"#s368\"<:(Union{AbstractSet{W}, AbstractVector{W}} where W<:AbstractWorld)}} where {N, W<:AbstractWorld}","page":"Full reference","title":"SoleLogics.collateworlds","text":"function collateworlds(\n    fr::AbstractFrame{W},\n    op::AbstractOperator,\n    t::NTuple{N,WorldSetType},\n)::AbstractWorldSet{<:W} where {N,W<:AbstractWorld,WorldSetType<:AbstractWorldSet}\n\nFor a given crisp frame (truthtype == Bool), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the N sets of worlds where the each immediate sub-formula is true.\n\nSee also check, iscrisp, AbstractOperator, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.converse-Tuple{Type{<:AbstractRelation}}","page":"Full reference","title":"SoleLogics.converse","text":"converse(R::Type{<:AbstractRelation})::Type{<:AbstractRelation}\nconverse(r::AbstractRelation)::AbstractRelation = converse(typeof(r))()\n\nIf it exists, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.default_algebra-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Full reference","title":"SoleLogics.default_algebra","text":"default_algebra(::Type{T})::AbstractAlgebra{<:T} where {T<:TruthValue}\n\nReturn the fallback algebra for a given truth value type.\n\nImplementation\n\nIn order to check syntax trees without algebras, truth values should provide a default algebra it works with.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.diamond-Tuple{}","page":"Full reference","title":"SoleLogics.diamond","text":"\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}","page":"Full reference","title":"SoleLogics.domain","text":"domain(a::AbstractAlgebra)\n\nReturn the domain of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.dual-Tuple{AbstractSyntaxToken}","page":"Full reference","title":"SoleLogics.dual","text":"dual(tok::AbstractSyntaxToken)\n\nReturn the dual of a syntax token. Given a token tok of arity n, the dual dtok is such that, on a boolean algebra, tok(ch_1, ..., ch_n) ≡ ¬dtok(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform synctactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q). Duality also applies to nullary operators (⊤/⊥), operators with existential/universal semantics (◊/□), and Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{A}) where {A} = Atom(dual(value(p)))\n\nAs such, hasdual(::A) and dual(::A) should be defined when wrapping objects of type A.\n\nSee also normalize, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.emptyworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Full reference","title":"SoleLogics.emptyworld","text":"Return an empty world (e.g., Interval(-1,0)).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{A, O} where {A, O}}","page":"Full reference","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxTree}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}","page":"Full reference","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{A,O} where {A,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxTree}\n\nGenerate all formulas with syntax trees that are not taller than a given maxdepth.\n\nSee also AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}","page":"Full reference","title":"SoleLogics.goeswithdim","text":"Some worlds (dimensional worlds) can be interpreted on dimensional data, that is, n-dimensional arrays. The compatibility of a given world with respect of a  structure of a given dimensionality must be specified via the following trait:\n\ngoeswithdim(w::AbstractWorld, d) = goeswithdim(typeof(w), d)\ngoeswithdim(W::Type{<:AbstractWorld}, d::Integer) = goeswithdim(W, Val(d))\ngoeswithdim(::Type{<:AbstractWorld}, ::Val) = false\n\nExamples\n\njulia> SoleLogics.goeswithdim(OneWorld, 0)\ntrue\n\njulia> SoleLogics.goeswithdim(OneWorld, 1)\nfalse\n\njulia> SoleLogics.goeswithdim(Interval, 1)\ntrue\n\njulia> SoleLogics.goeswithdim(Interval, 2)\nfalse\n\njulia> all([SoleLogics.goeswithdim.(SoleLogics.Point{N}, N) for N in 1:10])\ntrue\n\n\nSee also OneWorld, World, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G","page":"Full reference","title":"SoleLogics.grammar","text":"grammar(l::AbstractLogic{G})::G where {G<:AbstractGrammar}\n\nReturn the grammar of a given logic.\n\nSee also grammar, algebra, operators, alphabet, truthtype, formulas, AbstractGrammar, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.hasconverse-Tuple{Type{<:AbstractRelation}}","page":"Full reference","title":"SoleLogics.hasconverse","text":"converse(R::Type{<:AbstractRelation})::Type{<:AbstractRelation}\nconverse(r::AbstractRelation)::AbstractRelation = converse(typeof(r))()\n\nIf it exists, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.height","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.height","text":"height(t::SyntaxTree)::Integer\n\nReturn the height of a syntax tree.\n\nSee also tokens, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isbottom-Tuple{Any}","page":"Full reference","title":"SoleLogics.isbottom","text":"isbottom(::TruthValue)::Bool\n\nReturn true if the truth value is the bottom of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nisbottom(t::Bool)::Bool = (t == false)\n\nSee also istop, TruthValue.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isbox-Tuple{Type{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.isbox","text":"isbox(::Type{<:AbstractOperator})::Bool = false\nisbox(o::AbstractOperator)::Bool = isbox(typeof(o))\n\nReturn whether it is known that an AbstractOperator is a box (i.e., universal) operator.\n\nExamples\n\njulia> SoleLogics.isbox(◊)\nfalse\n\njulia> SoleLogics.isbox(∧)\nfalse\n\njulia> SoleLogics.isbox(□)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.iscommutative-Tuple{Type{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.iscommutative","text":"iscommutative(::Type{AbstractOperator})\niscommutative(o::AbstractOperator) = iscommutative(typeof(o))\n\nReturn whether an operator is known to be commutative.\n\nExamples\n\njulia> iscommutative(∧)\ntrue\n\njulia> iscommutative(→)\nfalse\n\nNote that nullary and unary operators are considered commutative.\n\nSee also AbstractOperator.\n\nImplementation\n\nWhen implementing a new type for a commutative operator O with arity higher than 1, please provide a method iscommutative(::Type{O}). This can help model checking operations.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.iscrisp-Tuple{Type{<:SoleLogics.AbstractAlgebra}}","page":"Full reference","title":"SoleLogics.iscrisp","text":"iscrisp(A::Type{<:AbstractAlgebra}) = (truthtype(A) == Bool)\niscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))\n\nAn algebra is crisp (or boolean) when its domain type is... Bool, quite literally! The antonym of crisp is fuzzy.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isgrounded-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.isgrounded","text":"isgrounded(f::AbstractFormula)::Bool\n\nReturn true if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.\n\nExamples\n\njulia> f = parsebaseformula(\"⟨G⟩p → [G]q\");\n\njulia> syntaxstring(f)\n\"(⟨G⟩p) → ([G]q)\"\n\njulia> SoleLogics.isgrounded(f)\ntrue\n\nSee also isgrounding), SyntaxTree), AbstractFormula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isgrounding-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.isgrounding","text":"isgrounding(::AbstractRelation)\n\nReturn whether it is known that a relation is grounding. A relation R is grounding if ∀x,y R(x,y) ⇔ R(z,y).\n\nSee also isreflexive, issymmetric, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ismodal-Tuple{Type{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.ismodal","text":"ismodal(::Type{<:AbstractOperator})::Bool = false\nismodal(o::AbstractOperator)::Bool = ismodal(typeof(o))\n\nReturn whether it is known that an AbstractOperator is modal.\n\nExamples\n\njulia> ismodal(◊)\ntrue\n\njulia> ismodal(∧)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isreflexive-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.isreflexive","text":"isreflexive(::AbstractRelation)\n\nReturn whether it is known that a relation is reflexive.\n\nSee also issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isrightassociative-Tuple{Type{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.isrightassociative","text":"isrightassociative(::Type{AbstractOperator})\nisrightassociative(o::AbstractOperator) = isrightassociative(typeof(o))\n\nReturn whether an AbstractOperator is right associative or no.\n\nAssociativity establishes how operators of the same precedence are grouped in the absence of the parentheses.\n\nConjunction and disjunction are commutative operators, thus, the left associativity case \"(p ∧ q) ∧ r\" and the right associativity case \"p ∧ (q ∧ r)\" are equivalent; by convention we consider the latter form. Implication is right associative, meaning that \"p → q → r\" is grouped as \"p → (q → r)\".\n\nBy default, an operator is right associative.\n\nExamples\n\njulia> isrightassociative(∧)\ntrue\n\njulia> isrightassociative(→)\ntrue\n\nSee also AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.issymmetric-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.issymmetric","text":"issymmetric(::AbstractRelation) = hasconverse(r) ? converse(r) == r : false\n\nReturn whether it is known that a relation is symmetric.\n\nSee also hasconverse, converse, isreflexive, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istop-Tuple{Any}","page":"Full reference","title":"SoleLogics.istop","text":"istop(::TruthValue)::Bool\n\nReturn true if the truth value is the top of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nistop(t::Bool)::Bool = (t == true)\n\nSee also isbottom, TruthValue.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}","page":"Full reference","title":"SoleLogics.istopological","text":"istopological(r::GeometricalRelation)\n\nReturn whether it is known that a given geometrical relation is topological (i.e., invariant under homeomorphisms,  see here)\n\nSee also GeometricalRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istransitive-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.istransitive","text":"istransitive(::AbstractRelation)\n\nReturn whether it is known that a relation is transitive.\n\nSee also isreflexive, issymmetric, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.joinformulas-Union{Tuple{F}, Tuple{N}, Tuple{SoleLogics.AbstractOperator, Tuple{Vararg{F, N}}}} where {N, F<:AbstractFormula}","page":"Full reference","title":"SoleLogics.joinformulas","text":"joinformulas(\n    op::AbstractOperator,\n    ::NTuple{N,F}\n)::F where {N,F<:AbstractFormula}\n\nReturn a new formula of type F by composing N formulas of the same type via an operator op. This function allows one to use operators for flexibly composing formulas (see Implementation).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxTree: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;)\nSyntaxTree: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxTree: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon joinformulas lies a flexible way of using operators for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (op::AbstractOperator)(\n    children::NTuple{N,Union{AbstractSyntaxToken,AbstractFormula}},\n) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of AbstractFormula, a new method for joinformulas should be defined, together with promotion from/to other AbstractFormulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) operator to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined operator op, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Union{AbstractSyntaxToken,AbstractFormula},\n    c2::Union{AbstractSyntaxToken,AbstractFormula},\n    c3::Union{AbstractSyntaxToken,AbstractFormula},\n    cs::Union{AbstractSyntaxToken,AbstractFormula}...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Union{AbstractSyntaxToken,AbstractFormula},\n    c2::Union{AbstractSyntaxToken,AbstractFormula},\n    c3::Union{AbstractSyntaxToken,AbstractFormula},\n    cs::Union{AbstractSyntaxToken,AbstractFormula}...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nSee also AbstractFormula, AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.modallogic-Tuple{}","page":"Full reference","title":"SoleLogics.modallogic","text":"modallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a modal logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic(; operators = [¬, ∨]))\n┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedOperator[¬, ∨]). Consider using propositionallogic instead.\n└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642\nfalse\n\njulia> modallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> modallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also propositionallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.natoms-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.natoms","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.natoms-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.natoms","text":"natoms(t::SyntaxTree)::Integer\n\nReturn the count of all atoms appearing in a syntax tree.\n\nSee also atoms, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.noperators-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.noperators","text":"noperators(t::SyntaxTree)::Integer\n\nReturn the count of all operators appearing in a syntax tree.\n\nSee also operaters, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.normalize-Tuple{AbstractSyntaxStructure}","page":"Full reference","title":"SoleLogics.normalize","text":"normalize(\n    f::AbstractFormula;\n    remove_boxes = true,\n    reduce_negations = true,\n    allow_atom_flipping = true,\n)\n\nReturn a modified version of a given formula, that has the same semantics but different syntax. This is useful when dealing with the truth of many (possibly similar) formulas; for example, when performing model checking. BEWARE: it currently assumes the underlying algebra is Boolean!\n\nArguments\n\nf::AbstractFormula: when set to true,   the formula;\nremove_boxes::Bool: converts all uni-modal and multi-modal box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.\nreduce_negations::Bool: when set to true,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., De Morgan's laws).   Note: this assumes an underlying Boolean algebra.\nallow_atom_flipping::Bool: when set to true,   together with reduce_negations=true, this may cause the negation of an atom   to be replaced with the its dual atom.\n\nExamples\n\njulia> f = parsebaseformula(\"□¬((p∧¬q)→r)∧⊤\");\n\njulia> syntaxstring(f)\n\"□¬((p ∧ ¬q) → r) ∧ ⊤\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))\n\"¬◊(q ∨ ¬p ∨ r)\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))\n\"□(¬r ∧ p ∧ ¬q)\"\n\nSee also SyntaxTree), AbstractFormula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ntokens-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.ntokens","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ntokens-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.ntokens","text":"ntokens(t::SyntaxTree)::Integer\n\nReturn the count of all tokens appearing in a syntax tree.\n\nSee also tokens, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}","page":"Full reference","title":"SoleLogics.nworlds","text":"nworlds(fr::AbstractFrame)::Integer\n\nReturn the number of worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.operators-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.operators","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.operators-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.operators","text":"operators(t::SyntaxTree)::AbstractVector{AbstractOperator}\n\nList all operators appearing in a syntax tree.\n\nSee also noperators, atoms, tokens, AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}","page":"Full reference","title":"SoleLogics.parsebaseformula","text":"function parsebaseformula(\n    expression::String,\n    additional_operators::Union{Nothing,Vector{<:AbstractOperator}} = nothing;\n    operators::Union{Nothing,Vector{<:AbstractOperator}},\n    grammar::Union{Nothing,AbstractGrammar} = nothing,\n    algebra::Union{Nothing,AbstractAlgebra} = nothing,\n    kwargs...\n)::Formula\n\nReturn a Formula which is the result of parsing expression  via the Shunting yard  algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS; additional operators may be provided as a second argument.\n\nThe grammar and algebra of the associated logic is inferred using the baseformula function from the operators encountered in the expression, and those in additional_operators.\n\nSee parsetree, baseformula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.parseformula-Tuple{Type{<:AbstractFormula}, AbstractString, Vararg{Any}}","page":"Full reference","title":"SoleLogics.parseformula","text":"function parseformula(\n    F::Type{<:AbstractFormula},\n    str::AbstractString,\n    args...;\n    kwargs...\n)\n\nParses a formula of type F from a string. When F is not specified, it defaults to     SyntaxTree and parsetree is called.\n\nSee also parsetree, parsebaseformula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.parsetree-Tuple{Any, Vararg{Any}}","page":"Full reference","title":"SoleLogics.parsetree","text":"parsetree(\n    expression::String,\n    additional_operators::Union{Nothing,Vector{<:AbstractOperator}} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)\n\nReturn a SyntaxTree which is the result of parsing expression  via the Shunting yard  algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS (see arguments section); additional operators may be provided as a second argument.\n\nArguments\n\nexpression::String: expression to be parsed;\nadditional_operators::Vector{<:AbstractOperator}: additional, non-standard operators   needed to correctly parse the expression.   When left unset, only the operators in SoleLogics.BASE_PARSABLE_OPERATORS are   correctly parsed: S, o, l, e, L, o, g, i, c, s, ., A, b, s, t, r, a, c, t, O, p, e, r, a, t, o, r, [, ⊤, ,,  , ⊥, ,,  , ¬, ,,  , ∧, ,,  , ∨, ,,  , →, ,,  , ◊, ,,  , □, ,,  , ⟨, G, ⟩, ,,  , [, G, ], ,,  , ⟨, =, ⟩, ,,  , [, =, ], ];   note that, in case of clashing syntaxstring's,   the provided additional operators will override these.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g, \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g, \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parsetree(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parsetree(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parsetree(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nSee also SyntaxTree, syntaxstring, [].\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.propositionallogic-Tuple{}","page":"Full reference","title":"SoleLogics.propositionallogic","text":"propositionallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a propositional logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(propositionallogic())\ntrue\n\njulia> (¬) isa operatorstype(propositionallogic(; operators = [∨]))\nfalse\n\njulia> propositionallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> propositionallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also modallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.randbaseformula-Tuple{Integer, Any, Vector{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.randbaseformula","text":"randformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\nfunction randbaseformula(\n    height::Integer,\n    g::AbstractGrammar;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nfunction randbaseformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nReturn a pseudo-randomic SyntaxTree or Formula.\n\nArguments\n\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::Vector{<:AbstractOperator}: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately.\n\nKeyword Arguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\npicker::Function = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.randbaseformula-Tuple{Integer, SoleLogics.AbstractGrammar}","page":"Full reference","title":"SoleLogics.randbaseformula","text":"randformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\nfunction randbaseformula(\n    height::Integer,\n    g::AbstractGrammar;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nfunction randbaseformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nReturn a pseudo-randomic SyntaxTree or Formula.\n\nArguments\n\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::Vector{<:AbstractOperator}: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately.\n\nKeyword Arguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\npicker::Function = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.randformula-Tuple{Integer, Any, Vector{<:SoleLogics.AbstractOperator}}","page":"Full reference","title":"SoleLogics.randformula","text":"randformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\nfunction randbaseformula(\n    height::Integer,\n    g::AbstractGrammar;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nfunction randbaseformula(\n    height::Integer,\n    alphabet,\n    operators::Vector{<:AbstractOperator};\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::Formula\n\nReturn a pseudo-randomic SyntaxTree or Formula.\n\nArguments\n\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::Vector{<:AbstractOperator}: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately.\n\nKeyword Arguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\npicker::Function = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.relation-Tuple{AbstractRelationalOperator}","page":"Full reference","title":"SoleLogics.relation","text":"relationtype(::AbstractRelationalOperator{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalOperator) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational operator.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.relationtype-Union{Tuple{AbstractRelationalOperator{R}}, Tuple{R}} where R<:AbstractRelation","page":"Full reference","title":"SoleLogics.relationtype","text":"relationtype(::AbstractRelationalOperator{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalOperator) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational operator.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.subformulas-Tuple{AbstractSyntaxStructure}","page":"Full reference","title":"SoleLogics.subformulas","text":"subformulas(f::AbstractFormula; sorted=true)\n\nReturn all sub-formulas (sorted by size when sorted=true) of a given formula.\n\nExamples\n\njulia> syntaxstring.(SoleLogics.subformulas(parsebaseformula(\"◊((p∧q)→r)\")))\n6-element Vector{String}:\n \"p\"\n \"q\"\n \"r\"\n \"p ∧ q\"\n \"◊(p ∧ q)\"\n \"(◊(p ∧ q)) → r\"\n\nSee also SyntaxTree), AbstractFormula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.syntaxstring-Tuple{AbstractSyntaxToken}","page":"Full reference","title":"SoleLogics.syntaxstring","text":"syntaxstring(φ::AbstractFormula; kwargs...)::String\nsyntaxstring(tok::AbstractSyntaxToken; kwargs...)::String\n\nProduce the string representation of a formula or syntax token by performing a tree traversal of the syntax tree representation of the formula. Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leafs of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(p, ∧(q, ∧(r, ∧(s, t))))\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"(p) ∧ ((q) ∧ ((r) ∧ ((s) ∧ (t))))\"\n\njulia> syntaxstring(parsebaseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parsebaseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parsebaseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parsebaseformula, parsetree, SyntaxTree, AbstractSyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including kwargs...) for every newly defined AbstractSyntaxToken (e.g., operators and Atoms), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(p::Atom; kwargs...) = syntaxstring(value(p); kwargs...)\n\nThen, the syntaxstring for a given value can be defined. For example, with String (or Number) values, it defaults to:\n\nsyntaxstring(value::String; kwargs...) = value\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (','). See also parsebaseformula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.tokens-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.tokens","text":"tokens(f::AbstractFormula)::AbstractVector{<:AbstractSyntaxToken}\noperators(f::AbstractFormula)::AbstractVector{<:AbstractOperator}\natoms(f::AbstractFormula)::AbstractVector{<:Atom}\nntokens(f::AbstractFormula)::Integer\nnoperators(f::AbstractFormula)::Integer\nnatoms(f::AbstractFormula)::Integer\n\nReturn the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.\n\nSee also AbstractSyntaxStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.tokens-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.tokens","text":"tokens(t::SyntaxTree)::AbstractVector{AbstractSyntaxToken}\n\nList all tokens appearing in a syntax tree.\n\nSee also ntokens, operators, atoms, AbstractSyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra}","page":"Full reference","title":"SoleLogics.top","text":"top(a::AbstractAlgebra)\n\nReturn the top of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.tree-Tuple{AbstractFormula}","page":"Full reference","title":"SoleLogics.tree","text":"tree(f::AbstractFormula)::SyntaxTree\n\nExtract the SyntaxTree representation of a formula (equivalent to Base.convert(SyntaxTree, f)).\n\nSee also SyntaxTree, AbstractSyntaxStructure. AbstractFormula,\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}","page":"Full reference","title":"SoleLogics.treewalk","text":"function treewalk(\n    st::SyntaxTree,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    criterion::Function = ntokens,\n    toleaf::Bool = true,\n    returnnode::Bool = false,\n    transformnode::Function = nothing,\n)::SyntaxTree\n\nReturn a subtree from passed SyntaxTree by following options:\n\ncriterion: function used to calculate the probability of stopping at a random node;\nreturnnode: true if only the subtree is to be returned;\ntransformnode: function that will be applied to the chosen subtree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T","page":"Full reference","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractAlgebra{T}}) where {T<:TruthValue} = T\ntruthtype(a::AbstractAlgebra) = truthtype(typeof(a))\n\nThe Julia type for representing truth values of the algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR<:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W<:AbstractWorld, A, T}","page":"Full reference","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractKripkeStructure{W,A,T}}) where {W<:AbstractWorld,A,T<:TruthValue} = T\ntruthtype(a::AbstractKripkeStructure) = truthtype(typeof(a))\n\nThe truth type of the model.\n\nSee also AbstractKripkeStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.worldtype","text":"worldtype(::Type{<:AbstractFrame{W}}) where {W<:AbstractWorld} = W\nworldtype(fr::AbstractFrame) = worldtype(typeof(fr))\n\nReturn the world type of the frame.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR<:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W<:AbstractWorld, A, T}","page":"Full reference","title":"SoleLogics.worldtype","text":"worldtype(::Type{<:AbstractKripkeStructure{W,A,T}}) where {W<:AbstractWorld,A,T<:TruthValue} = W\nworldtype(a::AbstractKripkeStructure) = worldtype(typeof(a))\n\nThe world type of the model.\n\nSee also AbstractKripkeStructure.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#StatsBase.sample-Tuple{SoleLogics.AbstractGrammar, Vararg{Any}}","page":"Full reference","title":"StatsBase.sample","text":"function StatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG, ]\n    g::AbstractGrammar,\n    height::Integer,\n    args...;\n    kwargs...\n)::AbstractFormula\n\nRandomly sample a logic formula of given height from a grammar g.\n\nImplementation\n\nThis method for must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also `AbstractAlphabet'.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.@atoms-Tuple","page":"Full reference","title":"SoleLogics.@atoms","text":"@atoms(cast, ps...)\n\nInstantiate a collection of Atoms and return them as a vector.\n\ninfo: Info\nAtoms instantiated with this macro are defined in the global scope as constants.\n\nExamples\n\njulia> SoleLogics.@atoms String p q r s\n4-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n Atom{String}(\"r\")\n Atom{String}(\"s\")\n\njulia> p\nAtom{String}(\"p\")\n\n\n\n\n\n","category":"macro"},{"location":"autodocs/#SoleLogics.@synexpr-Tuple{Any}","page":"Full reference","title":"SoleLogics.@synexpr","text":"@synexpr(expression)\n\nReturn an expression after automatically instantiating undefined Atoms.\n\ninfo: Info\n\n\nEvery identified atom is of type Atom{String}.\n\nExamples\n\njulia> @synexpr x = p # Atom{String}(\"p\") is assigned to the global variable x\nAtom{String}(\"p\")\n\njulia> @synexpr st = p ∧ q → r\n(p ∧ q) → r\n\njulia> typeof(st)\nSyntaxTree{SoleLogics.NamedOperator{:→}}\n\n\n\n\n\n","category":"macro"}]
}
