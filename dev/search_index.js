var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleLogics","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#syntactical-base-definitions","page":"Getting started","title":"Syntax Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Logical formulas are syntactical objects representing statements which level of truth can be assessed. Formulas arise from formal grammars (e.g., context-free grammars), and are most commonly represented as syntax trees. At the leaf nodes of a syntax tree are atoms (simple, atomic statements) or truth values (e.g., ⊤, representing truth), while at the internal nodes are logical connectives that allow for the composition of formulas to represent complex concepts.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In SoleLogics, an Atom is a wrapper for any value (accessible via the value method). TODO arity","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Atom\nTruth\nConnective\nSyntaxBranch","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let's review these concepts with a simple example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"julia> p = Atom(\"p\")\nAtom{String}(\"p\")\n\njulia> q = Atom(\"q\")\nAtom{String}(\"q\")\n\njulia> value(p)\n\"p\"\n\n# Operators are syntax tokens too\njulia> CONJUNCTION\n∧\n\n# SyntaxBranch's are arity-compliant\njulia> st = SyntaxBranch(CONJUNCTION, p)\nERROR: AssertionError: Cannot instantiate SyntaxBranch{SoleLogics.NamedConnective{:∧}} \nwith token ∧ of arity 2 and 1 children.\n\n# In fact, the conjunction operator in a syntax tree must have exactly 2 children \njulia> arity(CONJUNCTION)\n2\n\njulia> stree = SyntaxBranch(CONJUNCTION, (p,q))\nSyntaxBranch: p ∧ q\n\n# Get the token of the root node\njulia> token(st)\n∧\n\n# Get the first subtree, containing only an atom\njulia> leftree = children(st)[1]; \nSyntaxBranch: p\n\njulia> typeof(leftree)\nSyntaxBranch{Atom{String}}\n\n# Atoms are necessarily at the leaves; in fact their arity is 0\njulia> leftree |> token |> arity\n0","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractSyntaxStructure\nSyntaxToken\nSoleLogics.arity(::SyntaxToken)","category":"page"},{"location":"getting-started/#Connectives","page":"Getting started","title":"Connectives","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"TODO","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.Connective","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement custom operators. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.NamedConnective\nSoleLogics.precedence\nSoleLogics.associativity\nSoleLogics.iscommutative","category":"page"},{"location":"getting-started/#SoleLogics.precedence","page":"Getting started","title":"SoleLogics.precedence","text":"precedence(c::Connective)\n\nReturn the precedence of a binary connective.\n\nWhen using infix notation, and in the absence of parentheses, precedence establishes how binary connectives are interpreted. A precedence value is a standard integer, and connectives with high precedence take precedence over connectives with lower precedences. This affects how formulas are shown (via syntaxstring) and parsed (via parseformula).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); there are some exceptions (e.g., ¬). Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nIt is possible to assign a specific precedence to a connective type C by providing a method Base.operator_precedence(::C).\n\nExamples\n\njulia> precedence(∧) == Base.operator_precedence(:∧)\ntrue\n\njulia> precedence(∧), precedence(∨), precedence(→)\n∨(12, 11, 4)\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also associativity, Connective.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.associativity","page":"Getting started","title":"SoleLogics.associativity","text":"associativity(::Connective)\n\nReturn whether a (binary) connective is right-associative.\n\nWhen using infix notation, and in the absence of parentheses, associativity establishes how binary connectives of the sameprecedenceare interpreted. This affects how formulas are shown (viasyntaxstring) and parsed (viaparseformula`).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); thus, for example, most connectives are left-associative (e.g., ∧ and ∨), while → is right-associative. Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nExamples\n\njulia> associativity(∧)\n:left\n\njulia> associativity(→)\n:right\n\njulia> syntaxstring(parseformula(\"p → q → r\"); remove_redundant_parentheses = false)\n\"p → (q → r)\"\n\njulia> syntaxstring(parseformula(\"p ∧ q ∨ r\"); remove_redundant_parentheses = false)\n\"(p ∧ q) ∨ r\"\n\nSee also Connective, parseformula, precedence, syntaxstring.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.iscommutative","page":"Getting started","title":"SoleLogics.iscommutative","text":"iscommutative(c::Connective)\n\nReturn whether a connective is known to be commutative.\n\nExamples\n\njulia> iscommutative(∧)\ntrue\n\njulia> iscommutative(→)\nfalse\n\nNote that nullary and unary connectives are considered commutative.\n\nSee also Connective.\n\nImplementation\n\nWhen implementing a new type for a commutative connective C with arity higher than 1, please provide a method iscommutative(::C). This can help model checking operations.\n\nSee also Connective.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To learn more about operators, refer to Propositional Logic and Modal Logic chapters.","category":"page"},{"location":"getting-started/#Formulas","page":"Getting started","title":"Formulas","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"TODO: the following definition might be unclear, since \"evaluation\" and \"logic\" are not concepts already read by the user. When the Logic structure will be removed from SoleLogics, this section will be expanded with semantics-related concepts.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Formula","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement a custom Formula subtype. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"composeformulas\ntokens(::Formula)\nSoleLogics.height(::SyntaxBranch)\nSoleLogics.tree(::Formula)","category":"page"},{"location":"getting-started/#SoleLogics.composeformulas","page":"Getting started","title":"SoleLogics.composeformulas","text":"composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\n\nReturn a new formula of type F by composing N formulas of the same type via a connective c. This function allows one to use connectives for flexibly composing formulas (see Implementation section).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxBranch: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;) See https://stackoverflow.com/a/60321302/5646732\nSyntaxBranch: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxBranch: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon composeformulas lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (c::Connective)(φs::NTuple{N,Formula}) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of Formula, a new method for composeformulas should be defined, together with promotion from/to other Formulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective c, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nnote: Note\n\n\nTo allow for the composition of Formulas of different types, promotion rules should be provided.\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.height-Tuple{SyntaxBranch}","page":"Getting started","title":"SoleLogics.height","text":"height(φ::Formula)::Integer\n\nReturn the height of a formula in its syntax tree representation.\n\nSee also SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Parsing-and-Printing","page":"Getting started","title":"Parsing & Printing","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleLogics.jl allows you to: ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Extract the string representation of a formula (via syntaxstring);\nParse formulas from strings (via parseformula).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"These features are highly customizable, and leverage three properties of syntactical tokens: arity, connective precedence and connective associativity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"syntaxstring\nparseformula","category":"page"},{"location":"getting-started/#SoleLogics.syntaxstring","page":"Getting started","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including kwargs...) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxBranchs, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#SoleLogics.parseformula","page":"Getting started","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS (e.g., ¬, ∧, ∨, →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstring's will be used for parsing them. Note that, in case of clashing syntaxstring's, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\n\n\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, syntaxstring.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Grammar","page":"Getting started","title":"Grammar","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractAlphabet","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nSoleLogics.jl offers the possibility to implement a custom AbstractAlphabet concrete type. To see an in-depth example, please refer to section Customization.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"atoms(a::AbstractAlphabet)\n\nBase.in(p::Atom, a::AbstractAlphabet)\nBase.length(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet)\nExplicitAlphabet\nAlphabetOfAny\n\nAbstractGrammar\nalphabet(g::AbstractGrammar{A} where {A})\nBase.in(φ::SyntaxBranch, g::AbstractGrammar)\nformulas(g::AbstractGrammar; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing, args...)\n\nCompleteFlatGrammar{A<:AbstractAlphabet,O<:Operator}\nformulas(g::CompleteFlatGrammar{A,O} where {A,O}; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing)","category":"page"},{"location":"getting-started/#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}","page":"Getting started","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{V} where {V})::V\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Base.in-Tuple{SyntaxBranch, SoleLogics.AbstractGrammar}","page":"Getting started","title":"Base.in","text":"Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}","page":"Getting started","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxBranch}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}","page":"Getting started","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{V,O} where {V,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxBranch}\n\nGenerate all formulas whose SyntaxBranchs that are not taller than a given maxdepth.\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Semantics","page":"Getting started","title":"Semantics","text":"","category":"section"},{"location":"getting-started/#customization-section","page":"Getting started","title":"Customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc justo justo, finibus ac odio in, tempor fermentum augue. Vivamus ullamcorper lacus eget enim imperdiet, ac lobortis turpis elementum. Fusce non auctor eros. Duis scelerisque auctor volutpat. Morbi non luctus est. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Pellentesque porttitor a est sit amet ornare. Aliquam faucibus fringilla imperdiet.","category":"page"},{"location":"propositional-logic/","page":"Propositional logic","title":"Propositional logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"propositional-logic/","page":"Propositional logic","title":"Propositional logic","text":"Pages = [\"propositional-logic.md\"]","category":"page"},{"location":"propositional-logic/#propositional-logic","page":"Propositional logic","title":"Propositional Logic","text":"","category":"section"},{"location":"modal-logic/","page":"Modal logic","title":"Modal logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"modal-logic/","page":"Modal logic","title":"Modal logic","text":"Pages = [\"modal-logic.md\"]","category":"page"},{"location":"modal-logic/#modal-logic","page":"Modal logic","title":"Modal Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleLogics","category":"page"},{"location":"#SoleLogics","page":"Home","title":"SoleLogics","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleLogics, a Julia package for computational logic. SoleLogics.jl lays the logical foundations for Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleLogics.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleLogics\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl allows easy manipulation of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Syntax tokens (e.g., atoms, logical constants/connectives, etc.);\nAlphabets, grammars, algebras (e.g., crisp, fuzzy), logics (e.g., propositional and (multi)modal);\nFormulas (e.g., syntax trees, DNFs, CNFs): random generation, parsing, minimization;\nInterpretations (e.g., propositional assignments, Kripke structures);\nAlgorithms for evaluating the: validity/satisfiability of a formula, and truth of a formula on an interpretation (model checking).","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"CurrentModule = SoleLogics","category":"page"},{"location":"autodocs/#Full-reference-for-SoleLogics.jl","page":"Full reference","title":"Full reference for SoleLogics.jl","text":"","category":"section"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"Auto documentation for SoleLogics.jl.","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"Modules = [SoleLogics]","category":"page"},{"location":"autodocs/#SoleLogics.:¬","page":"Full reference","title":"SoleLogics.:¬","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:→","page":"Full reference","title":"SoleLogics.:→","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:∧","page":"Full reference","title":"SoleLogics.:∧","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.:∨","page":"Full reference","title":"SoleLogics.:∨","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BASE_OPERATORS","page":"Full reference","title":"SoleLogics.BASE_OPERATORS","text":"const BASE_OPERATORS = [¬, ∧, ∨, →]\n\nBasic logical operators.\n\nSee also NEGATION, CONJUCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BASE_PARSABLE_OPERATORS","page":"Full reference","title":"SoleLogics.BASE_PARSABLE_OPERATORS","text":"const BASE_PARSABLE_OPERATORS = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]\n\nVector of (standard) operators that are automatically taken care of when parsing.\n\nSee also parseformula.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BOT","page":"Full reference","title":"SoleLogics.BOT","text":"struct Bot <: Truth end\nconst BOT = Bot()\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.BOX","page":"Full reference","title":"SoleLogics.BOX","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box operator, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.CONJUNCTION","page":"Full reference","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.DIAMOND","page":"Full reference","title":"SoleLogics.DIAMOND","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::NamedConnective{:◊}) = true\narity(::typeof(◊)) = 1\n\nLogical diamond operator, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.DISJUNCTION","page":"Full reference","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IA3Relations","page":"Full reference","title":"SoleLogics.IA3Relations","text":"const IA3Relations = [IA_I, IA_L, IA_Li]\n\nVector of 3 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA7Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IA7Relations","page":"Full reference","title":"SoleLogics.IA7Relations","text":"const IA7Relations = [IA_AorO,   IA_L,  IA_DorBorE,\n                      IA_AiorOi, IA_Li, IA_DiorBiorEi]\n\nVector of 7 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA3Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IABase","page":"Full reference","title":"SoleLogics.IABase","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IARelations","page":"Full reference","title":"SoleLogics.IARelations","text":"const IARelations = [IA_A,  IA_L,  IA_B,  IA_E,  IA_D,  IA_O,\n                     IA_Ai, IA_Li, IA_Bi, IA_Ei, IA_Di, IA_Oi]\n\nVector of the 12 interval relations from Allen's interval algebra.\n\nSee also IA7Relations, IA3Relations,  IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.IMPLICATION","page":"Full reference","title":"SoleLogics.IMPLICATION","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.NEGATION","page":"Full reference","title":"SoleLogics.NEGATION","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.Operator","page":"Full reference","title":"SoleLogics.Operator","text":"const Operator = Union{Connective,Truth}\n\nUnion type for logical constants of any ariety (zero for Truth values, non-zero for Connectives).\n\nSee also Connective, Truth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Operator-Tuple{Any}","page":"Full reference","title":"SoleLogics.Operator","text":"(op::Operator)(o::Any)\n\nAn Operator can be used to compose syntax tokens (e.g., atoms), syntax trees and/or formulas.\n\nExamples\n\n    ¬(Atom(1)) ∨ Atom(1) ∧ ⊤\n    ∧(⊤,⊤)\n    ⊤()\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.Point2DRelations","page":"Full reference","title":"SoleLogics.Point2DRelations","text":"Vector of 8 cardinal relations from Compass logic: North, South, North-West, etc.\n\nSee also PointRelations.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.PointRelations","page":"Full reference","title":"SoleLogics.PointRelations","text":"Vector of 6 point relations: min, max, successor, predecessor, >, <.\n\nSee also Point2DRelations.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.RCC5Relations","page":"Full reference","title":"SoleLogics.RCC5Relations","text":"const RCC5Relations = [Topo_DR, Topo_PO, Topo_PP, Topo_PPi]\n\nVector of the 4 relations from RCC5.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.RCC8Relations","page":"Full reference","title":"SoleLogics.RCC8Relations","text":"const RCC8Relations = [Topo_DC, Topo_EC, Topo_PO, Topo_TPP, Topo_TPPi, Topo_NTPP, Topo_NTPPi]\n\nVector of the 7 relations from RCC8.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.SyntaxToken","page":"Full reference","title":"SoleLogics.SyntaxToken","text":"const SyntaxToken = Union{Connective,SyntaxLeaf}\n\nUnion type for values wrapped in SyntaxTree nodes.\n\nSee also SyntaxTree, SyntaxLeaf, Connective.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TOP","page":"Full reference","title":"SoleLogics.TOP","text":"struct Top <: Truth end\nconst TOP = Top()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.globalrel","page":"Full reference","title":"SoleLogics.globalrel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also IdentityRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.identityrel","page":"Full reference","title":"SoleLogics.identityrel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(identityrel)\nIdentityRel()\n\nSee also GlobalRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.tocenterrel","page":"Full reference","title":"SoleLogics.tocenterrel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also IdentityRel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.⊤","page":"Full reference","title":"SoleLogics.⊤","text":"struct Top <: Truth end\nconst TOP = Top()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.⊥","page":"Full reference","title":"SoleLogics.⊥","text":"struct Bot <: Truth end\nconst BOT = Bot()\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.□","page":"Full reference","title":"SoleLogics.□","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box operator, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.◊","page":"Full reference","title":"SoleLogics.◊","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::NamedConnective{:◊}) = true\narity(::typeof(◊)) = 1\n\nLogical diamond operator, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleLogics.AbstractAlgebra","page":"Full reference","title":"SoleLogics.AbstractAlgebra","text":"abstract type AbstractAlgebra{T<:Truth} end\n\nAbstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a lattice structure where two elements(or nodes) ⊤ and ⊥ are referred to as TOP (or maximum) and bot (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.\n\nImplementation\n\nWhen implementing a new algebra type, the methods domain, TOP, and bot should be implemented.\n\nSee also bot, BooleanAlgebra, Operator, TOP, collatetruth, domain, iscrisp, truthtype.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractAlphabet","page":"Full reference","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, Atom, ExplicitAlphabet, atomstype,  valuetype.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractAlphabet-Union{Tuple{Any}, Tuple{V}} where V","page":"Full reference","title":"SoleLogics.AbstractAlphabet","text":"An alphabet of valuetype V can be used for instantiating atoms of valuetype V.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.AbstractAssignment","page":"Full reference","title":"SoleLogics.AbstractAssignment","text":"abstract type AbstractAssignment <: AbstractInterpretation end\n\nAbstract type for assigments, that is, interpretations of propositional logic, encoding mappings from Atoms to Truth values.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractDimensionalFrame","page":"Full reference","title":"SoleLogics.AbstractDimensionalFrame","text":"abstract type AbstractDimensionalFrame{\n    N,\n    W<:AbstractWorld,\n} <: AbstractMultiModalFrame{W} end\n\nAbstract type for dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding dimensional frame is a graph where each vertex is an N-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).\n\nSee also  Interval, Interval2D, IntervalRelation, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractFrame","page":"Full reference","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the structure to Kripke structures's).\n\nSee also truthtype, worldtype, allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractGrammar","page":"Full reference","title":"SoleLogics.AbstractGrammar","text":"abstract type AbstractGrammar{V<:AbstractAlphabet,O<:Operator} end\n\nAbstract type for representing a context-free grammar based on a single alphabet of type V, and a set of operators that consists of all the (singleton) child types of O. V context-free grammar is a simple structure for defining formulas inductively.\n\nSee also alphabet, atomstype, tokenstype, operatorstype, alphabettype, AbstractAlphabet, Operator.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractInterpretation","page":"Full reference","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractInterpretationSet","page":"Full reference","title":"SoleLogics.AbstractInterpretationSet","text":"abstract type AbstractInterpretationSet{M<:AbstractInterpretation} <: AbstractDataset end\n\nAbstract type for ordered sets of interpretations. A set of interpretations, also referred to as a dataset in this context, is a collection of instances, each of which is an interpretation, and is identified by an index iinstance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Modelchecking).\n\nSee also valuetype, truthtype, InterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractKripkeStructure","page":"Full reference","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's). It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractLogic","page":"Full reference","title":"SoleLogics.AbstractLogic","text":"abstract type AbstractLogic{G<:AbstractGrammar,V<:AbstractAlgebra} end\n\nAbstract type of a logic, which comprehends a context-free grammar (syntax) and an algebra (semantics).\n\nImplementation\n\nWhen implementing a new logic type, the methods grammar and algebra should be implemented.\n\nSee also AbstractAlgebra, AbstractGrammar.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractMultiModalFrame","page":"Full reference","title":"SoleLogics.AbstractMultiModalFrame","text":"abstract type AbstractMultiModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.\n\nImplementation\n\nWhen implementing a new multi-modal frame type, the logical semantics for the frame should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractUniModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractRelation","page":"Full reference","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, IdentityRel, GlobalRel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractRelationalOperator","page":"Full reference","title":"SoleLogics.AbstractRelationalOperator","text":"abstract type AbstractRelationalOperator{R<:AbstractRelation} <: Connective end\n\nAbstract type for relational logical operators. A relational operator allows for semantic quantification across relational structures (e.g., Krikpe structures). It has arity equal to the arity of its underlying relation minus one.\n\nSee, for example temporal modal logic.\n\nSee also DiamondRelationalOperator, BoxRelationalOperator, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractSyntaxStructure","page":"Full reference","title":"SoleLogics.AbstractSyntaxStructure","text":"abstract type AbstractSyntaxStructure <: Formula end\n\nAbstract type for the purely-syntactic component of a logical formula (e.g., no fancy memoization structure associated). The typical representation is the SyntaxTree, however, different implementations can cover specific syntactic forms (e.g., conjuctive/disjuctive normal forms).\n\nSee also Formula, AbstractLogic, SyntaxTree, tree.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractUniModalFrame","page":"Full reference","title":"SoleLogics.AbstractUniModalFrame","text":"abstract type AbstractUniModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a modal logic based on a single (implicit) accessibility relation.\n\nSee also AbstractMultiModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractWorld","page":"Full reference","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semanticsu should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AbstractWorlds","page":"Full reference","title":"SoleLogics.AbstractWorlds","text":"const AbstractWorlds{W} = AbstractVector{W} where {W<:AbstractWorld}\nconst Worlds{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases for dealing with worlds sets/arrays.\n\nSee also accessibles, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AlphabetOfAny","page":"Full reference","title":"SoleLogics.AlphabetOfAny","text":"struct AlphabetOfAny{V} <: AbstractAlphabet{V} end\n\nAn implicit, infinite alphabet that includes all atoms with values of a subtype of V.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.AnchoredFormula","page":"Full reference","title":"SoleLogics.AnchoredFormula","text":"struct AnchoredFormula{L<:AbstractLogic} <: Formula\n    _logic::Base.RefValue{L}\n    synstruct::AbstractSyntaxStructure\nend\n\nA formula anchored to a logic of type L, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.\n\nUpon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:\n\ncheck_atoms::Bool = false: whether to perform or not a check that the atoms   belong to the alphabet of the logic;\ncheck_tree::Bool = false: whether to perform or not a check that the formula's   syntactic structure honors the grammar   (includes the check performed with check_atoms = true);\n\nCool feature: a AnchoredFormula can be used for instating other formulas of the same logic. See the examples.\n\nExamples\n\njulia> f = parsebaseformula(\"◊(p→q)\");\n\njulia> f2 = f(parseformula(\"p\"));\n\njulia> syntaxstring(f)\n\"◊(→(p, q))\"\n\njulia> syntaxstring(f2)\n\"p\"\n\njulia> @assert logic(f) == logic(f2)\n\njulia> @assert ◊ in operators(logic(f2))\n\njulia> @assert ◊ isa operatorstype(logic(f2))\n\n\nSee also AbstractLogic, logic, SyntaxToken, SyntaxBranch, tree.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Atom","page":"Full reference","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BaseLogic","page":"Full reference","title":"SoleLogics.BaseLogic","text":"struct BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra} <: AbstractLogic{G,A}\n    grammar::G\n    algebra::A\nend\n\nA basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.\n\nSee also grammar, algebra, AbstractGrammar, AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BooleanAlgebra","page":"Full reference","title":"SoleLogics.BooleanAlgebra","text":"struct BooleanAlgebra <: AbstractAlgebra{Bool} end\n\nA boolean algebra, defined on the values Top (representing true) and Bot (for bottom, representing false). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of true and false, respectively.\n\nSee also Truth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.BooleanTruth","page":"Full reference","title":"SoleLogics.BooleanTruth","text":"abstract type BooleanTruth <: Truth end\n\nSupertype of Top and Bot, the two truth values of BooleanAlgebra\n\nSee also Bot, Top, BooleanAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Bot","page":"Full reference","title":"SoleLogics.Bot","text":"struct Bot <: Truth end\nconst BOT = Bot()\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.CNF","page":"Full reference","title":"SoleLogics.CNF","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}} TODO recheck these\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.CompleteFlatGrammar","page":"Full reference","title":"SoleLogics.CompleteFlatGrammar","text":"struct CompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator} <: AbstractGrammar{V,O}\n    alphabet::V\n    operators::Vector{<:O}\nend\n\nV grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type V, and all operators in operators. With n operators, this grammar has exactly n+1 production rules. For example, with operators = [∧,∨], the grammar (in Backus-Naur form) is:\n\nφ ::= p | φ ∧ φ | φ ∨ φ\n\nwith p ∈ alphabet. Note: it is flat in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.\n\nSee also AbstractGrammar, Operator, alphabet, formulas, connectives, operators, leaves.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Connective","page":"Full reference","title":"SoleLogics.Connective","text":"abstract type Connective <: Syntactical end\n\nAbstract type for logical connectives, that are used to express non-atomic statements; for example, CONJUNCTION, DISJUNCTION and IMPLICATION (stylized as ∧, ∨ and →).\n\nImplementation\n\nWhen implementing a new type C for a connective, please define its arity. For example, with a binary operator (e.g., ∨ or ∧):\n\narity(::C) = 2\n\nWhen implementing a new type C for a commutative connective with arity higher than 1, please provide a method iscommutative(::C). This can speed up model checking operations.\n\nWhen implementing a custom binary connective, one can override the default precedence and associativity (see https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity). If the custom connective is a NamedConnective and renders as something considered as a math symbol (for example, ⊙, see https://stackoverflow.com/a/60321302/5646732), by the Julia parser, Base.operator_precedence and Base.operator_associativity are used to define these behaviors, and you might want to avoid providing these methods at all.\n\nSee also arity, SyntaxBranch, associativity, precedence, check, iscommutative, NamedConnective, Syntactical.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DNF","page":"Full reference","title":"SoleLogics.DNF","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}} TODO recheck these\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DefaultedTruthDict","page":"Full reference","title":"SoleLogics.DefaultedTruthDict","text":"struct DefaultedTruthDict{\n    D<:AbstractDict{A where A<:Atom,T where T<:Truth},\n    T<:Truth\n} <: AbstractAssignment\n    truth::D\n    default_truth::T\nend\n\nA truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns default_truth.\n\nExamples\n\njulia> t1 = DefaultedTruthDict(string.(1:4), false); t1[\"5\"] = false; t1\nDefaultedTruthDict with default truth `⊥` and values:\n┌────────┬────────┬────────┬────────┬────────┐\n│      4 │      1 │      5 │      2 │      3 │\n│ String │ String │ String │ String │ String │\n├────────┼────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊥ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┴────────┘\n\njulia> check(parseformula(\"1 ∨ 2\"), t1)\ntrue\n\njulia> check(parseformula(\"1 ∧ 5\"), t1)\nfalse\n\n\nSee also TruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.DiamondRelationalOperator","page":"Full reference","title":"SoleLogics.DiamondRelationalOperator","text":"struct DiamondRelationalOperator{R<:AbstractRelation} <: AbstractRelationalOperator{R} end\nstruct BoxRelationalOperator{R<:AbstractRelation} <: AbstractRelationalOperator{R} end\n\nSingleton types for relational operators, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth operators can be easily instantiated with relation instances, such as DiamondRelationalOperator(rel), which is a shortcut for DiamondRelationalOperator{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalOperator(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalOperator(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalOperator(IA_A) == SoleLogics.dual(BoxRelationalOperator(IA_A))\n\n\nSee also DiamondRelationalOperator, BoxRelationalOperator, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ExplicitAlphabet","page":"Full reference","title":"SoleLogics.ExplicitAlphabet","text":"struct ExplicitAlphabet{V} <: AbstractAlphabet{V}\n    atoms::Vector{Atom{V}}\nend\n\nAn alphabet wrapping atoms in a (finite) Vector.\n\nSee also AbstractAlphabet, atoms.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ExplicitCrispUniModalFrame","page":"Full reference","title":"SoleLogics.ExplicitCrispUniModalFrame","text":"TODO\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Formula","page":"Full reference","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), AbstractSyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nSee also tree, AbstractSyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.FullDimensionalFrame","page":"Full reference","title":"SoleLogics.FullDimensionalFrame","text":"struct FullDimensionalFrame{N,W<:AbstractWorld} <: AbstractDimensionalFrame{N,W}\n    channelsize::NTuple{N,Int}\nend\n\nAbstract type for full dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding full dimensional frame is a graph where there is exactly one vertex for each M-hyperrectangle in the space (1:X, 1:Y, 1:Z, ...), with M ≤ N.\n\nHere, the M-hyperrectangle can be either a Point, or a N-tuple of intervals (e.g., Interval or Interval2D), where each interval is a pair of natural numbers (x,y) where: i) x > 0; ii) y > 0; iii) x < y.\n\nThe current implementation can handle N ∈ {0,1,2}.\n\nExamples\n\njulia> SoleLogics.allworlds(SoleLogics.FullDimensionalFrame((),))\n1-element Vector{OneWorld}:\n −\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,),))\n55\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,10),))\n3025\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also  OneWorld, Interval, Interval2D, IntervalRelation, IntervalRelation2D, accessibles, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GeometricalRelation","page":"Full reference","title":"SoleLogics.GeometricalRelation","text":"abstract type GeometricalWorld <: AbstractRelation end\n\nAbstract type for relations with a geometrical interpretation.\n\nSee also istopological, IntervalRelation, RectangleRelation, RCCRelation, AbstractRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GeometricalWorld","page":"Full reference","title":"SoleLogics.GeometricalWorld","text":"abstract type GeometricalWorld <: AbstractWorld end\n\nAbstract type for worlds with a geometrical interpretation.\n\nSee also Point, Interval, Interval2D, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.GlobalRel","page":"Full reference","title":"SoleLogics.GlobalRel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also IdentityRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IdentityRel","page":"Full reference","title":"SoleLogics.IdentityRel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(identityrel)\nIdentityRel()\n\nSee also GlobalRel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.InterpretationSet","page":"Full reference","title":"SoleLogics.InterpretationSet","text":"struct InterpretationSet{M<:AbstractInterpretation} <: AbstractInterpretationSet{M}\n    instances::Vector{M}\nend\n\nA dataset of interpretations instantiated as a vector.\n\nAbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Interval","page":"Full reference","title":"SoleLogics.Interval","text":"struct Interval{T} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Interval2D","page":"Full reference","title":"SoleLogics.Interval2D","text":"struct Interval2D{T} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.IntervalRelation","page":"Full reference","title":"SoleLogics.IntervalRelation","text":"abstract type IntervalRelation <: GeometricalRelation end\n\nAbstract type for interval binary relations. Originally defined by Allen in 1983, interval algebra comprehends 12 directional relations between intervals, plus the identity (i.e., identityrel).\n\nThe 12 relations are the 6 relations after, later, begins, ends, during, overlaps, and their inverses.\n\nIf we consider a reference interval (x,y), we can graphically represent the 6 base relations by providing an example of a world (z,t) that is accessible via each of them:\n\nRELATION    ABBR.     x                   y                     PROPERTY                                         |–––––––––-|                                                                      .                   .                                                                      .                   z        t            y = z                      After       (A)       .                   |––––|                                                             .                   .                                                                      .                   .   z         t       y < z                      Later       (L)       .                   .   |––––-|                                                        .                   .                                                                      z     t             .                     x = z, t < y               Begins      (B)       |––-|             .                                                                      .                   .                                                                      .             z     t                     y = t, x < z               Ends        (E)       .             |––-|                                                                      .                   .                                                                      .   z        t      .                     x < z, t < y               During      (D)       .   |––––|      .                                                                      .                   .                                                                      .           z       .    t                x < z < y < t              Overlaps    (O)       .           |––––––|                                          \n\nCoarser relations can be defined by union of these 12 relations.\n\nExamples\n\njulia> IARelations\n12-element Vector{IntervalRelation}:\n _IA_A()\n _IA_L()\n _IA_B()\n _IA_E()\n _IA_D()\n _IA_O()\n _IA_Ai()\n _IA_Li()\n _IA_Bi()\n _IA_Ei()\n _IA_Di()\n _IA_Oi()\n\njulia> @assert SoleLogics._IA_L() == IA_L\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(2,5), IA_L))\n15-element Vector{Interval{Int64}}:\n (6−7)\n (6−8)\n (7−8)\n (6−9)\n (7−9)\n (8−9)\n (6−10)\n (7−10)\n (8−10)\n (9−10)\n (6−11)\n (7−11)\n (8−11)\n (9−11)\n (10−11)\n\njulia> syntaxstring.(IARelations)\n12-element Vector{String}:\n \"A\"\n \"L\"\n \"B\"\n \"E\"\n \"D\"\n \"O\"\n \"A̅\"\n \"L̅\"\n \"B̅\"\n \"E̅\"\n \"D̅\"\n \"O̅\"\n\njulia> syntaxstring.(IA7Relations)\n6-element Vector{String}:\n \"A∨O\"\n \"L\"\n \"D∨B∨E\"\n \"A̅∨O̅\"\n \"L̅\"\n \"D̅∨B̅∨E̅\"\n\njulia> syntaxstring.(SoleLogics.IA3Relations)\n3-element Vector{String}:\n \"I\"\n \"L\"\n \"L̅\"\n\n\nSee also IARelations, IA7Relations, IA3Relations, Interval, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.KripkeStructure","page":"Full reference","title":"SoleLogics.KripkeStructure","text":"struct KripkeStructure{\n    FR<:AbstractFrame,\n    MAS<:AbstractDict\n} <: AbstractKripkeStructure\n    frame::FR\n    assignment::AS\nend\n\nType for representing Kripke structures's). explicitly; it wraps a frame, and an abstract dictionary that assigns an interpretation to each world.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostConjunctiveForm","page":"Full reference","title":"SoleLogics.LeftmostConjunctiveForm","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}} TODO recheck these\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostDisjunctiveForm","page":"Full reference","title":"SoleLogics.LeftmostDisjunctiveForm","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}} TODO recheck these\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LeftmostLinearForm","page":"Full reference","title":"SoleLogics.LeftmostLinearForm","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}} TODO recheck these\n    (p) → (q) → (r)\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    (¬(p)) ∧ (q) ∧ (¬(r))\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    (¬(p)) ∨ (q) ∨ (¬(r))\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa SoleLogics.DNF\ntrue\n\n\nSee also AbstractSyntaxStructure, SyntaxTree, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, Literal.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Literal","page":"Full reference","title":"SoleLogics.Literal","text":"struct Literal{T<:SyntaxToken} <: AbstractSyntaxStructure\n    ispos::Bool\n    prop::T\nend\n\nAn atom, or its negation.\n\nSee also CNF, DNF, AbstractSyntaxStructure.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.LogicalInstance","page":"Full reference","title":"SoleLogics.LogicalInstance","text":"TODO explain. In general, one may not be able to extract a single logical instance from a set, thus we represent it as a tuple of dataset + instance id (i_instance).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.NamedConnective","page":"Full reference","title":"SoleLogics.NamedConnective","text":"struct NamedConnective{Symbol} <: Connective end\n\nA singleton type for representing connectives defined by a name or a symbol.\n\nExamples\n\nThe AND connective (logical conjuction) is defined as the subtype:\n\nconst CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.NamedRelation","page":"Full reference","title":"SoleLogics.NamedRelation","text":"struct NamedRelation{T} <: AbstractRelation\n    name::T\nend\n\nType for relations that are solely defined by their name.\n\nSee also AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.OneWorld","page":"Full reference","title":"SoleLogics.OneWorld","text":"struct OneWorld <: AbstractWorld end\n\nA singleton world to be used in modal frames with a single, unique world. This usage effectively simulates a propositional context. Note that it is compatible with 0-dimensional datasets.\n\nSee also Interval, Interval2D, goeswithdim, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Point","page":"Full reference","title":"SoleLogics.Point","text":"struct Point{N,T} <: GeometricalWorld\n    xyz :: NTuple{N,T}\nend\n\nA point in an N-dimensional space, with integer coordinates.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),3)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),2)\nfalse\n\n\nSee also goeswithdim, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Point2DRelation","page":"Full reference","title":"SoleLogics.Point2DRelation","text":"2D Point relations (see Compass logic)\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.PointRelation","page":"Full reference","title":"SoleLogics.PointRelation","text":"1D Point relations\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.RCCRelation","page":"Full reference","title":"SoleLogics.RCCRelation","text":"abstract type RCCRelation <: GeometricalRelation end\n\nTopological binary relations from Region Connection Calculus. Region Connection Calculus (RCC) is most famous for RCC8, a set of 8 topological relations, which comprehends the identity relation (i.e., `identityrel'), and the following 7 relations:\n\nExternally connected\nPartially overlapping\nTangential proper part\nTangential proper part inverse\nNon-tangential proper part\nNon-tangential proper part inverse\n\nIf we consider a reference interval (x,y), we can graphically represent the 7  relations by providing an example of a world (z,t) that is accessible via each of them:\n\n                                             x                   y\n\nRELATION                             ABBR.       |–––––––––-|                                                  .                   .                                                  .                   .  z        t Disconnected                         (DC)        .                   . |––––|                                                  .                   .                                                  .                   z         t Externally connected                 (EC)        .                   |––––-|                                                  .                   .                                                  .                z     t Partially overlapping                (PO)        .                |––-|                                                  .                   .                                                  .             z     t Tangential proper part               (TPP)       .             |––-|                                                  .                   .                                                  z                   .     t Tangential proper part inverse       (T̅P̅P̅)       |––––––––––––-|                                                  .                   .                                                  .           z       . Non-tangential proper part           (NTPP)      .           |––-| .                                                  .                   .                                                z .                   . t Non-tangential proper part inverse   (N̅T̅P̅P̅)    |–––––––––––-|\n\nMethods for RCC8 relations and Interval2D's can be obtained by combining their 1D versions, according to the following composition rules:\n\n             .-------------------------------------------------------.\n             |         DC   EC   PO   TPP   T̅P̅P̅   NTPP   N̅T̅P̅P̅    Id  |\n             |-------------------------------------------------------|\n             | DC   |  DC | DC | DC | DC  | DC  |  DC  |  DC  |  DC  |\n             | EC   |  DC | EC | EC | EC  | EC  |  EC  |  EC  |  EC  |\n             | PO   |  DC | EC | PO | PO  | PO  |  PO  |  PO  |  PO  |\n             | TPP  |  DC | EC | PO | TPP | PO  |  TPP |  PO  |  TPP |\n             | T̅P̅P̅  |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  |  T̅P̅P̅ |  T̅P̅P̅ |\n             | NTPP |  DC | EC | PO | TPP | PO  | NTPP |  PO  |  TPP |\n             | N̅T̅P̅P̅ |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  | N̅T̅P̅P̅ |  T̅P̅P̅ |\n             |  Id  |  DC | EC | PO | TPP | T̅P̅P̅ |  TPP |  T̅P̅P̅ |  Id  |\n             '-------------------------------------------------------'\n\nExamples\n\njulia> RCC8Relations\n7-element Vector{RCCRelation}:\n _Topo_DC()\n _Topo_EC()\n _Topo_PO()\n _Topo_TPP()\n _Topo_TPPi()\n _Topo_NTPP()\n _Topo_NTPPi()\n\njulia> @assert SoleLogics._Topo_DC() == Topo_DC\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(4,8), Topo_DC))\n6-element Vector{Interval{Int64}}:\n (9−10)\n (9−11)\n (10−11)\n (1−2)\n (1−3)\n (2−3)\n\njulia> syntaxstring.(RCC8Relations)\n7-element Vector{String}:\n \"DC\"\n \"EC\"\n \"PO\"\n \"TPP\"\n \"T̅P̅P̅\"\n \"NTPP\"\n \"N̅T̅P̅P̅\"\n\njulia> RCC5Relations\n4-element Vector{RCCRelation}:\n _Topo_DR()\n _Topo_PO()\n _Topo_PP()\n _Topo_PPi()\n\nSee also  RCC8Relations, RCC5Relations, Interval, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.RectangleRelation","page":"Full reference","title":"SoleLogics.RectangleRelation","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Syntactical","page":"Full reference","title":"SoleLogics.Syntactical","text":"abstract type Syntactical end\n\nMaster abstract type for all syntactical objects (e.g., formulas, connectives).\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.SyntaxBranch","page":"Full reference","title":"SoleLogics.SyntaxBranch","text":"struct SyntaxBranch{T<:Connective} <: SyntaxTree\n    token::T\n    children::NTuple{N,SyntaxTree} where {N}\nend\n\nAn internal node of a syntax tree encoding a logical formula. Such a node holds a syntax token (a Connective, and has as many children as the arity of the token.\n\nThis implementation is arity-compliant, in that, upon construction, the arity of the token is checked against the number of children provided.\n\nSee also token, children, arity, Connective, height, atoms, natoms, atomstype, operators, noperators, operatorstype, tokens, ntokens, tokenstype,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.SyntaxLeaf","page":"Full reference","title":"SoleLogics.SyntaxLeaf","text":"abstract type SyntaxLeaf <: AbstractSyntaxStructure end\n\nAn atomic logical element, like a Truth value or an Atom. SyntaxLeafs have arity equal to zero, meaning that they are not allowed to have children in tree-like syntactic structures.\n\nSee also AbstractSyntaxStructure,  arity, SyntaxBranch.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.SyntaxTree","page":"Full reference","title":"SoleLogics.SyntaxTree","text":"abstract type SyntaxTree <: AbstractSyntaxStructure end\n\nAbstract type for syntax leaves (see SyntaxLeaf, such as Truth values and Atoms), and their composition via Connectives (i.e., SyntaxBranch).\n\nSee also SyntaxLeaf, SyntaxBranch, AbstractSyntaxStructure, Formula.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.ToCenteredRel","page":"Full reference","title":"SoleLogics.ToCenteredRel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also IdentityRel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Top","page":"Full reference","title":"SoleLogics.Top","text":"struct Top <: Truth end\nconst TOP = Top()\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Truth","page":"Full reference","title":"SoleLogics.Truth","text":"abstract type Truth <: SyntaxLeaf end\n\nAbstract type for syntax leaves representing values of a lattice algebra. In Boolean logic, the two BooleanTruth values Top and Bot are tused.\n\nImplementation\n\nWhen implementing a custom Truth subtype, provide istop, isbot... TODO: write the interface to be implemented here, with an example.\n\nSee also Top, Bot, BooleanTruth, arity;\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthDict","page":"Full reference","title":"SoleLogics.TruthDict","text":"struct TruthDict{D<:AbstractDict{A where A<:Atom,T where T<:Truth}} <: AbstractAssignment\n    truth::D\nend\n\nA logical interpretation instantiated as a dictionary, explicitly assigning truth values to a finite set of atoms.\n\nExamples\n\njulia> TruthDict(1:4)\nTruthDict with values:\n┌────────┬────────┬────────┬────────┐\n│      4 │      2 │      3 │      1 │\n│  Int64 │  Int64 │  Int64 │  Int64 │\n├────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┘\n\n\njulia> t1 = TruthDict(1:4, false); t1[5] = true; t1\nTruthDict with values:\n┌───────┬───────┬───────┬───────┬───────┐\n│     5 │     4 │     2 │     3 │     1 │\n│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │\n├───────┼───────┼───────┼───────┼───────┤\n│     ⊤ │     ⊥ │     ⊥ │     ⊥ │     ⊥ │\n└───────┴───────┴───────┴───────┴───────┘\n\njulia> t2 = TruthDict([\"a\" => true, \"b\" => false, \"c\" => true])\nTruthDict with values:\n┌────────┬────────┬────────┐\n│      c │      b │      a │\n│ String │ String │ String │\n├────────┼────────┼────────┤\n│      ⊤ │      ⊥ │      ⊤ │\n└────────┴────────┴────────┘\n\njulia> check(parseformula(\"a ∨ b\"), t2)\ntrue\n\n\nnote: Note\n\n\nIf prompted for the value of an unknown atom, this throws an error. If boolean, integer, or float values are specified, they are converted to Truth values. If the structure is initialized as empty, BooleanTruth values are assumed.\n\nSee also DefaultedTruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.TruthTable","page":"Full reference","title":"SoleLogics.TruthTable","text":"struct TruthTable{A,T<:Truth}\n\nDictionary which associates an AbstractAssignments to the truth value of the assignment itself on a AbstractSyntaxStructure.\n\nSee also AbstractAssignment, AbstractSyntaxStructure, Truth.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.World","page":"Full reference","title":"SoleLogics.World","text":"struct World{T} <: AbstractWorld\n    name::T\nend\n\nA world that is solely identified by its name. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.\n\nSee also OneWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.Worlds","page":"Full reference","title":"SoleLogics.Worlds","text":"const AbstractWorlds{W} = AbstractVector{W} where {W<:AbstractWorld}\nconst Worlds{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases for dealing with worlds sets/arrays.\n\nSee also accessibles, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.WrapperMultiModalFrame","page":"Full reference","title":"SoleLogics.WrapperMultiModalFrame","text":"struct WrapperMultiModalFrame{\n    W<:AbstractWorld,\n    D<:AbstractDict{<:AbstractRelation,<:AbstractUniModalFrame{W}}\n} <: AbstractMultiModalFrame{W}\n    frames::D\nend\n\nA multi-modal frame that is the superposition of many uni-modal frames. It uses a single AbstractUniModalFrame for each of relations.\n\nSee also AbstractRelation, AbstractUniModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#AbstractTrees.children-Tuple{SyntaxBranch}","page":"Full reference","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nGetter for φ children.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#AbstractTrees.children-Tuple{SyntaxTree}","page":"Full reference","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nGetter for φ children.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.haskey-Tuple{SoleLogics.AbstractAssignment, Atom}","page":"Full reference","title":"Base.haskey","text":"Base.haskey(i::AbstractAssignment, ::Atom)::Bool\n\nReturn whether an assigment has a truth value for a given atom.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.in","text":"Base.in(p::Atom, a::AbstractAlphabet)::Bool\n\nReturn whether an atom belongs to an alphabet.\n\nSee also AbstractAlphabet, Atom.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{SyntaxToken, SyntaxTree}","page":"Full reference","title":"Base.in","text":"Base.in(tok::SyntaxToken, φ::Formula)::Bool\n\nReturn whether a syntax token appears in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}","page":"Full reference","title":"Base.in","text":"Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.iterate","text":"Base.iterate(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet, state)\n\nReturn an iterator to the next element in an alhabet.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.length-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"Base.length","text":"Base.length(a::AbstractAlphabet)::Bool\n\nReturn the alphabet length, if it is finite.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}","page":"Full reference","title":"Base.rand","text":"Base.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG, ]\n    alphabet,\n    args...;\n    kwargs...\n)::Atom\n\nRandomly sample an atom from an alphabet, according to a uniform distribution.\n\nImplementation\n\nIf the alphabet is finite, the function defaults to rand(rng, atoms(alphabet)); otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also isfinite, `AbstractAlphabet'.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.accessibles","text":"accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}","page":"Full reference","title":"SoleLogics.algebra","text":"algebra(l::AbstractLogic{G,V})::V where {G,V}\n\nReturn the algebra of a given logic.\n\nSee also AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.allworlds","text":"allworlds(fr::AbstractFrame{W})::AbstractVector{<:W} where {W<:AbstractWorld}\n\nReturn all worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}","page":"Full reference","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{V} where {V})::V\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.arity-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.arity","text":"arity(::AbstractRelation)::Integer\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.arity-Tuple{Connective}","page":"Full reference","title":"SoleLogics.arity","text":"arity(tok::Connective)::Integer\narity(φ::SyntaxLeaf)::Integer # TODO extend to SyntaxTree SyntaxBranch\n\nReturn the arity of a Connective or an SyntaxLeaf. The arity is an integer representing the number of allowed children in a SyntaxBranch. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.arity-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.arity","text":"arity(tok::Connective)::Integer\narity(φ::SyntaxLeaf)::Integer # TODO extend to SyntaxTree SyntaxBranch\n\nReturn the arity of a Connective or an SyntaxLeaf. The arity is an integer representing the number of allowed children in a SyntaxBranch. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.associativity-Tuple{Connective}","page":"Full reference","title":"SoleLogics.associativity","text":"associativity(::Connective)\n\nReturn whether a (binary) connective is right-associative.\n\nWhen using infix notation, and in the absence of parentheses, associativity establishes how binary connectives of the sameprecedenceare interpreted. This affects how formulas are shown (viasyntaxstring) and parsed (viaparseformula`).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); thus, for example, most connectives are left-associative (e.g., ∧ and ∨), while → is right-associative. Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nExamples\n\njulia> associativity(∧)\n:left\n\njulia> associativity(→)\n:right\n\njulia> syntaxstring(parseformula(\"p → q → r\"); remove_redundant_parentheses = false)\n\"p → (q → r)\"\n\njulia> syntaxstring(parseformula(\"p ∧ q ∨ r\"); remove_redundant_parentheses = false)\n\"(p ∧ q) ∨ r\"\n\nSee also Connective, parseformula, precedence, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.atoms-Tuple{Formula}","page":"Full reference","title":"SoleLogics.atoms","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Full reference","title":"SoleLogics.atoms","text":"atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nList the atoms of a finite alphabet.\n\nSee also AbstractAlphabet, Base.isfinite.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.baseformula-Tuple{Formula}","page":"Full reference","title":"SoleLogics.baseformula","text":"function baseformula(\n    φ::Formula;\n    infer_logic = true,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing,\n    kwargs...,\n)\n\nAttempt at instantiating a AnchoredFormula from a syntax token/formula, by inferring the logic it belongs to. If infer_logic is true, then a canonical logic (e.g., propositional logic with all the BASE_PROPOSITIONAL_OPERATORS) is inferred; if it's false, then a logic with exactly the operators appearing in the syntax tree, plus the additional_operators is instantiated.\n\nExamples\n\njulia> t = parseformula(\"◊((p∧q)→r)\");\n\njulia> unique(operators(logic(SoleLogics.baseformula(t))))\n3-element Vector{Union{SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:∧}}}:\n ∧\n ◊\n →\n\njulia> unique(operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_OPERATORS))))\n8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedConnective{:¬}, SoleLogics.NamedConnective{:∧}, SoleLogics.NamedConnective{:∨}, SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:□}, SoleLogics.TopOperator}}:\n ¬\n ∧\n ∨\n →\n ◊\n □\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Full reference","title":"SoleLogics.bot","text":"bot(a::AbstractAlgebra)\n\nReturn the bottom of a given algebra.\n\nSee also top, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.box-Tuple{}","page":"Full reference","title":"SoleLogics.box","text":"TODO document\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Full reference","title":"SoleLogics.centralworld","text":"Return the world at the center of the frame; note that this does not always exist.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check","page":"Full reference","title":"SoleLogics.check","text":"function check(\n    φ::SyntaxTree,\n    i::AbstractKripkeStructure,\n    w::Union{Nothing,<:AbstractWorld} = nothing;\n    use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing,\n    perform_normalization::Bool = true,\n    memo_max_height::Union{Nothing,Int} = nothing,\n)::Bool\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_OPERATORS)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([ (1, 2), (1, 3), (2, 4), (3, 4), (3, 5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Structure\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Full reference","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretationSet, Integer, Vararg{Any}}","page":"Full reference","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    i_instance::Integer,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on the i-th instance of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretationSet, Vararg{Any}}","page":"Full reference","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    args...;\n    kwargs...\n)::Vector{Bool}\n\nCheck a formula on all instances of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.collatetruth-Union{Tuple{T}, Tuple{N}, Tuple{Connective, Tuple{Vararg{T, N}}}} where {N, T<:Truth}","page":"Full reference","title":"SoleLogics.collatetruth","text":"collatetruth(\n    c::Connective,\n    ts::NTuple{N,T},\n)::T where {N,T<:Truth}\n\nReturn the truth value for a composed formula c(φ1, ..., φN), given the N truth values for its immediate sub-formulas.\n\nSee also AbstractAlgebra Connective, Truth.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, Tuple{Vararg{var\"#s276\", N}} where var\"#s276\"<:(AbstractVector{W} where W<:AbstractWorld)}} where {N, W<:AbstractWorld}","page":"Full reference","title":"SoleLogics.collateworlds","text":"collateworlds(\n    fr::AbstractFrame{W},\n    op::Operator,\n    t::NTuple{N,WS},\n)::AbstractVector{<:W} where {N,W<:AbstractWorld,WS<:AbstractWorlds}\n\nFor a given crisp frame (truthtype == Bool), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the N sets of worlds where the each immediate sub-formula is true.\n\nSee also check, iscrisp, Operator, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, Tuple{Vararg{F, N}}}} where {N, F<:Formula}","page":"Full reference","title":"SoleLogics.composeformulas","text":"composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\n\nReturn a new formula of type F by composing N formulas of the same type via a connective c. This function allows one to use connectives for flexibly composing formulas (see Implementation section).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxBranch: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;) See https://stackoverflow.com/a/60321302/5646732\nSyntaxBranch: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxBranch: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon composeformulas lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (c::Connective)(φs::NTuple{N,Formula}) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of Formula, a new method for composeformulas should be defined, together with promotion from/to other Formulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective c, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nnote: Note\n\n\nTo allow for the composition of Formulas of different types, promotion rules should be provided.\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.connectives-Tuple{Formula}","page":"Full reference","title":"SoleLogics.connectives","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}","page":"Full reference","title":"SoleLogics.connectives","text":"connectives(g::AbstractGrammar)\n\nList all connectives appearing in a grammar.\n\nSee also Connective, nconnectives.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.converse-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.converse","text":"converse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.diamond-Tuple{}","page":"Full reference","title":"SoleLogics.diamond","text":"TODO document\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}","page":"Full reference","title":"SoleLogics.domain","text":"domain(a::AbstractAlgebra)\n\nReturn an iterator to the values in the domain of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.dual-Tuple{SyntaxToken}","page":"Full reference","title":"SoleLogics.dual","text":"dual(op::SyntaxToken)\n\nReturn the dual of an Operator. Given an operator op of arity n, the dual dop is such that, on a boolean algebra, op(ch_1, ..., ch_n) ≡ ¬dop(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q). Duality also applies to Truth values (⊤/⊥), with existential/universal semantics (◊/□), and Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.emptyworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Full reference","title":"SoleLogics.emptyworld","text":"Return an empty world (e.g., Interval(-1,0)).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{V, O} where {V, O}}","page":"Full reference","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxBranch}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}","page":"Full reference","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{V,O} where {V,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxBranch}\n\nGenerate all formulas whose SyntaxBranchs that are not taller than a given maxdepth.\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}","page":"Full reference","title":"SoleLogics.goeswithdim","text":"Some worlds (dimensional worlds) can be interpreted on dimensional data, that is, n-dimensional arrays. The compatibility of a given world with respect of a  structure of a given dimensionality must be specified via the following trait:\n\ngoeswithdim(w::AbstractWorld, d) = goeswithdim(typeof(w), d)\ngoeswithdim(W::Type{<:AbstractWorld}, d::Integer) = goeswithdim(W, Val(d))\ngoeswithdim(::Type{<:AbstractWorld}, ::Val) = false\n\nExamples\n\njulia> SoleLogics.goeswithdim(OneWorld, 0)\ntrue\n\njulia> SoleLogics.goeswithdim(OneWorld, 1)\nfalse\n\njulia> SoleLogics.goeswithdim(Interval, 1)\ntrue\n\njulia> SoleLogics.goeswithdim(Interval, 2)\nfalse\n\njulia> all([SoleLogics.goeswithdim.(SoleLogics.Point{N}, N) for N in 1:10])\ntrue\n\n\nSee also OneWorld, World, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G","page":"Full reference","title":"SoleLogics.grammar","text":"grammar(l::AbstractLogic{G})::G where {G<:AbstractGrammar}\n\nReturn the grammar of a given logic.\n\nSee also AbstractGrammar, AbstractLogic, algebra, alphabet, formulas, grammar, operators, truthtype.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.hasconverse-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.hasconverse","text":"converse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.hasdual-Tuple{SyntaxToken}","page":"Full reference","title":"SoleLogics.hasdual","text":"dual(op::SyntaxToken)\n\nReturn the dual of an Operator. Given an operator op of arity n, the dual dop is such that, on a boolean algebra, op(ch_1, ..., ch_n) ≡ ¬dop(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q). Duality also applies to Truth values (⊤/⊥), with existential/universal semantics (◊/□), and Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{Formula}","page":"Full reference","title":"SoleLogics.height","text":"height(φ::Formula)::Integer\n\nReturn the height of a formula in its syntax tree representation.\n\nSee also SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Full reference","title":"SoleLogics.interpret","text":"interpret(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Formula\n\nReturn the truth value for a formula on a logical interpretation (or model).\n\nExamples\n\njulia> @atoms p q\n2-element Vector{Atom{String}}:\n p\n q\n\njulia> td = TruthDict([p => true, q => false])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> interpret(CONJUNCTION(p,q), td)\n⊥\n\nSee also check, Formula, AbstractInterpretation, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isbot-Tuple{Truth}","page":"Full reference","title":"SoleLogics.isbot","text":"isbot(::Truth)::Bool\n\nReturn true if the Truth value is the bottom of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nisbot(t::Bool)::Bool = (t == false)\n\nSee also istop, Truth.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isbox-Tuple{Type{<:Connective}}","page":"Full reference","title":"SoleLogics.isbox","text":"isbox(::Type{<:Connective})::Bool = false\nisbox(c::Connective)::Bool = isbox(typeof(c))\n\nReturn whether it is known that an Connective is a box (i.e., universal) operator.\n\nExamples\n\njulia> SoleLogics.isbox(◊)\nfalse\n\njulia> SoleLogics.isbox(∧)\nfalse\n\njulia> SoleLogics.isbox(□)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.iscommutative-Tuple{Connective}","page":"Full reference","title":"SoleLogics.iscommutative","text":"iscommutative(c::Connective)\n\nReturn whether a connective is known to be commutative.\n\nExamples\n\njulia> iscommutative(∧)\ntrue\n\njulia> iscommutative(→)\nfalse\n\nNote that nullary and unary connectives are considered commutative.\n\nSee also Connective.\n\nImplementation\n\nWhen implementing a new type for a commutative connective C with arity higher than 1, please provide a method iscommutative(::C). This can help model checking operations.\n\nSee also Connective.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}","page":"Full reference","title":"SoleLogics.iscrisp","text":"iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))\n\nAn algebra is crisp (or boolean) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is fuzzy.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isgrounded-Tuple{Formula}","page":"Full reference","title":"SoleLogics.isgrounded","text":"isgrounded(f::Formula)::Bool\n\nReturn true if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.\n\nExamples\n\njulia> f = parseformula(\"⟨G⟩p → [G]q\");\n\njulia> syntaxstring(f)\n\"(⟨G⟩p) → ([G]q)\"\n\njulia> SoleLogics.isgrounded(f)\ntrue\n\nSee also isgrounding), SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isgrounding-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.isgrounding","text":"isgrounding(::AbstractRelation)\n\nReturn whether it is known that a relation is grounding. A relation R is grounding if ∀x,y R(x,y) ⇔ R(z,y).\n\nSee also isreflexive, issymmetric, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ismodal-Tuple{Type{<:Connective}}","page":"Full reference","title":"SoleLogics.ismodal","text":"ismodal(::Type{<:Connective})::Bool = false\nismodal(c::Connective)::Bool = ismodal(typeof(c))\n\nReturn whether it is known that an Connective is modal.\n\nExamples\n\njulia> ismodal(◊)\ntrue\n\njulia> ismodal(∧)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.isreflexive-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.isreflexive","text":"isreflexive(::AbstractRelation)\n\nReturn whether it is known that a relation is reflexive.\n\nSee also issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.issymmetric-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.issymmetric","text":"issymmetric(r::AbstractRelation) = hasconverse(r) ? converse(r) == r : false\n\nReturn whether it is known that a relation is symmetric.\n\nSee also hasconverse, converse, isreflexive, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istoone-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.istoone","text":"istoone(r::AbstractRelation) = false\n\nReturn whether it is known that a relation is istoone.\n\nSee also hasconverse, converse, issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istop-Tuple{Truth}","page":"Full reference","title":"SoleLogics.istop","text":"istop(::Truth)::Bool\n\nReturn true if the Truth value is the top of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nistop(t::Bool)::Bool = (t == true)\n\nSee also isbot, Truth.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}","page":"Full reference","title":"SoleLogics.istopological","text":"istopological(r::GeometricalRelation)\n\nReturn whether it is known that a given geometrical relation is topological (i.e., invariant under homeomorphisms,  see here)\n\nSee also GeometricalRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.istransitive-Tuple{AbstractRelation}","page":"Full reference","title":"SoleLogics.istransitive","text":"istransitive(::AbstractRelation)\n\nReturn whether it is known that a relation is transitive.\n\nSee also istoone, issymmetric, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.leaves-Tuple{Formula}","page":"Full reference","title":"SoleLogics.leaves","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}","page":"Full reference","title":"SoleLogics.leaves","text":"leaves(g::AbstractGrammar)\n\nList all leaves appearing in a grammar.\n\nSee also SyntaxLeaf, nleaves.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.modallogic-Tuple{}","page":"Full reference","title":"SoleLogics.modallogic","text":"modallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a modal logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic(; operators = [¬, ∨]))\n┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedConnective[¬, ∨]). Consider using propositionallogic instead.\n└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642\nfalse\n\njulia> modallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> modallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also propositionallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.natoms-Tuple{Formula}","page":"Full reference","title":"SoleLogics.natoms","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nconnectives-Tuple{Formula}","page":"Full reference","title":"SoleLogics.nconnectives","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nleaves-Tuple{Formula}","page":"Full reference","title":"SoleLogics.nleaves","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.noperators-Tuple{Formula}","page":"Full reference","title":"SoleLogics.noperators","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.normalize-Tuple{Formula, Vararg{Any}}","page":"Full reference","title":"SoleLogics.normalize","text":"normalize(\n    f::Formula;\n    remove_boxes = true,\n    reduce_negations = true,\n    allow_atom_flipping = true,\n)\n\nReturn a modified version of a given formula, that has the same semantics but different syntax. This is useful when dealing with the truth of many (possibly similar) formulas; for example, when performing model checking. BEWARE: it currently assumes the underlying algebra is Boolean!\n\nArguments\n\nf::Formula: when set to true,   the formula;\nremove_boxes::Bool: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.\nreduce_negations::Bool: when set to true,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., De Morgan's laws).   Note: this assumes an underlying Boolean algebra.\nallow_atom_flipping::Bool: when set to true,   together with reduce_negations=true, this may cause the negation of an atom   to be replaced with the its dual atom.\n\nExamples\n\njulia> f = parseformula(\"□¬((p∧¬q)→r)∧⊤\");\n\njulia> syntaxstring(f)\n\"□¬((p ∧ ¬q) → r) ∧ ⊤\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))\n\"¬◊(q ∨ ¬p ∨ r)\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))\n\"□(¬r ∧ p ∧ ¬q)\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ntokens-Tuple{Formula}","page":"Full reference","title":"SoleLogics.ntokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.ntruths-Tuple{Formula}","page":"Full reference","title":"SoleLogics.ntruths","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}","page":"Full reference","title":"SoleLogics.nworlds","text":"nworlds(fr::AbstractFrame)::Integer\n\nReturn the number of worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.operators-Tuple{Formula}","page":"Full reference","title":"SoleLogics.operators","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.parsebaseformula-Tuple{String, Vararg{Any}}","page":"Full reference","title":"SoleLogics.parsebaseformula","text":"parsebaseformula(\n    expression::String,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing;\n    operators::Union{Nothing,Vector{<:Operator}},\n    grammar::Union{Nothing,AbstractGrammar} = nothing,\n    algebra::Union{Nothing,AbstractAlgebra} = nothing,\n    kwargs...\n)::AnchoredFormula\n\nReturn a AnchoredFormula which is the result of parsing expression  via the Shunting yard  algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS; additional operators may be provided as a second argument.\n\nThe grammar and algebra of the associated logic is inferred using the baseformula function from the operators encountered in the expression, and those in additional_operators.\n\nSee parseformula, baseformula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.parseformula-Tuple{Type{<:Formula}, String, Vararg{Any}}","page":"Full reference","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_OPERATORS (e.g., ¬, ∧, ∨, →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstring's will be used for parsing them. Note that, in case of clashing syntaxstring's, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\n\n\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.precedence-Tuple{Connective}","page":"Full reference","title":"SoleLogics.precedence","text":"precedence(c::Connective)\n\nReturn the precedence of a binary connective.\n\nWhen using infix notation, and in the absence of parentheses, precedence establishes how binary connectives are interpreted. A precedence value is a standard integer, and connectives with high precedence take precedence over connectives with lower precedences. This affects how formulas are shown (via syntaxstring) and parsed (via parseformula).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); there are some exceptions (e.g., ¬). Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nIt is possible to assign a specific precedence to a connective type C by providing a method Base.operator_precedence(::C).\n\nExamples\n\njulia> precedence(∧) == Base.operator_precedence(:∧)\ntrue\n\njulia> precedence(∧), precedence(∨), precedence(→)\n∨(12, 11, 4)\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also associativity, Connective.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.propositionallogic-Tuple{}","page":"Full reference","title":"SoleLogics.propositionallogic","text":"propositionallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = NamedConnective[¬, ∧, ∨, →],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), NamedConnective[¬, ∧, ∨, →]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a propositional logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(propositionallogic())\ntrue\n\njulia> (¬) isa operatorstype(propositionallogic(; operators = [∨]))\nfalse\n\njulia> propositionallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> propositionallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also modallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.randbaseformula-Tuple{Integer, SoleLogics.AbstractGrammar}","page":"Full reference","title":"SoleLogics.randbaseformula","text":"randformula(\n    height::Integer,\n    alphabet,\n    operators::AbstractVector;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\n# TODO @Mauro implement this method.\nfunction randformula(\n    height::Integer,\n    g::AbstractGrammar;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\nReturn a pseudo-randomic SyntaxBranch.\n\nArguments\n\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::AbstractVector: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately. (TODO explain?)\n\nKeyword Arguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\natompicker::Function = method used to pick a random element. For example, this could be   Base.rand or StatsBase.sample.\nopweights::AbstractWeights = weight vector over the set of operators (see StatsBase).\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.randformula-Tuple{Random.AbstractRNG, Integer, Any, AbstractVector}","page":"Full reference","title":"SoleLogics.randformula","text":"randformula(\n    height::Integer,\n    alphabet,\n    operators::AbstractVector;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\n# TODO @Mauro implement this method.\nfunction randformula(\n    height::Integer,\n    g::AbstractGrammar;\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)::SyntaxTree\n\nReturn a pseudo-randomic SyntaxBranch.\n\nArguments\n\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::AbstractVector: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately. (TODO explain?)\n\nKeyword Arguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\natompicker::Function = method used to pick a random element. For example, this could be   Base.rand or StatsBase.sample.\nopweights::AbstractWeights = weight vector over the set of operators (see StatsBase).\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.relation-Tuple{AbstractRelationalOperator}","page":"Full reference","title":"SoleLogics.relation","text":"relationtype(::AbstractRelationalOperator{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalOperator) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational operator.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.relationtype-Union{Tuple{AbstractRelationalOperator{R}}, Tuple{R}} where R<:AbstractRelation","page":"Full reference","title":"SoleLogics.relationtype","text":"relationtype(::AbstractRelationalOperator{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalOperator) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational operator.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.subformulas-Tuple{Formula, Vararg{Any}}","page":"Full reference","title":"SoleLogics.subformulas","text":"subformulas(f::Formula; sorted=true)\n\nReturn all sub-formulas (sorted by size when sorted=true) of a given formula.\n\nExamples\n\njulia> syntaxstring.(SoleLogics.subformulas(parseformula(\"◊((p∧q)→r)\")))\n6-element Vector{String}:\n \"p\"\n \"q\"\n \"r\"\n \"p ∧ q\"\n \"◊(p ∧ q)\"\n \"(◊(p ∧ q)) → r\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.syntaxstring-Tuple{Syntactical}","page":"Full reference","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including kwargs...) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxBranchs, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.token-Tuple{SyntaxBranch}","page":"Full reference","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nGetter for the token wrapped in a SyntaxTree.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.token-Tuple{SyntaxTree}","page":"Full reference","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nGetter for the token wrapped in a SyntaxTree.\n\nSee also SyntaxBranch, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.tokens-Tuple{Formula}","page":"Full reference","title":"SoleLogics.tokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Full reference","title":"SoleLogics.top","text":"top(a::AbstractAlgebra)\n\nReturn the top of a given algebra.\n\nSee also bot, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.tree-Tuple{Formula}","page":"Full reference","title":"SoleLogics.tree","text":"tree(φ::Formula)::SyntaxTree\n\nReturn the SyntaxTree representation of a formula; note that this is equivalent to Base.convert(SyntaxTree, φ).\n\nSee also Formula, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}","page":"Full reference","title":"SoleLogics.treewalk","text":"treewalk(\n    st::SyntaxTree,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    criterion::Function = ntokens,\n    toleaf::Bool = true,\n    returnnode::Bool = false,\n    transformnode::Function = nothing,\n)::SyntaxTree\n\nReturn a subtree of syntax tree, by following these options:\n\ncriterion: function used to calculate the probability of stopping at a random node;\nreturnnode: true if only the subtree is to be returned;\ntransformnode: function that will be applied to the chosen subtree.\n\nTODO explain better TODO is this available in AbstractTrees?\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.truths-Tuple{Formula}","page":"Full reference","title":"SoleLogics.truths","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atomss, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.truthsupertype-Tuple{Type{<:Truth}}","page":"Full reference","title":"SoleLogics.truthsupertype","text":"truthsupertype(T::Type{<:Truth})::Type\n\nReturn the supertype of a Truth type that includes all values of the same algebra.\n\nSee also Truth, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T<:Truth","page":"Full reference","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth} = T\ntruthtype(a::AbstractAlgebra) = truthtype(typeof(a))\n\nThe Julia type for representing truth values of the algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W<:AbstractWorld","page":"Full reference","title":"SoleLogics.worldtype","text":"worldtype(fr::AbstractFrame)\nworldtype(i::AbstractKripkeStructure)\n\nReturn the world type of the Kripke frame/structure.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#StatsBase.sample","page":"Full reference","title":"StatsBase.sample","text":"StatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG, ]\n    g::AbstractGrammar,\n    height::Integer,\n    args...;\n    kwargs...\n)::Formula\n\nRandomly sample a logic formula of given height from a grammar g.\n\nImplementation\n\nThis method for must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also `AbstractAlphabet'.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleLogics.@atoms-Tuple","page":"Full reference","title":"SoleLogics.@atoms","text":"@atoms(ps...)\n\nInstantiate a collection of Atoms and return them as a vector.\n\ninfo: Info\nAtoms instantiated with this macro are defined in the global scope as constants.\n\nExamples\n\njulia> SoleLogics.@atoms String p q r s\n4-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n Atom{String}(\"r\")\n Atom{String}(\"s\")\n\njulia> p\nAtom{String}(\"p\")\n\n\n\n\n\n","category":"macro"},{"location":"autodocs/#SoleLogics.@synexpr-Tuple{Any}","page":"Full reference","title":"SoleLogics.@synexpr","text":"@synexpr(expression)\n\nReturn an expression after automatically instantiating undefined Atoms.\n\ninfo: Info\n\n\nEvery identified atom is of type Atom{String}.\n\nExamples\n\njulia> @synexpr x = p # Atom{String}(\"p\") is assigned to the global variable x\nAtom{String}(\"p\")\n\njulia> @synexpr st = p ∧ q → r\n(p ∧ q) → r\n\njulia> typeof(st)\nSyntaxBranch{SoleLogics.NamedConnective{:→}}\n\n\n\n\n\n","category":"macro"}]
}
