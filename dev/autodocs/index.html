<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full reference · SoleLogics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/autodocs/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../propositional-logic/">Propositional logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal logic</a></li><li class="is-active"><a class="tocitem" href>Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Full reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/autodocs.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-reference-for-SoleLogics.jl"><a class="docs-heading-anchor" href="#Full-reference-for-SoleLogics.jl">Full reference for SoleLogics.jl</a><a id="Full-reference-for-SoleLogics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Full-reference-for-SoleLogics.jl" title="Permalink"></a></h1><p>Auto documentation for <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.:¬" href="#SoleLogics.:¬"><code>SoleLogics.:¬</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const NEGATION = NamedOperator{:¬}()
const ¬ = NEGATION
arity(::Type{typeof(¬)}) = 1</code></pre><p>Logical negation (also referred to as complement). It can be typed by <code>\neg&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.:→" href="#SoleLogics.:→"><code>SoleLogics.:→</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IMPLICATION = NamedOperator{:→}()
const → = IMPLICATION
arity(::Type{typeof(→)}) = 2</code></pre><p>Logical implication. It can be typed by <code>\to&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L122-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.:∧" href="#SoleLogics.:∧"><code>SoleLogics.:∧</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedOperator{:∧}()
const ∧ = CONJUNCTION
arity(::Type{typeof(∧)}) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.:∨" href="#SoleLogics.:∨"><code>SoleLogics.:∨</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedOperator{:∨}()
const ∨ = DISJUNCTION
arity(::Type{typeof(∨)}) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractWorldSet" href="#SoleLogics.AbstractWorldSet"><code>SoleLogics.AbstractWorldSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const AbstractWorldSet{W} = Union{AbstractVector{W},AbstractSet{W}} where {W&lt;:AbstractWorld}
const WorldSet{W} = Vector{W} where {W&lt;:AbstractWorld}</code></pre><p>Useful aliases.</p><p>See also <a href="#SoleLogics.WorldSet"><code>WorldSet</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BASE_OPERATORS" href="#SoleLogics.BASE_OPERATORS"><code>SoleLogics.BASE_OPERATORS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const BASE_OPERATORS = [⊤, ⊥, ¬, ∧, ∨, →]</code></pre><p>Basic logical operators.</p><p>See also <a href="#SoleLogics.TOP"><code>TOP</code></a>, <a href="#SoleLogics.BOTTOM"><code>BOTTOM</code></a>, <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="@ref"><code>CONJUCTION</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L272-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BASE_PARSABLE_OPERATORS" href="#SoleLogics.BASE_PARSABLE_OPERATORS"><code>SoleLogics.BASE_PARSABLE_OPERATORS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Operators considered valid by default, when parsing. Those are the vector SoleLogics.AbstractOperator[⊤, ⊥, ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=]].</p><p>See also <a href="../getting-started/#SoleLogics.parsetree"><code>parsetree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/parse.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BASE_PRECEDENCE" href="#SoleLogics.BASE_PRECEDENCE"><code>SoleLogics.BASE_PRECEDENCE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const MAX_PRECEDENCE  = Base.operator_precedence(:(::))
const HIGH_PRECEDENCE = Base.operator_precedence(:^)
const BASE_PRECEDENCE = Base.operator_precedence(:*)
const LOW_PRECEDENCE  = Base.operator_precedence(:+)</code></pre><p>Standard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.</p><p>By default, all operators are assigned a <code>BASE_PRECEDENCE</code>, except for:</p><ul><li>nullary operators (e.g., ⊤, ⊥), that are assigned a <code>MAX_PRECEDENCE</code>;</li><li>unary operators (e.g., ¬, ◊), that are assigned a <code>HIGH_PRECEDENCE</code>;</li><li>the implication (→), that is assigned a <code>LOW_PRECEDENCE</code>.</li></ul><p>In case of tie, operators are evaluated in the left-to-right order.</p><p>It is possible to assign a specific precedence to an operator type <code>O</code> by providing a method <code>Base.operator_precedence(::Type{O})</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬a ∧ b ∧ c&quot;))
&quot;¬a ∧ b ∧ c&quot;

julia&gt; syntaxstring(parseformula(&quot;¬a → b ∧ c&quot;))
&quot;(¬a) → (b ∧ c)&quot;

julia&gt; syntaxstring(parseformula(&quot;a ∧ b → c ∧ d&quot;))
&quot;(a ∧ b) → (c ∧ d)&quot;</code></pre><p>See also <a href="#SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}"><code>parseformula</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L380-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BOTTOM" href="#SoleLogics.BOTTOM"><code>SoleLogics.BOTTOM</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct BottomOperator &lt;: AbstractTruthOperator end
const BOTTOM = BottomOperator()
const ⊥ = BOTTOM</code></pre><p>Canonical truth operator representing the value <code>false</code>. It can be typed by <code>\bot&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.TOP"><code>TOP</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1441-L1450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BOX" href="#SoleLogics.BOX"><code>SoleLogics.BOX</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const BOX = NamedOperator{:□}()
const □ = BOX
arity(::Type{typeof(□)}) = 1</code></pre><p>Logical box operator, typically interpreted as the modal universal quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a>, <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L846-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.CONJUNCTION" href="#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedOperator{:∧}()
const ∧ = CONJUNCTION
arity(::Type{typeof(∧)}) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L88-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.DIAMOND" href="#SoleLogics.DIAMOND"><code>SoleLogics.DIAMOND</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DIAMOND = NamedOperator{:◊}()
const ◊ = DIAMOND
ismodal(::NamedOperator{:◊}) = true
arity(::Type{typeof(◊)}) = 1</code></pre><p>Logical diamond operator, typically interpreted as the modal existential quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.BOX"><code>BOX</code></a>, <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L827-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.DISJUNCTION" href="#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedOperator{:∨}()
const ∨ = DISJUNCTION
arity(::Type{typeof(∨)}) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.HIGH_PRECEDENCE" href="#SoleLogics.HIGH_PRECEDENCE"><code>SoleLogics.HIGH_PRECEDENCE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const MAX_PRECEDENCE  = Base.operator_precedence(:(::))
const HIGH_PRECEDENCE = Base.operator_precedence(:^)
const BASE_PRECEDENCE = Base.operator_precedence(:*)
const LOW_PRECEDENCE  = Base.operator_precedence(:+)</code></pre><p>Standard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.</p><p>By default, all operators are assigned a <code>BASE_PRECEDENCE</code>, except for:</p><ul><li>nullary operators (e.g., ⊤, ⊥), that are assigned a <code>MAX_PRECEDENCE</code>;</li><li>unary operators (e.g., ¬, ◊), that are assigned a <code>HIGH_PRECEDENCE</code>;</li><li>the implication (→), that is assigned a <code>LOW_PRECEDENCE</code>.</li></ul><p>In case of tie, operators are evaluated in the left-to-right order.</p><p>It is possible to assign a specific precedence to an operator type <code>O</code> by providing a method <code>Base.operator_precedence(::Type{O})</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬a ∧ b ∧ c&quot;))
&quot;¬a ∧ b ∧ c&quot;

julia&gt; syntaxstring(parseformula(&quot;¬a → b ∧ c&quot;))
&quot;(¬a) → (b ∧ c)&quot;

julia&gt; syntaxstring(parseformula(&quot;a ∧ b → c ∧ d&quot;))
&quot;(a ∧ b) → (c ∧ d)&quot;</code></pre><p>See also <a href="#SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}"><code>parseformula</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L378-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IA3Relations" href="#SoleLogics.IA3Relations"><code>SoleLogics.IA3Relations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IA3Relations = [IA_I, IA_L, IA_Li]</code></pre><p>Vector of 3 interval relations from a coarser version of Allen&#39;s interval algebra.</p><p>See also <a href="#SoleLogics.IARelations"><code>IARelations</code></a>, <a href="#SoleLogics.IA7Relations"><code>IA7Relations</code></a>,  <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IA7Relations" href="#SoleLogics.IA7Relations"><code>SoleLogics.IA7Relations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IA7Relations = [IA_AorO,   IA_L,  IA_DorBorE,
                      IA_AiorOi, IA_Li, IA_DiorBiorEi]</code></pre><p>Vector of 7 interval relations from a coarser version of Allen&#39;s interval algebra.</p><p>See also <a href="#SoleLogics.IARelations"><code>IARelations</code></a>, <a href="#SoleLogics.IA3Relations"><code>IA3Relations</code></a>,  <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA.jl#L227-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IABase" href="#SoleLogics.IABase"><code>SoleLogics.IABase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}
struct RectangleRelation{R1&lt;:IABase,R2&lt;:IABase} &lt;: GeometricalRelation
    x :: R1
    y :: R2
end</code></pre><p>Relation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(IA2DRelations[1:20:end])
9-element Vector{String}:
 &quot;=,A&quot;
 &quot;A,L̅&quot;
 &quot;B,L&quot;
 &quot;E,B̅&quot;
 &quot;O,B&quot;
 &quot;A̅,E̅&quot;
 &quot;B̅,E&quot;
 &quot;E̅,D̅&quot;
 &quot;O̅,D&quot;</code></pre><p>See also <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, [<code>[</code>GeometricalRelation`](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA2D.jl#L34-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IARelations" href="#SoleLogics.IARelations"><code>SoleLogics.IARelations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IARelations = [IA_A,  IA_L,  IA_B,  IA_E,  IA_D,  IA_O,
                     IA_Ai, IA_Li, IA_Bi, IA_Ei, IA_Di, IA_Oi]</code></pre><p>Vector of the 12 interval relations from Allen&#39;s interval algebra.</p><p>See also <a href="#SoleLogics.IA7Relations"><code>IA7Relations</code></a>, <a href="#SoleLogics.IA3Relations"><code>IA3Relations</code></a>,  <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA.jl#L213-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IMPLICATION" href="#SoleLogics.IMPLICATION"><code>SoleLogics.IMPLICATION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IMPLICATION = NamedOperator{:→}()
const → = IMPLICATION
arity(::Type{typeof(→)}) = 2</code></pre><p>Logical implication. It can be typed by <code>\to&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.LOW_PRECEDENCE" href="#SoleLogics.LOW_PRECEDENCE"><code>SoleLogics.LOW_PRECEDENCE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const MAX_PRECEDENCE  = Base.operator_precedence(:(::))
const HIGH_PRECEDENCE = Base.operator_precedence(:^)
const BASE_PRECEDENCE = Base.operator_precedence(:*)
const LOW_PRECEDENCE  = Base.operator_precedence(:+)</code></pre><p>Standard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.</p><p>By default, all operators are assigned a <code>BASE_PRECEDENCE</code>, except for:</p><ul><li>nullary operators (e.g., ⊤, ⊥), that are assigned a <code>MAX_PRECEDENCE</code>;</li><li>unary operators (e.g., ¬, ◊), that are assigned a <code>HIGH_PRECEDENCE</code>;</li><li>the implication (→), that is assigned a <code>LOW_PRECEDENCE</code>.</li></ul><p>In case of tie, operators are evaluated in the left-to-right order.</p><p>It is possible to assign a specific precedence to an operator type <code>O</code> by providing a method <code>Base.operator_precedence(::Type{O})</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬a ∧ b ∧ c&quot;))
&quot;¬a ∧ b ∧ c&quot;

julia&gt; syntaxstring(parseformula(&quot;¬a → b ∧ c&quot;))
&quot;(¬a) → (b ∧ c)&quot;

julia&gt; syntaxstring(parseformula(&quot;a ∧ b → c ∧ d&quot;))
&quot;(a ∧ b) → (c ∧ d)&quot;</code></pre><p>See also <a href="#SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}"><code>parseformula</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L382-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.MAX_PRECEDENCE" href="#SoleLogics.MAX_PRECEDENCE"><code>SoleLogics.MAX_PRECEDENCE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const MAX_PRECEDENCE  = Base.operator_precedence(:(::))
const HIGH_PRECEDENCE = Base.operator_precedence(:^)
const BASE_PRECEDENCE = Base.operator_precedence(:*)
const LOW_PRECEDENCE  = Base.operator_precedence(:+)</code></pre><p>Standard integers representing operator precedence; operators with high values take precedence over operators with lower values. This is needed to establish unambiguous implementations of parsing-related algorithms.</p><p>By default, all operators are assigned a <code>BASE_PRECEDENCE</code>, except for:</p><ul><li>nullary operators (e.g., ⊤, ⊥), that are assigned a <code>MAX_PRECEDENCE</code>;</li><li>unary operators (e.g., ¬, ◊), that are assigned a <code>HIGH_PRECEDENCE</code>;</li><li>the implication (→), that is assigned a <code>LOW_PRECEDENCE</code>.</li></ul><p>In case of tie, operators are evaluated in the left-to-right order.</p><p>It is possible to assign a specific precedence to an operator type <code>O</code> by providing a method <code>Base.operator_precedence(::Type{O})</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬a ∧ b ∧ c&quot;))
&quot;¬a ∧ b ∧ c&quot;

julia&gt; syntaxstring(parseformula(&quot;¬a → b ∧ c&quot;))
&quot;(¬a) → (b ∧ c)&quot;

julia&gt; syntaxstring(parseformula(&quot;a ∧ b → c ∧ d&quot;))
&quot;(a ∧ b) → (c ∧ d)&quot;</code></pre><p>See also <a href="#SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}"><code>parseformula</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L376-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.NEGATION" href="#SoleLogics.NEGATION"><code>SoleLogics.NEGATION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const NEGATION = NamedOperator{:¬}()
const ¬ = NEGATION
arity(::Type{typeof(¬)}) = 1</code></pre><p>Logical negation (also referred to as complement). It can be typed by <code>\neg&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.RCC5Relations" href="#SoleLogics.RCC5Relations"><code>SoleLogics.RCC5Relations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const RCC5Relations = [Topo_DR, Topo_PO, Topo_PP, Topo_PPi]</code></pre><p>Vector of the 4 relations from RCC5.</p><p>See also <a href="#SoleLogics.RCC5Relations"><code>RCC5Relations</code></a>,  <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/RCC.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.RCC8Relations" href="#SoleLogics.RCC8Relations"><code>SoleLogics.RCC8Relations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const RCC8Relations = [Topo_DC, Topo_EC, Topo_PO, Topo_TPP, Topo_TPPi, Topo_NTPP, Topo_NTPPi]</code></pre><p>Vector of the 7 relations from RCC8.</p><p>See also <a href="#SoleLogics.RCC5Relations"><code>RCC5Relations</code></a>,  <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/RCC.jl#L171-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.SYNTACTICAL" href="#SoleLogics.SYNTACTICAL"><code>SoleLogics.SYNTACTICAL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const SYNTACTICAL = Union{AbstractSyntaxStructure,AbstractSyntaxToken}</code></pre><p>Union type representing a generic <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a> or a single token in it.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1882-L1889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TOP" href="#SoleLogics.TOP"><code>SoleLogics.TOP</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct TopOperator &lt;: AbstractTruthOperator end
const TOP = TopOperator()
const ⊤ = TOP</code></pre><p>Canonical truth operator representing the value <code>true</code>. It can be typed by <code>\top&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.BOTTOM"><code>BOTTOM</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1422-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.globalrel" href="#SoleLogics.globalrel"><code>SoleLogics.globalrel</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct GlobalRel &lt;: AbstractRelation end;
const globalrel  = GlobalRel();</code></pre><p>Singleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.globalrel)
&quot;G&quot;

julia&gt; SoleLogics.converse(GlobalRel)
GlobalRel</code></pre><p>See also <a href="#SoleLogics.IdentityRel"><code>IdentityRel</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations.jl#L98-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.identityrel" href="#SoleLogics.identityrel"><code>SoleLogics.identityrel</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct IdentityRel &lt;: AbstractRelation end;
const identityrel   = IdentityRel();</code></pre><p>Singleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.identityrel)
&quot;=&quot;

julia&gt; SoleLogics.converse(IdentityRel)
IdentityRel</code></pre><p>See also <a href="#SoleLogics.GlobalRel"><code>GlobalRel</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations.jl#L56-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.tocenterrel" href="#SoleLogics.tocenterrel"><code>SoleLogics.tocenterrel</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct ToCenteredRel &lt;: AbstractRelation end;
const tocenterrel = ToCenteredRel();</code></pre><p>Singleton type for a relation that leads to the world at the center of a frame. The relation is transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.tocenterrel)
&quot;◉&quot;</code></pre><p>See also <a href="#SoleLogics.IdentityRel"><code>IdentityRel</code></a>, <a href="#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}"><code>centralworld</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames.jl#L81-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.⊤" href="#SoleLogics.⊤"><code>SoleLogics.⊤</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct TopOperator &lt;: AbstractTruthOperator end
const TOP = TopOperator()
const ⊤ = TOP</code></pre><p>Canonical truth operator representing the value <code>true</code>. It can be typed by <code>\top&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.BOTTOM"><code>BOTTOM</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1424-L1433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.⊥" href="#SoleLogics.⊥"><code>SoleLogics.⊥</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct BottomOperator &lt;: AbstractTruthOperator end
const BOTTOM = BottomOperator()
const ⊥ = BOTTOM</code></pre><p>Canonical truth operator representing the value <code>false</code>. It can be typed by <code>\bot&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.TOP"><code>TOP</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1443-L1452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.□" href="#SoleLogics.□"><code>SoleLogics.□</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const BOX = NamedOperator{:□}()
const □ = BOX
arity(::Type{typeof(□)}) = 1</code></pre><p>Logical box operator, typically interpreted as the modal universal quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a>, <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L848-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.◊" href="#SoleLogics.◊"><code>SoleLogics.◊</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DIAMOND = NamedOperator{:◊}()
const ◊ = DIAMOND
ismodal(::NamedOperator{:◊}) = true
arity(::Type{typeof(◊)}) = 1</code></pre><p>Logical diamond operator, typically interpreted as the modal existential quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.BOX"><code>BOX</code></a>, <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L829-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractAlgebra" href="#SoleLogics.AbstractAlgebra"><code>SoleLogics.AbstractAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlgebra{T&lt;:TruthValue} end</code></pre><p>Abstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> where two elements(or nodes) <em>⊤</em> and <em>⊥</em> are referred to as <em>top</em> (or maximum) and <em>bottom</em> (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.</p><p><strong>Implementation</strong></p><p>When implementing a new algebra type, the methods <code>domain</code>, <code>top</code>, and <code>bottom</code> should be implemented.</p><p>See also <a href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>domain</code></a>, <a href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra}"><code>top</code></a>, <a href="#SoleLogics.bottom-Tuple{SoleLogics.AbstractAlgebra}"><code>bottom</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T"><code>truthtype</code></a>, <a href="#SoleLogics.iscrisp-Tuple{Type{&lt;:SoleLogics.AbstractAlgebra}}"><code>iscrisp</code></a>, <a href="@ref">`<code>BooleanAlgebra</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>, <a href="#SoleLogics.collatetruth-Union{Tuple{T}, Tuple{N}, Tuple{SoleLogics.AbstractAlgebra{T}, SoleLogics.AbstractOperator, Tuple{Vararg{T, N}}}} where {N, T}"><code>collatetruth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1467-L1486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractAlphabet" href="#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlphabet{A} end</code></pre><p>Abstract type for representing an alphabet of atoms with values of type <code>A</code>. An alphabet (or <em>propositional alphabet</em>) is a set of atoms (assumed to be <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>).</p><p>See also <a href="#SoleLogics.ExplicitAlphabet"><code>ExplicitAlphabet</code></a>, <a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny</code></a>, <a href="@ref"><code>atomstype</code></a>, <a href="@ref"><code>valuetype</code></a>, <a href="#SoleLogics.Atom"><code>Atom</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Atom(1) in ExplicitAlphabet(Atom.(1:10))
true

julia&gt; Atom(1) in ExplicitAlphabet(1:10)
true

julia&gt; Atom(1) in AlphabetOfAny{String}()
false

julia&gt; Atom(&quot;mystring&quot;) in AlphabetOfAny{String}()
true

julia&gt; &quot;mystring&quot; in AlphabetOfAny{String}()
┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})
└ @ SoleLogics ...
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new alphabet type <code>MyAlphabet</code>, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:</p><pre><code class="nohighlight hljs">function Base.in(p::Atom, a::MyAlphabet)::Bool</code></pre><p>in the case of <em>finite</em> alphabets, it suffices to define a method:</p><pre><code class="nohighlight hljs">function atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>By default, an alphabet is considered finite:</p><pre><code class="nohighlight hljs">Base.isfinite(::Type{&lt;:AbstractAlphabet}) = true
Base.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))
Base.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L939-L990">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractAlphabet-Union{Tuple{Any}, Tuple{A}} where A" href="#SoleLogics.AbstractAlphabet-Union{Tuple{Any}, Tuple{A}} where A"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An alphabet of <code>valuetype</code> <code>A</code> can be used for instantiating atoms of valuetype <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1844-L1846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractAssignment" href="#SoleLogics.AbstractAssignment"><code>SoleLogics.AbstractAssignment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAssignment{A,T&lt;:TruthValue} &lt;: AbstractInterpretation{A,T} end</code></pre><p>A propositional assigment (or, simply, an <em>assigment</em>) is a propositional interpretation, encoding a mapping from <code>Atom</code>s of value type <code>A</code> to truth values of type <code>T</code>.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractDimensionalFrame" href="#SoleLogics.AbstractDimensionalFrame"><code>SoleLogics.AbstractDimensionalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDimensionalFrame{
    N,
    W&lt;:AbstractWorld,
} &lt;: AbstractMultiModalFrame{W} end</code></pre><p>Abstract type for dimensional frames. Given a <code>N</code>-dimensional array of size (X, Y, Z, ...) the corresponding dimensional frame is a graph where each vertex is an <code>N</code>-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).</p><p>See also  <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.AbstractDimensionalFrame"><code>AbstractDimensionalFrame</code></a>, <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames/full-dimensional-frame/main.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractFormula" href="#SoleLogics.AbstractFormula"><code>SoleLogics.AbstractFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFormula end</code></pre><p>A logical formula encoding a statement which truth can be evaluated on interpretations (or models) of the logic.</p><p>Its syntactic component is canonically encoded via a syntax tree (see <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), and it can be anchored to a logic (see <a href="#SoleLogics.Formula"><code>Formula</code></a>).</p><p><strong>Implementation</strong></p><p>When implementing a new formula type <code>MyCustomFormulaType</code>, please provide a method <code>tree</code> for extracting its syntax tree representation:</p><pre><code class="nohighlight hljs">function tree(f::MyCustomFormulaType)::SyntaxTree
    ...
end</code></pre><p>As well as a method used for composing formulas:</p><pre><code class="nohighlight hljs">function (op::AbstractOperator)(
    children::NTuple{N,Union{AbstractSyntaxToken,MyCustomFormulaType}},
)::AbstractFormula where {N}
    # Composed formula
end</code></pre><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L438-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractFrame" href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFrame{W&lt;:AbstractWorld} end</code></pre><p>Abstract type for an accessibility graph (Kripke frame), that gives the structure to <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s).</p><p>See also <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T"><code>truthtype</code></a>, <a href="#SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld"><code>worldtype</code></a>, <a href="#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld"><code>allworlds</code></a>, <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractGrammar" href="#SoleLogics.AbstractGrammar"><code>SoleLogics.AbstractGrammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGrammar{A&lt;:AbstractAlphabet,O&lt;:AbstractOperator} end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a> based on a <em>single</em> alphabet of type <code>A</code>, and a set of operators that consists of all the (singleton) child types of <code>O</code>. A context-free grammar is a simple structure for defining formulas inductively.</p><p>See also <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}"><code>alphabet</code></a>, <a href="@ref"><code>atomstype</code></a>, <a href="@ref"><code>tokenstype</code></a>, <a href="@ref"><code>operatorstype</code></a>, <a href="@ref"><code>alphabettype</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1124-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractInterpretation" href="#SoleLogics.AbstractInterpretation"><code>SoleLogics.AbstractInterpretation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretation{A,T&lt;:TruthValue} end</code></pre><p>Abstract type for representing a propositional <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">interpretation</a> (or propositional model) that associates truth values of a type <code>T</code> to atoms of value type <code>A</code>. In the case of <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a>, is essentially a map <em>atom → truth value</em>.</p><p>Properties expressed via logical formulas can be <code>check</code>ed on logical interpretations.</p><p>See also <a href="#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}"><code>check</code></a>, <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1765-L1779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractInterpretationSet" href="#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretationSet{M&lt;:AbstractInterpretation} &lt;: AbstractDataset end</code></pre><p>Abstract type for ordered sets of interpretations. A set of interpretations, also referred to as a <em>dataset</em> in this context, is a collection of <em>instances</em>, each of which is an interpretation, and is identified by an index i<em>instance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Model</em>checking).</p><p>See also <a href="@ref"><code>valuetype</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T"><code>truthtype</code></a>, <a href="#SoleLogics.InterpretationSet"><code>InterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/interpretation-sets.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractKripkeStructure" href="#SoleLogics.AbstractKripkeStructure"><code>SoleLogics.AbstractKripkeStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKripkeStructure{
    W&lt;:AbstractWorld,
    A,
    T&lt;:TruthValue,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractInterpretation{A,T} end</code></pre><p>Abstract type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s). It comprehends a directed graph structure (Kripke frame), where nodes are referred to as <em>worlds</em>, and the binary relation between them is referred to as the <em>accessibility relation</em>. Additionally, each world is associated with a mapping from <code>Atom</code>s of value type <code>A</code> to truth values of type <code>T</code>.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L512-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractLogic" href="#SoleLogics.AbstractLogic"><code>SoleLogics.AbstractLogic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra} end</code></pre><p>Abstract type of a logic, which comprehends a context-free grammar (<em>syntax</em>) and an algebra (<em>semantics</em>).</p><p><strong>Implementation</strong></p><p>When implementing a new logic type, the methods <code>grammar</code> and <code>algebra</code> should be implemented.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1550-L1562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractMultiModalFrame" href="#SoleLogics.AbstractMultiModalFrame"><code>SoleLogics.AbstractMultiModalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMultiModalFrame{
    W&lt;:AbstractWorld,
} &lt;: AbstractFrame{W} end</code></pre><p>A frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.</p><p><strong>Implementation</strong></p><p>When implementing a new multi-modal frame type, the logical semantics for the frame should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L305-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractOperator" href="#SoleLogics.AbstractOperator"><code>SoleLogics.AbstractOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractOperator &lt;: AbstractSyntaxToken end</code></pre><p>An operator is a <a href="https://en.wikipedia.org/wiki/Logical_connective">logical constant</a> which establishes a relation between atoms (i.e., facts). For example, the boolean operators AND, OR and IMPLIES (stylized as ∧, ∨ and →) are used to connect atoms and/or formulas to express derived concepts.</p><p>Since operators often display very different algorithmic behaviors, leaf subtypes of <code>AbstractOperator</code> are often singleton types, which can be easily dispatched upon.</p><p><strong>Implementation</strong></p><p>When implementing a new custom operator, think about changing its default <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity">precedence and associativity</a> by providing the methods <code>Base.operator_precedence(::Type{AbstractOperator})</code> and <code>isrightassociative(::Type{AbstractOperator})</code>.</p><p>When implementing a new type for a <em>commutative</em> operator <code>O</code> with arity higher than 1, please provide a method <code>iscommutative(::Type{O})</code>. This can help model checking operations.</p><p>See also <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>, <a href="#SoleLogics.NamedOperator"><code>NamedOperator</code></a>, <a href="#Base.operator_precedence-Tuple{SoleLogics.AbstractOperator}"><code>Base.operator_precedence</code></a>, <a href="../getting-started/#SoleLogics.isrightassociative"><code>isrightassociative</code></a>, <a href="../getting-started/#SoleLogics.iscommutative"><code>iscommutative</code></a>, <a href="#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}"><code>check</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L273-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractOperator-Tuple{Any}" href="#SoleLogics.AbstractOperator-Tuple{Any}"><code>SoleLogics.AbstractOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An operator can be used to compose syntax tokens (e.g., atoms), syntax trees and/or formulas. This is quite handy, try it:</p><pre><code class="nohighlight hljs">¬(Atom(1)) ∨ Atom(1) ∧ ⊤
∧(⊤,⊤)
⊤()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1849-L1856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractRelation" href="#SoleLogics.AbstractRelation"><code>SoleLogics.AbstractRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelation end</code></pre><p>Abstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are <code>identityrel</code> and <code>globalrel</code>, which access the current world and all worlds, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new relation type <code>R</code>, please provide the methods:</p><pre><code class="nohighlight hljs">arity(::Type{R})::Int = ...
syntaxstring(::R; kwargs...)::String = ...</code></pre><p>If the relation is symmetric relation, please specify its converse relation <code>CR</code> with:</p><pre><code class="nohighlight hljs">hasconverse(::Type{R}) = true
converse(::Type{R}) = CR</code></pre><p>If the relation is reflexive or transitive, flag it with:</p><pre><code class="nohighlight hljs">isreflexive(::Type{R}) = true
istransitive(::Type{R}) = true</code></pre><p>Most importantly, the logical semantics for <code>R</code> should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}"><code>arity</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleLogics.converse-Tuple{Type{&lt;:AbstractRelation}}"><code>converse</code></a>, <a href="#SoleLogics.hasconverse-Tuple{Type{&lt;:AbstractRelation}}"><code>hasconverse</code></a>, <a href="#SoleLogics.IdentityRel"><code>IdentityRel</code></a>, <a href="#SoleLogics.GlobalRel"><code>GlobalRel</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L158-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractRelationalOperator" href="#SoleLogics.AbstractRelationalOperator"><code>SoleLogics.AbstractRelationalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelationalOperator{R&lt;:AbstractRelation} &lt;: AbstractOperator end</code></pre><p>Abstract type for relational logical operators. A relational operator allows for semantic quantification across relational structures (e.g., Krikpe structures). It has arity equal to the arity of its underlying relation minus one.</p><p>See, for example <a href="https://en.wikipedia.org/wiki/Temporal_logic">temporal modal logic</a>.</p><p>See also <a href="#SoleLogics.DiamondRelationalOperator"><code>DiamondRelationalOperator</code></a>, <a href="@ref"><code>BoxRelationalOperator</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L923-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractSyntaxStructure" href="#SoleLogics.AbstractSyntaxStructure"><code>SoleLogics.AbstractSyntaxStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSyntaxStructure &lt;: AbstractFormula end</code></pre><p>A logical formula, represented by its syntactic component. The typical representation is the <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>; however, different implementations can cover specific synctactic forms (e.g., conjuctive/disjuctive normal forms).</p><p>See also <a href="#SoleLogics.tree-Tuple{AbstractFormula}"><code>tree</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L562-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractSyntaxToken" href="#SoleLogics.AbstractSyntaxToken"><code>SoleLogics.AbstractSyntaxToken</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSyntaxToken end</code></pre><p>A token in a syntactic structure.</p><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}"><code>arity</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractTruthOperator" href="#SoleLogics.AbstractTruthOperator"><code>SoleLogics.AbstractTruthOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTruthOperator &lt;: AbstractOperator end</code></pre><p>A nullary operator wrapping a truth value; in fact, truth values can be used in formulas. Two canonical truth values that are used as nullary operators are <code>⊤</code> (<em>top</em>) and <code>⊥</code> (<em>bottom</em>), representing truth (<code>true</code>) and falsity (<code>false</code>), respectively.</p><p>See also <a href="#SoleLogics.TOP"><code>TOP</code></a>, <a href="#SoleLogics.BOTTOM"><code>BOTTOM</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1397-L1406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractUniModalFrame" href="#SoleLogics.AbstractUniModalFrame"><code>SoleLogics.AbstractUniModalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractUniModalFrame{
    W&lt;:AbstractWorld,
} &lt;: AbstractFrame{W} end</code></pre><p>A frame of a modal logic based on a single (implicit) accessibility relation.</p><p>See also <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AbstractWorld" href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractWorld end</code></pre><p>Abstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to <em>worlds</em>, that is, nodes of a graph.</p><p><strong>Implementing</strong></p><p>When implementing a new world type, the logical semanticsu should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.AlphabetOfAny" href="#SoleLogics.AlphabetOfAny"><code>SoleLogics.AlphabetOfAny</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AlphabetOfAny{A} &lt;: AbstractAlphabet{A} end</code></pre><p>An implicit, infinite alphabet that includes all atoms with values of a subtype of A.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1111-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Atom" href="#SoleLogics.Atom"><code>SoleLogics.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Atom{A} &lt;: AbstractSyntaxToken
    value::A
end</code></pre><p>An atom, sometimes called an atomic proposition, propositional letter (or simply <em>letter</em>), of type <code>Atom{A}</code> wraps a <code>value::A</code> representing a fact which truth can be assessed on a logical interpretation.</p><p>Atoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be <code>Atom</code>s.</p><p>See also <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}"><code>check</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L148-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BaseLogic" href="#SoleLogics.BaseLogic"><code>SoleLogics.BaseLogic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BaseLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra} &lt;: AbstractLogic{G,A}
    grammar::G
    algebra::A
end</code></pre><p>A basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.</p><p>See also <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G"><code>grammar</code></a>, <a href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, A}}, Tuple{A}, Tuple{G}} where {G, A}"><code>algebra</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L215-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BooleanAlgebra" href="#SoleLogics.BooleanAlgebra"><code>SoleLogics.BooleanAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BooleanAlgebra &lt;: AbstractAlgebra{Bool} end</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a>, defined on the values <code>true</code> (for top) and <code>false</code> (for bottom). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, respectively.</p><p>See also <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L159-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.BottomOperator" href="#SoleLogics.BottomOperator"><code>SoleLogics.BottomOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BottomOperator &lt;: AbstractTruthOperator end
const BOTTOM = BottomOperator()
const ⊥ = BOTTOM</code></pre><p>Canonical truth operator representing the value <code>false</code>. It can be typed by <code>\bot&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.TOP"><code>TOP</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1439-L1448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.CNF" href="#SoleLogics.CNF"><code>SoleLogics.CNF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{O&lt;:AbstractOperator,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <code>foldl</code> of a set of other syntax structure of type <code>SS</code> by means of an operator <code>O</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}
    (p) → (q) → (r)

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}
    (¬(p)) ∧ (q) ∧ (¬(r))

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}
    (¬(p)) ∨ (q) ∨ (¬(r))

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L254-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.CompleteFlatGrammar" href="#SoleLogics.CompleteFlatGrammar"><code>SoleLogics.CompleteFlatGrammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CompleteFlatGrammar{A&lt;:AbstractAlphabet,O&lt;:AbstractOperator} &lt;: AbstractGrammar{A,O}
    alphabet::A
    operators::Vector{&lt;:O}
end</code></pre><p>A grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type <code>A</code>, and all operators in <code>operators</code>. With n operators, this grammar has exactly n+1 production rules. For example, with <code>operators = [⊥,∧,∨]</code>, the grammar (in Backus-Naur form) is:</p><pre><code class="nohighlight hljs">φ ::= p | ⊥ | φ ∧ φ | φ ∨ φ</code></pre><p>with p ∈ alphabet. Note: it is <em>flat</em> in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.</p><p>See also <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}"><code>alphabet</code></a>, <a href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>operators</code></a>, <a href="@ref"><code>nonterminals</code></a>, <a href="@ref"><code>terminals</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{A, O} where {A, O}}"><code>formulas</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1221-L1241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.DNF" href="#SoleLogics.DNF"><code>SoleLogics.DNF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{O&lt;:AbstractOperator,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <code>foldl</code> of a set of other syntax structure of type <code>SS</code> by means of an operator <code>O</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}
    (p) → (q) → (r)

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}
    (¬(p)) ∧ (q) ∧ (¬(r))

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}
    (¬(p)) ∨ (q) ∨ (¬(r))

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L256-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.DefaultedTruthDict" href="#SoleLogics.DefaultedTruthDict"><code>SoleLogics.DefaultedTruthDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultedTruthDict{
    A,
    T&lt;:TruthValue,
    D&lt;:AbstractDict{&lt;:Atom{&lt;:A},T}
} &lt;: AbstractAssignment{A,T}
    truth::D
    default_truth::T
end</code></pre><p>A truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns <code>default_truth</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t1 = DefaultedTruthDict(string.(1:4), false); t1[&quot;5&quot;] = false; t1
DefaultedTruthDict with default truth `false` and values:
┌────────┬────────┬────────┬────────┬────────┐
│      4 │      1 │      5 │      2 │      3 │
│ String │ String │ String │ String │ String │
├────────┼────────┼────────┼────────┼────────┤
│   true │   true │  false │   true │   true │
└────────┴────────┴────────┴────────┴────────┘


julia&gt; check(parsebaseformula(&quot;1 ∨ 2&quot;), t1)
true

julia&gt; check(parsebaseformula(&quot;1 ∧ 5&quot;), t1)
false
</code></pre><p>See also <a href="#SoleLogics.TruthDict"><code>TruthDict</code></a>, <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L369-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.DiamondRelationalOperator" href="#SoleLogics.DiamondRelationalOperator"><code>SoleLogics.DiamondRelationalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiamondRelationalOperator{R&lt;:AbstractRelation} &lt;: AbstractRelationalOperator{R} end
struct BoxRelationalOperator{R&lt;:AbstractRelation} &lt;: AbstractRelationalOperator{R} end</code></pre><p>Singleton types for relational operators, typically interpreted as the modal existential and universal quantifier, respectively.</p><p>Both operators can be easily instantiated with relation instances, such as <code>DiamondRelationalOperator(rel)</code>, which is a shortcut for <code>DiamondRelationalOperator{typeof(rel)}()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(DiamondRelationalOperator(IA_A))
&quot;⟨A⟩&quot;

julia&gt; syntaxstring(BoxRelationalOperator(IA_A))
&quot;[A]&quot;

julia&gt; @assert DiamondRelationalOperator(IA_A) == SoleLogics.dual(BoxRelationalOperator(IA_A))
</code></pre><p>See also <a href="#SoleLogics.DiamondRelationalOperator"><code>DiamondRelationalOperator</code></a>, <a href="@ref"><code>BoxRelationalOperator</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleLogics.dual-Tuple{AbstractSyntaxToken}"><code>dual</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L953-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ExplicitAlphabet" href="#SoleLogics.ExplicitAlphabet"><code>SoleLogics.ExplicitAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitAlphabet{A} &lt;: AbstractAlphabet{A}
    atoms::Vector{Atom{A}}
end</code></pre><p>An alphabet wrapping atoms in a (finite) <code>Vector</code>.</p><p>See also <a href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>atoms</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1084-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ExplicitCrispUniModalFrame" href="#SoleLogics.ExplicitCrispUniModalFrame"><code>SoleLogics.ExplicitCrispUniModalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L133-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Formula" href="#SoleLogics.Formula"><code>SoleLogics.Formula</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Formula{L&lt;:AbstractLogic} &lt;: AbstractFormula
    _logic::Base.RefValue{L}
    synstruct::AbstractSyntaxStructure
end</code></pre><p>A formula anchored to a logic of type <code>L</code>, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.</p><p>Upon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:</p><ul><li><code>check_atoms::Bool = false</code>: whether to perform or not a check that the atoms   belong to the alphabet of the logic;</li><li><code>check_tree::Bool = false</code>: whether to perform or not a check that the formula&#39;s syntactic structure   honors the grammar (includes the check performed with <code>check_atoms = true</code>) (TODO);</li></ul><p><em>Cool feature</em>: a <code>Formula</code> can be used for instating other formulas of the same logic. See the examples.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parsebaseformula(&quot;◊(p→q)&quot;);

julia&gt; f2 = f(parseformula(&quot;p&quot;));

julia&gt; syntaxstring(f)
&quot;◊(→(p, q))&quot;

julia&gt; syntaxstring(f2)
&quot;p&quot;

julia&gt; @assert logic(f) == logic(f2)

julia&gt; @assert ◊ in operators(logic(f2))

julia&gt; @assert ◊ isa operatorstype(logic(f2))
</code></pre><p>See also <a href="#SoleLogics.tree-Tuple{AbstractFormula}"><code>tree</code></a>, <a href="@ref"><code>logic</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1616-L1662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.FullDimensionalFrame" href="#SoleLogics.FullDimensionalFrame"><code>SoleLogics.FullDimensionalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FullDimensionalFrame{N,W&lt;:AbstractWorld} &lt;: AbstractDimensionalFrame{N,W}
    channelsize::NTuple{N,Int}
end</code></pre><p>Abstract type for full dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding full dimensional frame is a graph where there is exactly one vertex for each N-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).</p><p>Here, a <code>N</code>-hyperrectangle is an <code>N</code> tuple of intervals, where each interval is a pair of natural numbers (x,y) where: i) x &gt; 0; ii) y &gt; 0; iii) x &lt; y.</p><p>The current implementation can handle N ∈ {0,1,2}.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.allworlds(SoleLogics.FullDimensionalFrame((),))
1-element Vector{OneWorld}:
 −

julia&gt; nworlds(SoleLogics.FullDimensionalFrame((10,),))
55

julia&gt; nworlds(SoleLogics.FullDimensionalFrame((10,10),))
3025

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))
3-element Vector{Interval2D{Int64}}:
 ((4−5)×(5−6))
 ((4−6)×(5−6))
 ((5−6)×(5−6))
</code></pre><p>See also  <a href="#SoleLogics.OneWorld"><code>OneWorld</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="@ref"><code>IntervalRelation2D</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractDimensionalFrame"><code>AbstractDimensionalFrame</code></a>, <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames/full-dimensional-frame/main.jl#L22-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.GeometricalRelation" href="#SoleLogics.GeometricalRelation"><code>SoleLogics.GeometricalRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricalWorld &lt;: AbstractRelation end</code></pre><p>Abstract type for relations with a geometrical interpretation.</p><p>See also <a href="#SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}"><code>istopological</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.RectangleRelation"><code>RectangleRelation</code></a>, <a href="#SoleLogics.RCCRelation"><code>RCCRelation</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/geometrical-relations.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.GeometricalWorld" href="#SoleLogics.GeometricalWorld"><code>SoleLogics.GeometricalWorld</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricalWorld &lt;: AbstractWorld end</code></pre><p>Abstract type for worlds with a geometrical interpretation.</p><p>See also <a href="#SoleLogics.Point"><code>Point</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds/geometrical-worlds.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.GlobalRel" href="#SoleLogics.GlobalRel"><code>SoleLogics.GlobalRel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GlobalRel &lt;: AbstractRelation end;
const globalrel  = GlobalRel();</code></pre><p>Singleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.globalrel)
&quot;G&quot;

julia&gt; SoleLogics.converse(GlobalRel)
GlobalRel</code></pre><p>See also <a href="#SoleLogics.IdentityRel"><code>IdentityRel</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations.jl#L96-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IdentityRel" href="#SoleLogics.IdentityRel"><code>SoleLogics.IdentityRel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IdentityRel &lt;: AbstractRelation end;
const identityrel   = IdentityRel();</code></pre><p>Singleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.identityrel)
&quot;=&quot;

julia&gt; SoleLogics.converse(IdentityRel)
IdentityRel</code></pre><p>See also <a href="#SoleLogics.GlobalRel"><code>GlobalRel</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations.jl#L54-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.InterpretationSet" href="#SoleLogics.InterpretationSet"><code>SoleLogics.InterpretationSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InterpretationSet{M&lt;:AbstractInterpretation} &lt;: AbstractInterpretationSet{M}
    instances::Vector{M}
end</code></pre><p>A dataset of interpretations instantiated as a vector.</p><p><a href="#SoleLogics.AbstractInterpretationSet"><code>AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/interpretation-sets.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Interval" href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Interval{T} &lt;: GeometricalWorld
    x :: T
    y :: T
end</code></pre><p>An interval in a 1-dimensional space, with coordinates of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)
true

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)
false

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))
6-element Vector{Interval{Int64}}:
 (3−4)
 (3−5)
 (4−5)
 (3−6)
 (4−6)
 (5−6)

</code></pre><p>See also <a href="#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="#SoleLogics.FullDimensionalFrame"><code>FullDimensionalFrame</code></a>, <a href="#SoleLogics.Point"><code>Point</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds/geometrical-worlds.jl#L57-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Interval2D" href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Interval2D{T} &lt;: GeometricalWorld
    x :: Interval{T}
    y :: Interval{T}
end</code></pre><p>A orthogonal rectangle in a 2-dimensional space, with coordinates of type <code>T</code>. This is the 2-dimensional <code>Interval</code> counterpart, that is, the combination of two orthogonal <code>Interval</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)
false

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)
true

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))
3-element Vector{Interval2D{Int64}}:
 ((4−5)×(5−6))
 ((4−6)×(5−6))
 ((5−6)×(5−6))
</code></pre><p>See also <a href="#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="#SoleLogics.FullDimensionalFrame"><code>FullDimensionalFrame</code></a>, <a href="#SoleLogics.Point"><code>Point</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds/geometrical-worlds.jl#L112-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.IntervalRelation" href="#SoleLogics.IntervalRelation"><code>SoleLogics.IntervalRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type IntervalRelation &lt;: GeometricalRelation end</code></pre><p>Abstract type for interval binary relations. Originally defined by Allen in 1983, <a href="https://en.wikipedia.org/wiki/Allen%27s_interval_algebra">interval algebra</a> comprehends 12 directional relations between intervals, plus the identity (i.e., <code>identityrel</code>).</p><p>The 12 relations are the 6 relations <code>after</code>, <code>later</code>, <code>begins</code>, <code>ends</code>, <code>during</code>, <code>overlaps</code>, and their inverses.</p><p>If we consider a reference interval <code>(x,y)</code>, we can graphically represent the 6 base relations by providing an example of a world <code>(z,t)</code> that is accessible via each of them:</p><p>RELATION    ABBR.     x                   y                     PROPERTY                                         |–––––––––-|                                                                      .                   .                                                                      .                   z        t            y = z                      After       (A)       .                   |––––|                                                             .                   .                                                                      .                   .   z         t       y &lt; z                      Later       (L)       .                   .   |––––-|                                                        .                   .                                                                      z     t             .                     x = z, t &lt; y               Begins      (B)       |––-|             .                                                                      .                   .                                                                      .             z     t                     y = t, x &lt; z               Ends        (E)       .             |––-|                                                                      .                   .                                                                      .   z        t      .                     x &lt; z, t &lt; y               During      (D)       .   |––––|      .                                                                      .                   .                                                                      .           z       .    t                x &lt; z &lt; y &lt; t              Overlaps    (O)       .           |––––––|                                          </p><p>Coarser relations can be defined by union of these 12 relations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; IARelations
12-element Vector{IntervalRelation}:
 _IA_A()
 _IA_L()
 _IA_B()
 _IA_E()
 _IA_D()
 _IA_O()
 _IA_Ai()
 _IA_Li()
 _IA_Bi()
 _IA_Ei()
 _IA_Di()
 _IA_Oi()

julia&gt; @assert SoleLogics._IA_L() == IA_L

julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; collect(accessibles(fr, Interval(2,5), IA_L))
15-element Vector{Interval{Int64}}:
 (6−7)
 (6−8)
 (7−8)
 (6−9)
 (7−9)
 (8−9)
 (6−10)
 (7−10)
 (8−10)
 (9−10)
 (6−11)
 (7−11)
 (8−11)
 (9−11)
 (10−11)

julia&gt; syntaxstring.(IARelations)
12-element Vector{String}:
 &quot;A&quot;
 &quot;L&quot;
 &quot;B&quot;
 &quot;E&quot;
 &quot;D&quot;
 &quot;O&quot;
 &quot;A̅&quot;
 &quot;L̅&quot;
 &quot;B̅&quot;
 &quot;E̅&quot;
 &quot;D̅&quot;
 &quot;O̅&quot;

julia&gt; syntaxstring.(IA7Relations)
6-element Vector{String}:
 &quot;A∨O&quot;
 &quot;L&quot;
 &quot;D∨B∨E&quot;
 &quot;A̅∨O̅&quot;
 &quot;L̅&quot;
 &quot;D̅∨B̅∨E̅&quot;

julia&gt; syntaxstring.(SoleLogics.IA3Relations)
3-element Vector{String}:
 &quot;I&quot;
 &quot;L&quot;
 &quot;L̅&quot;
</code></pre><p>See also <a href="#SoleLogics.IARelations"><code>IARelations</code></a>, <a href="#SoleLogics.IA7Relations"><code>IA7Relations</code></a>, <a href="#SoleLogics.IA3Relations"><code>IA3Relations</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA.jl#L5-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.KripkeStructure" href="#SoleLogics.KripkeStructure"><code>SoleLogics.KripkeStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct KripkeStructure{
    W&lt;:AbstractWorld,
    A,
    T&lt;:TruthValue,
    FR&lt;:AbstractFrame{W},
    AS&lt;:AbstractDict{W,A where A&lt;:AbstractAssignment{A,T}}
} &lt;: AbstractKripkeStructure{W,A,T,FR}
    frame::FR
    assignment::AS
end</code></pre><p>Type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s). explicitly; it wraps a <code>frame</code>, and an abstract dictionary that assigns an interpretation to each world.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L724-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.LeftmostConjunctiveForm" href="#SoleLogics.LeftmostConjunctiveForm"><code>SoleLogics.LeftmostConjunctiveForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{O&lt;:AbstractOperator,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <code>foldl</code> of a set of other syntax structure of type <code>SS</code> by means of an operator <code>O</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}
    (p) → (q) → (r)

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}
    (¬(p)) ∧ (q) ∧ (¬(r))

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}
    (¬(p)) ∨ (q) ∨ (¬(r))

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L249-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.LeftmostDisjunctiveForm" href="#SoleLogics.LeftmostDisjunctiveForm"><code>SoleLogics.LeftmostDisjunctiveForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{O&lt;:AbstractOperator,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <code>foldl</code> of a set of other syntax structure of type <code>SS</code> by means of an operator <code>O</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}
    (p) → (q) → (r)

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}
    (¬(p)) ∧ (q) ∧ (¬(r))

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}
    (¬(p)) ∨ (q) ∨ (¬(r))

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L251-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.LeftmostLinearForm" href="#SoleLogics.LeftmostLinearForm"><code>SoleLogics.LeftmostLinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{O&lt;:AbstractOperator,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <code>foldl</code> of a set of other syntax structure of type <code>SS</code> by means of an operator <code>O</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:→},SyntaxTree{Atom{String}}}
    (p) → (q) → (r)

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedOperator{:∧},SyntaxTree}
    (¬(p)) ∧ (q) ∧ (¬(r))

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedOperator{:∨},Literal}
    (¬(p)) ∨ (q) ∨ (¬(r))

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="#SoleLogics.Literal"><code>Literal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L40-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Literal" href="#SoleLogics.Literal"><code>SoleLogics.Literal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Literal{T&lt;:AbstractSyntaxToken} &lt;: AbstractSyntaxStructure
    ispos::Bool
    prop::T
end</code></pre><p>An atom, or its negation.</p><p>See also <a href="#SoleLogics.CNF"><code>CNF</code></a>, <a href="#SoleLogics.DNF"><code>DNF</code></a>, <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.NamedOperator" href="#SoleLogics.NamedOperator"><code>SoleLogics.NamedOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NamedOperator{Symbol} &lt;: AbstractOperator end</code></pre><p>A singleton type for representing operators defined by a name or a symbol.</p><p><strong>Examples</strong></p><p>The AND operator (logical conjuction) is defined as the subtype:</p><pre><code class="nohighlight hljs">const CONJUNCTION = NamedOperator{:∧}()
const ∧ = CONJUNCTION
arity(::Type{typeof(∧)}) = 2</code></pre><p>See also <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>, <a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.NamedRelation" href="#SoleLogics.NamedRelation"><code>SoleLogics.NamedRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NamedRelation{T} &lt;: AbstractRelation
    name::T
end</code></pre><p>Type for relations that are solely defined by their name.</p><p>See also <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.OneWorld" href="#SoleLogics.OneWorld"><code>SoleLogics.OneWorld</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OneWorld &lt;: AbstractWorld end</code></pre><p>A singleton world to be used in modal frames with a single, unique world. This usage effectively simulates a propositional context. Note that it is compatible with 0-dimensional datasets.</p><p>See also <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}"><code>goeswithdim</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.Point" href="#SoleLogics.Point"><code>SoleLogics.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Point{N,T} &lt;: GeometricalWorld
    xyz :: NTuple{N,T}
end</code></pre><p>A point in an <code>N</code>-dimensional space, with integer coordinates.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),3)
true

julia&gt; SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),2)
false
</code></pre><p>See also <a href="#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}"><code>goeswithdim</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds/geometrical-worlds.jl#L14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.RCCRelation" href="#SoleLogics.RCCRelation"><code>SoleLogics.RCCRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type RCCRelation &lt;: GeometricalRelation end</code></pre><p>Topological binary relations from <a href="https://en.wikipedia.org/wiki/Region_connection_calculus">Region Connection Calculus</a>. Region Connection Calculus (RCC) is most famous for RCC8, a set of 8 topological relations, which comprehends the identity relation (i.e., `identityrel&#39;), and the following 7 relations:</p><ul><li>Externally connected</li><li>Partially overlapping</li><li>Tangential proper part</li><li>Tangential proper part inverse</li><li>Non-tangential proper part</li><li>Non-tangential proper part inverse</li></ul><p>If we consider a reference interval <code>(x,y)</code>, we can graphically represent the 7  relations by providing an example of a world <code>(z,t)</code> that is accessible via each of them:</p><pre><code class="nohighlight hljs">                                             x                   y</code></pre><p>RELATION                             ABBR.       |–––––––––-|                                                  .                   .                                                  .                   .  z        t Disconnected                         (DC)        .                   . |––––|                                                  .                   .                                                  .                   z         t Externally connected                 (EC)        .                   |––––-|                                                  .                   .                                                  .                z     t Partially overlapping                (PO)        .                |––-|                                                  .                   .                                                  .             z     t Tangential proper part               (TPP)       .             |––-|                                                  .                   .                                                  z                   .     t Tangential proper part inverse       (T̅P̅P̅)       |––––––––––––-|                                                  .                   .                                                  .           z       . Non-tangential proper part           (NTPP)      .           |––-| .                                                  .                   .                                                z .                   . t Non-tangential proper part inverse   (N̅T̅P̅P̅)    |–––––––––––-|</p><p>Methods for RCC8 relations and Interval2D&#39;s can be obtained by combining their 1D versions, according to the following composition rules:</p><pre><code class="nohighlight hljs">             .-------------------------------------------------------.
             |         DC   EC   PO   TPP   T̅P̅P̅   NTPP   N̅T̅P̅P̅    Id  |
             |-------------------------------------------------------|
             | DC   |  DC | DC | DC | DC  | DC  |  DC  |  DC  |  DC  |
             | EC   |  DC | EC | EC | EC  | EC  |  EC  |  EC  |  EC  |
             | PO   |  DC | EC | PO | PO  | PO  |  PO  |  PO  |  PO  |
             | TPP  |  DC | EC | PO | TPP | PO  |  TPP |  PO  |  TPP |
             | T̅P̅P̅  |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  |  T̅P̅P̅ |  T̅P̅P̅ |
             | NTPP |  DC | EC | PO | TPP | PO  | NTPP |  PO  |  TPP |
             | N̅T̅P̅P̅ |  DC | EC | PO | PO  | T̅P̅P̅ |  PO  | N̅T̅P̅P̅ |  T̅P̅P̅ |
             |  Id  |  DC | EC | PO | TPP | T̅P̅P̅ |  TPP |  T̅P̅P̅ |  Id  |
             &#39;-------------------------------------------------------&#39;</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RCC8Relations
7-element Vector{RCCRelation}:
 _Topo_DC()
 _Topo_EC()
 _Topo_PO()
 _Topo_TPP()
 _Topo_TPPi()
 _Topo_NTPP()
 _Topo_NTPPi()

julia&gt; @assert SoleLogics._Topo_DC() == Topo_DC

julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; collect(accessibles(fr, Interval(4,8), Topo_DC))
6-element Vector{Interval{Int64}}:
 (9−10)
 (9−11)
 (10−11)
 (1−2)
 (1−3)
 (2−3)

julia&gt; syntaxstring.(RCC8Relations)
7-element Vector{String}:
 &quot;DC&quot;
 &quot;EC&quot;
 &quot;PO&quot;
 &quot;TPP&quot;
 &quot;T̅P̅P̅&quot;
 &quot;NTPP&quot;
 &quot;N̅T̅P̅P̅&quot;

julia&gt; RCC5Relations
4-element Vector{RCCRelation}:
 _Topo_DR()
 _Topo_PO()
 _Topo_PP()
 _Topo_PPi()</code></pre><p>See also  <a href="#SoleLogics.RCC8Relations"><code>RCC8Relations</code></a>, <a href="#SoleLogics.RCC5Relations"><code>RCC5Relations</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/RCC.jl#L5-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.RectangleRelation" href="#SoleLogics.RectangleRelation"><code>SoleLogics.RectangleRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}
struct RectangleRelation{R1&lt;:IABase,R2&lt;:IABase} &lt;: GeometricalRelation
    x :: R1
    y :: R2
end</code></pre><p>Relation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(IA2DRelations[1:20:end])
9-element Vector{String}:
 &quot;=,A&quot;
 &quot;A,L̅&quot;
 &quot;B,L&quot;
 &quot;E,B̅&quot;
 &quot;O,B&quot;
 &quot;A̅,E̅&quot;
 &quot;B̅,E&quot;
 &quot;E̅,D̅&quot;
 &quot;O̅,D&quot;</code></pre><p>See also <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.IntervalRelation"><code>IntervalRelation</code></a>, [<code>[</code>GeometricalRelation`](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/IA2D.jl#L36-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.SyntaxTree" href="#SoleLogics.SyntaxTree"><code>SoleLogics.SyntaxTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SyntaxTree{
    T&lt;:AbstractSyntaxToken,
} &lt;: AbstractSyntaxStructure
    token::T
    children::NTuple{N,SyntaxTree} where {N}
end</code></pre><p>A syntax tree encoding a logical formula. Each node of the syntax tree holds a <code>token</code>, and has as many children as the <code>arity</code> of the token.</p><p>This implementation is <em>arity-compliant</em>, in that, upon construction, the arity is checked against the number of children provided.</p><p>See also <a href="@ref"><code>token</code></a>, <a href="@ref"><code>children</code></a>, <a href="@ref"><code>tokentype</code></a>, <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>operators</code></a>, <a href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>atoms</code></a>, <a href="#SoleLogics.ntokens-Tuple{AbstractFormula}"><code>ntokens</code></a>, <a href="#SoleLogics.natoms-Tuple{AbstractFormula}"><code>natoms</code></a>, <a href="#SoleLogics.height-Tuple{AbstractFormula}"><code>height</code></a>, <a href="@ref"><code>tokenstype</code></a>, <a href="@ref"><code>operatorstype</code></a>, <a href="@ref"><code>atomstype</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>, <a href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}"><code>arity</code></a>, <a href="#SoleLogics.Atom"><code>Atom</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L650-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ToCenteredRel" href="#SoleLogics.ToCenteredRel"><code>SoleLogics.ToCenteredRel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ToCenteredRel &lt;: AbstractRelation end;
const tocenterrel = ToCenteredRel();</code></pre><p>Singleton type for a relation that leads to the world at the center of a frame. The relation is transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.tocenterrel)
&quot;◉&quot;</code></pre><p>See also <a href="#SoleLogics.IdentityRel"><code>IdentityRel</code></a>, <a href="#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}"><code>centralworld</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames.jl#L79-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TopOperator" href="#SoleLogics.TopOperator"><code>SoleLogics.TopOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TopOperator &lt;: AbstractTruthOperator end
const TOP = TopOperator()
const ⊤ = TOP</code></pre><p>Canonical truth operator representing the value <code>true</code>. It can be typed by <code>\top&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.BOTTOM"><code>BOTTOM</code></a>, <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1420-L1429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TruthDict" href="#SoleLogics.TruthDict"><code>SoleLogics.TruthDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TruthDict{
    A,
    T&lt;:TruthValue,
    D&lt;:AbstractDict{&lt;:Atom{&lt;:A},T}
} &lt;: AbstractAssignment{A,T}
    truth::D
end</code></pre><p>A logical interpretation instantiated as a dictionary, explicitly assigning truth values to a <em>finite</em> set of atoms. If prompted for the value of an unknown atom, it throws an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; TruthDict(1:4)
TruthDict with values:
┌───────┬───────┬───────┬───────┐
│     4 │     2 │     3 │     1 │
│ Int64 │ Int64 │ Int64 │ Int64 │
├───────┼───────┼───────┼───────┤
│  true │  true │  true │  true │
└───────┴───────┴───────┴───────┘


julia&gt; t1 = TruthDict(1:4, false); t1[5] = true; t1
TruthDict with values:
┌───────┬───────┬───────┬───────┬───────┐
│     5 │     4 │     2 │     3 │     1 │
│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │
├───────┼───────┼───────┼───────┼───────┤
│  true │ false │ false │ false │ false │
└───────┴───────┴───────┴───────┴───────┘


julia&gt; t2 = TruthDict([&quot;a&quot; =&gt; true, &quot;b&quot; =&gt; false, &quot;c&quot; =&gt; true])
TruthDict with values:
┌────────┬────────┬────────┐
│      c │      b │      a │
│ String │ String │ String │
├────────┼────────┼────────┤
│   true │  false │   true │
└────────┴────────┴────────┘

julia&gt; check(parsebaseformula(&quot;a ∨ b&quot;), t2)
true
</code></pre><p>See also <a href="#SoleLogics.DefaultedTruthDict"><code>DefaultedTruthDict</code></a>, <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L176-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TruthOperator" href="#SoleLogics.TruthOperator"><code>SoleLogics.TruthOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TruthOperator{T&lt;:TruthValue} &lt;: AbstractTruthOperator
    value::T
end</code></pre><p>A truth operator wrapping a truth value of a given type.</p><p>See also <a href="#SoleLogics.AbstractTruthOperator"><code>AbstractTruthOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1448-L1456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TruthTable" href="#SoleLogics.TruthTable"><code>SoleLogics.TruthTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TruthTable{A,T&lt;:TruthValue}</code></pre><p>Dictionary which associates an <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>s to the truth value of the assignment itself on a <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L495-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.TruthValue" href="#SoleLogics.TruthValue"><code>SoleLogics.TruthValue</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for any Julia type that may instantiate truth values. In the crisp case, <code>Bool</code> values are used. In the fuzzy case, other values can be used. For example, <code>AbstractFloat</code>s can be used with chain algebras, and 0.0 and 1.0 are the <code>bottom</code> and <code>top</code>.</p><p>See also <a href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra}"><code>top</code></a>, <a href="#SoleLogics.bottom-Tuple{SoleLogics.AbstractAlgebra}"><code>bottom</code></a>, <a href="#SoleLogics.istop-Tuple{Any}"><code>istop</code></a>, <a href="#SoleLogics.isbottom-Tuple{Any}"><code>isbottom</code></a>, <a href="@ref"><code>Algebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1346-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.World" href="#SoleLogics.World"><code>SoleLogics.World</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct World{T} &lt;: AbstractWorld
    name::T
end</code></pre><p>A world that is solely identified by its <code>name</code>. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.</p><p>See also <a href="#SoleLogics.OneWorld"><code>OneWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.WorldSet" href="#SoleLogics.WorldSet"><code>SoleLogics.WorldSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const AbstractWorldSet{W} = Union{AbstractVector{W},AbstractSet{W}} where {W&lt;:AbstractWorld}
const WorldSet{W} = Vector{W} where {W&lt;:AbstractWorld}</code></pre><p>Useful aliases.</p><p>See also <a href="#SoleLogics.AbstractWorldSet"><code>AbstractWorldSet</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.WrapperMultiModalFrame" href="#SoleLogics.WrapperMultiModalFrame"><code>SoleLogics.WrapperMultiModalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WrapperMultiModalFrame{
    W&lt;:AbstractWorld,
    D&lt;:AbstractDict{&lt;:AbstractRelation,&lt;:AbstractUniModalFrame{W}}
} &lt;: AbstractMultiModalFrame{W}
    frames::D
end</code></pre><p>A multi-modal frame that is the superposition of many uni-modal frames. It uses a single <code>AbstractUniModalFrame</code> for each of relations.</p><p>See also <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L424-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA, T}, Atom, Vararg{Any}}} where {AA, T}" href="#Base.getindex-Union{Tuple{T}, Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA, T}, Atom, Vararg{Any}}} where {AA, T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(i::AbstractAssignment{AA,T}, p::Atom, args...)::T where {AA,T&lt;:TruthValue}</code></pre><p>Return the truth value of an atom, given an assignment.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Union{Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA}, Atom}} where AA" href="#Base.haskey-Union{Tuple{AA}, Tuple{SoleLogics.AbstractAssignment{AA}, Atom}} where AA"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.haskey(::Atom{A}, i::AbstractAssignment{A})::Bool where {A}</code></pre><p>Return whether an assigment has a truth value for a given atom.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{AbstractSyntaxToken, AbstractFormula}" href="#Base.in-Tuple{AbstractSyntaxToken, AbstractFormula}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(tok::AbstractSyntaxToken, f::AbstractFormula)::Bool</code></pre><p>Return whether a syntax token appears in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L578-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{AbstractSyntaxToken, SyntaxTree}" href="#Base.in-Tuple{AbstractSyntaxToken, SyntaxTree}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(tok::AbstractSyntaxToken, tree::SyntaxTree)::Bool</code></pre><p>Return whether a token appears in a syntax tree or not.</p><p>See also <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L737-L743">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}" href="#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(p::Atom, a::AbstractAlphabet)::Bool</code></pre><p>Return whether an atom belongs to an alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1018-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}" href="#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(t::SyntaxTree, g::AbstractGrammar)::Bool</code></pre><p>Return whether a formula, encoded as a <code>SyntaxTree</code>, belongs to a grammar.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1165-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{SoleLogics.AbstractAlphabet}" href="#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(a::AbstractAlphabet)
Base.iterate(a::AbstractAlphabet, state)</code></pre><p>Return an iterator to the next element in an alhabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1056-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{SoleLogics.AbstractAlphabet}" href="#Base.length-Tuple{SoleLogics.AbstractAlphabet}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.length(a::AbstractAlphabet)::Bool</code></pre><p>Return the alphabet length, if it is finite.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1041-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.operator_precedence-Tuple{SoleLogics.AbstractOperator}" href="#Base.operator_precedence-Tuple{SoleLogics.AbstractOperator}"><code>Base.operator_precedence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.operator_precedence(op::AbstractOperator)
Base.operator_precedence(::typeof(IMPLICATION))</code></pre><p>Assign a precedence to an operator.</p><p>See also <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>, <a href="#SoleLogics.MAX_PRECEDENCE"><code>MAX_PRECEDENCE</code></a>, <a href="#SoleLogics.HIGH_PRECEDENCE"><code>HIGH_PRECEDENCE</code></a>, <a href="#SoleLogics.BASE_PRECEDENCE"><code>BASE_PRECEDENCE</code></a>, <a href="#SoleLogics.LOW_PRECEDENCE"><code>LOW_PRECEDENCE</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L386-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Any, Vararg{Any}}" href="#Base.rand-Tuple{Any, Vararg{Any}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.rand(
    [rng::AbstractRNG = Random.GLOBAL_RNG, ]
    alphabet,
    args...;
    kwargs...
)::Atom</code></pre><p>Randomly sample an atom from an <code>alphabet</code>, according to a uniform distribution.</p><p><strong>Implementation</strong></p><p>If the <code>alphabet</code> is finite, the function defaults to <code>rand(rng, atoms(alphabet))</code>; otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.</p><p>See also <a href="@ref"><code>isfinite</code></a>, <a href="@ref">`AbstractAlphabet&#39;</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/random.jl#L9-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld" href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation
) where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code> via relation <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; typeof(accessibles(fr, Interval(2,5), IA_L))
Base.Generator{...}

julia&gt; typeof(accessibles(fr, globalrel))
Base.Generator{...}

julia&gt; @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))

julia&gt; typeof(accessibles(fr, Interval(2,5), identityrel))
Vector{Interval{Int64}}

julia&gt; Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>Since <code>accessibles</code> always returns an iterator of worlds of the same type <code>W</code>, the current implementation of <code>accessibles</code> for multi-modal frames delegates the enumeration to a lower level <code>_accessibles</code> function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:</p><pre><code class="nohighlight hljs">function accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    IterTools.imap(W, _accessibles(fr, w, r))
end</code></pre><p>As such, when defining new frames, worlds, and/or relations, one should provide new methods for <code>_accessibles</code>. For example:</p><pre><code class="nohighlight hljs">_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)</code></pre><p>This pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type <code>FR{W}</code>, one can resolve the ambiguities and define a custom <code>accessibles</code> method by providing these three methods:</p><pre><code class="nohighlight hljs"># access worlds through relation `r`
function accessibles(
    fr::FR{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    ...
end

# access current world
function accessibles(
    fr::FR{W},
    w::W,
    r::IdentityRel,
) where {W&lt;:AbstractWorld}
    [w]
end

# access all worlds
function accessibles(
    fr::FR{W},
    w::W,
    r::GlobalRel,
) where {W&lt;:AbstractWorld}
    allworlds(fr)
end</code></pre><p>In general, it should be true that <code>collect(accessibles(fr, w, r)) isa AbstractVector{W}</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L325-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld" href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accessibles(fr::AbstractUniModalFrame{W}, w::W)::Vector{W} where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, A}}, Tuple{A}, Tuple{G}} where {G, A}" href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, A}}, Tuple{A}, Tuple{G}} where {G, A}"><code>SoleLogics.algebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">algebra(l::AbstractLogic{G,A})::A where {G,A}</code></pre><p>Return the <code>algebra</code> of a given logic.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1592-L1598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld" href="#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld"><code>SoleLogics.allworlds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allworlds(fr::AbstractFrame{W})::AbstractVector{&lt;:W} where {W&lt;:AbstractWorld}</code></pre><p>Return all worlds within the frame.</p><p>See also <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}" href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}"><code>SoleLogics.alphabet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alphabet(g::AbstractGrammar{A} where {A})::A</code></pre><p>Return the propositional alphabet of a grammar.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1143-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}" href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}"><code>SoleLogics.arity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arity(::Type{&lt;:AbstractRelation})::Integer
arity(t::AbstractRelation)::Integer = arity(typeof(t))</code></pre><p>Return the <code>arity</code> of the relation.</p><p>See also <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L212-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.arity-Tuple{Type{&lt;:AbstractSyntaxToken}}" href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractSyntaxToken}}"><code>SoleLogics.arity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arity(::Type{&lt;:AbstractSyntaxToken})::Integer
arity(tok::AbstractSyntaxToken)::Integer = arity(typeof(tok))</code></pre><p>Return the <code>arity</code> of a syntax token. The arity of a syntax token is an integer representing the number of allowed children in a <code>SyntaxTree</code>. Tokens with <code>arity</code> equal to 0, 1 or 2 are called <code>nullary</code>, <code>unary</code> and <code>binary</code>, respectively.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.atoms-Tuple{AbstractFormula}" href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>SoleLogics.atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L621-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}" href="#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>SoleLogics.atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>List the atoms of a <em>finite</em> alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>Base.isfinite</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1003-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.atoms-Tuple{SyntaxTree}" href="#SoleLogics.atoms-Tuple{SyntaxTree}"><code>SoleLogics.atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atoms(t::SyntaxTree)::AbstractVector{Atom}</code></pre><p>List all atoms appearing in a syntax tree.</p><p>See also <a href="#SoleLogics.natoms-Tuple{AbstractFormula}"><code>natoms</code></a>, <a href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>operators</code></a>, <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L771-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.baseformula-Tuple{Union{AbstractFormula, SYNTACTICAL}}" href="#SoleLogics.baseformula-Tuple{Union{AbstractFormula, SYNTACTICAL}}"><code>SoleLogics.baseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function baseformula(
    tokf::Union{AbstractSyntaxToken,AbstractFormula};
    infer_logic = true,
    additional_operators::Union{Nothing,Vector{&lt;:AbstractOperator}} = nothing,
    kwargs...,
)</code></pre><p>Attempt at instantiating a <code>Formula</code> from a syntax token/formula, by inferring the logic it belongs to. If <code>infer_logic</code> is true, then a canonical logic (e.g., propositional logic with all the <code>BASE_PROPOSITIONAL_OPERATORS</code>) is inferred; if it&#39;s false, then a logic with exactly the operators appearing in the syntax tree, plus the <code>additional_operators</code> is instantiated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = parseformula(&quot;◊((p∧q)→r)&quot;);

julia&gt; operators(logic(SoleLogics.baseformula(t)))
3-element Vector{Union{SoleLogics.NamedOperator{:→}, SoleLogics.NamedOperator{:◊}, SoleLogics.NamedOperator{:∧}}}:
 ∧
 ◊
 →

julia&gt; operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_OPERATORS)))
8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedOperator{:¬}, SoleLogics.NamedOperator{:∧}, SoleLogics.NamedOperator{:∨}, SoleLogics.NamedOperator{:→}, SoleLogics.NamedOperator{:◊}, SoleLogics.NamedOperator{:□}, SoleLogics.TopOperator}}:
 ⊤
 ⊥
 ¬
 ∧
 ∨
 →
 ◊
 □</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L343-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.bottom-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.bottom-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.bottom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bottom(a::AbstractAlgebra)</code></pre><p>Return the <code>bottom</code> of a given algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1525-L1531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.box-Tuple{}" href="#SoleLogics.box-Tuple{}"><code>SoleLogics.box</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}" href="#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}"><code>SoleLogics.centralworld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the world at the <em>center</em> of the frame; note that this does not always exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}" href="#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function check(
    f::AbstractFormula,
    is::InterpretationSet,
    i_instance::Integer,
    args...
)</code></pre><p>Dispatch to check a specific <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a> in a <a href="#SoleLogics.InterpretationSet"><code>InterpretationSet</code></a> over a formula.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="#SoleLogics.InterpretationSet"><code>InterpretationSet</code></a>, <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/interpretation-sets.jl#L80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.check-Tuple{Formula, SoleLogics.AbstractAssignment, Vararg{Any}}" href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractAssignment, Vararg{Any}}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(
    f::AbstractFormula,
    i::AbstractAssignment::{A,T},
    args...
)::T where {A,T&lt;:TruthValue}</code></pre><p>Check a logical formula on an assigment, returning a truth value. The (finite) <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a> algorithm depends on the given logic.</p><p>See also <a href="#SoleLogics.TruthDict"><code>TruthDict</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L136-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFormula, SoleLogics.AbstractInterpretation{A, T}, Vararg{Any}}} where {A, T}" href="#SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFormula, SoleLogics.AbstractInterpretation{A, T}, Vararg{Any}}} where {A, T}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(
    f::AbstractFormula,
    m::AbstractInterpretation{A,T},
    args...
)::T where {A,T&lt;:TruthValue}</code></pre><p>Check a formula on a logical interpretation (or model), returning a truth value. This process is referred to as <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>, and there are many algorithms for it, typically depending on the complexity of the logic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; td = TruthDict([p =&gt; true, q =&gt; false])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│  false │   true │
└────────┴────────┘

julia&gt; check(CONJUNCTION(p,q), td)
false</code></pre><p>See also <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1785-L1818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{W}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}, Union{Nothing, AbstractWorld}}} where {W&lt;:AbstractWorld, A, T}" href="#SoleLogics.check-Union{Tuple{T}, Tuple{A}, Tuple{W}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}, Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}, Union{Nothing, AbstractWorld}}} where {W&lt;:AbstractWorld, A, T}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function check(     φ::SyntaxTree,     i::AbstractKripkeStructure{W,A,T},     w::Union{Nothing,&lt;:AbstractWorld} = nothing;     use<em>memo::Union{Nothing,AbstractDict{&lt;:AbstractFormula,&lt;:WorldSet}} = nothing,     perform</em>normalization::Bool = true,     memo<em>max</em>height::Union{Nothing,Int} = nothing, )::T where {W&lt;:AbstractWorld,A,T&lt;:TruthValue}</p><p>Check a formula on a specific word in a <a href="#SoleLogics.KripkeStructure"><code>KripkeStructure</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs, Random

julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_OPERATORS)
¬□(p ∨ q)

# A special graph, called Kripke Frame, is created.
# Nodes are called worlds, and the edges are relations between worlds.
julia&gt; worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5

julia&gt; edges = Edge.([ (1, 2), (1, 3), (2, 4), (3, 4), (3, 5)])

julia&gt; kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))

# A valuation function establishes which fact are true on each world
julia&gt; valuation = Dict([
    worlds[1] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[2] =&gt; TruthDict([p =&gt; true, q =&gt; true]),
    worlds[3] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[4] =&gt; TruthDict([p =&gt; false, q =&gt; false]),
    worlds[5] =&gt; TruthDict([p =&gt; false, q =&gt; true]),
 ])

# Kripke Frame and valuation function are merged in a Kripke Model (or Kripke Structure)
julia&gt; kstruct = KripkeStructure(kframe, valuation)

julia&gt; [w =&gt; check(fmodal, kstruct, w) for w in worlds]
5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:
 SoleLogics.World{Int64}(1) =&gt; 0
 SoleLogics.World{Int64}(2) =&gt; 1
 SoleLogics.World{Int64}(3) =&gt; 1
 SoleLogics.World{Int64}(4) =&gt; 0
 SoleLogics.World{Int64}(5) =&gt; 0</code></pre><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.KripkeStructure"><code>KripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L582-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.collatetruth-Union{Tuple{T}, Tuple{N}, Tuple{SoleLogics.AbstractAlgebra{T}, SoleLogics.AbstractOperator, Tuple{Vararg{T, N}}}} where {N, T}" href="#SoleLogics.collatetruth-Union{Tuple{T}, Tuple{N}, Tuple{SoleLogics.AbstractAlgebra{T}, SoleLogics.AbstractOperator, Tuple{Vararg{T, N}}}} where {N, T}"><code>SoleLogics.collatetruth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collatetruth(
    a::AbstractAlgebra,
    op::AbstractOperator,
    t::NTuple{N,T},
)::T where {N,T&lt;:TruthValue}</code></pre><p>Return the truth value of a composed formula op(φ1, ..., φN), given the <code>N</code> truth values of its immediate sub-formulas. An algebra must provide a <code>collatetruth</code> method for each operator that can be interpreted on it.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a> <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/base-logic.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, SoleLogics.AbstractOperator, Tuple{Vararg{var&quot;#s368&quot;, N}} where var&quot;#s368&quot;&lt;:(Union{AbstractSet{W}, AbstractVector{W}} where W&lt;:AbstractWorld)}} where {N, W&lt;:AbstractWorld}" href="#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, SoleLogics.AbstractOperator, Tuple{Vararg{var&quot;#s368&quot;, N}} where var&quot;#s368&quot;&lt;:(Union{AbstractSet{W}, AbstractVector{W}} where W&lt;:AbstractWorld)}} where {N, W&lt;:AbstractWorld}"><code>SoleLogics.collateworlds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function collateworlds(
    fr::AbstractFrame{W},
    op::AbstractOperator,
    t::NTuple{N,WorldSetType},
)::AbstractWorldSet{&lt;:W} where {N,W&lt;:AbstractWorld,WorldSetType&lt;:AbstractWorldSet}</code></pre><p>For a given crisp frame (<code>truthtype == Bool</code>), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the <code>N</code> sets of worlds where the each immediate sub-formula is true.</p><p>See also <a href="#SoleLogics.check-Tuple{AbstractFormula, SoleLogics.InterpretationSet, Integer, Vararg{Any}}"><code>check</code></a>, <a href="#SoleLogics.iscrisp-Tuple{Type{&lt;:SoleLogics.AbstractAlgebra}}"><code>iscrisp</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/check.jl#L325-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.converse-Tuple{Type{&lt;:AbstractRelation}}" href="#SoleLogics.converse-Tuple{Type{&lt;:AbstractRelation}}"><code>SoleLogics.converse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converse(R::Type{&lt;:AbstractRelation})::Type{&lt;:AbstractRelation}
converse(r::AbstractRelation)::AbstractRelation = converse(typeof(r))()</code></pre><p>If it exists, return the converse relation (type) of a given relation (type).</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L255-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.default_algebra-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#SoleLogics.default_algebra-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>SoleLogics.default_algebra</code></a> — <span class="docstring-category">Method</span></header><section><div><p>default_algebra(::Type{T})::AbstractAlgebra{&lt;:T} where {T&lt;:TruthValue}</p><p>Return the fallback algebra for a given truth value type.</p><p><strong>Implementation</strong></p><p>In order to check syntax trees without algebras, truth values should provide a default algebra it works with.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1380-L1389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.diamond-Tuple{}" href="#SoleLogics.diamond-Tuple{}"><code>SoleLogics.diamond</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domain(a::AbstractAlgebra)</code></pre><p>Return the <code>domain</code> of a given algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1500-L1506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.dual-Tuple{AbstractSyntaxToken}" href="#SoleLogics.dual-Tuple{AbstractSyntaxToken}"><code>SoleLogics.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(tok::AbstractSyntaxToken)</code></pre><p>Return the <code>dual</code> of a syntax token. Given a token <code>tok</code> of arity <code>n</code>, the dual <code>dtok</code> is such that, on a boolean algebra, <code>tok(ch_1, ..., ch_n)</code> ≡ <code>¬dtok(¬ch_1, ..., ¬ch_n)</code>.</p><p>Duality can be used to perform synctactic simplifications on formulas. For example, since <code>∧</code> and <code>∨</code> are <code>dual</code>s, <code>¬(¬p ∧ ¬q)</code> can be simplified to <code>(p ∧ q)</code>. Duality also applies to nullary operators (<code>⊤</code>/<code>⊥</code>), operators with existential/universal semantics (<code>◊</code>/<code>□</code>), and <code>Atom</code>s.</p><p><strong>Implementation</strong></p><p>When providing a <code>dual</code> for an operator of type <code>O</code>, please also provide:</p><pre><code class="nohighlight hljs">hasdual(::O) = true</code></pre><p>The dual of an <code>Atom</code> (that is, the atom with inverted semantics) is defined as:</p><pre><code class="nohighlight hljs">dual(p::Atom{A}) where {A} = Atom(dual(value(p)))</code></pre><p>As such, <code>hasdual(::A)</code> and <code>dual(::A)</code> should be defined when wrapping objects of type <code>A</code>.</p><p>See also <a href="#SoleLogics.normalize-Tuple{AbstractSyntaxStructure}"><code>normalize</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.emptyworld-Tuple{SoleLogics.AbstractMultiModalFrame}" href="#SoleLogics.emptyworld-Tuple{SoleLogics.AbstractMultiModalFrame}"><code>SoleLogics.emptyworld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return an empty world (e.g., <code>Interval(-1,0)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/frames.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{A, O} where {A, O}}" href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{A, O} where {A, O}}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::AbstractGrammar;
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing,
    args...
)::Vector{&lt;:SyntaxTree}</code></pre><p>Enumerate the formulas produced by a given grammar with a finite and iterable alphabet.</p><p><strong>Implementation</strong></p><p>Additional <code>args</code> can be used to model the function&#39;s behavior. At least these two arguments should be covered:</p><ul><li>a <code>nformulas</code> argument can be used to limit the size of the returned <code>Vector</code>;</li><li>a <code>maxdepth</code> argument can be used to limit the syntactic component, represented as a syntax tree,</li></ul><p>to a given maximum depth;</p><p>See also <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1177-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}" href="#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::CompleteFlatGrammar{A,O} where {A,O};
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing
)::Vector{SyntaxTree}</code></pre><p>Generate all formulas with syntax trees that are not taller than a given <code>maxdepth</code>.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1298-L1308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}" href="#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}"><code>SoleLogics.goeswithdim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Some worlds (dimensional worlds) can be interpreted on dimensional data, that is, n-dimensional arrays. The compatibility of a given world with respect of a  structure of a given dimensionality must be specified via the following trait:</p><pre><code class="nohighlight hljs">goeswithdim(w::AbstractWorld, d) = goeswithdim(typeof(w), d)
goeswithdim(W::Type{&lt;:AbstractWorld}, d::Integer) = goeswithdim(W, Val(d))
goeswithdim(::Type{&lt;:AbstractWorld}, ::Val) = false</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(OneWorld, 0)
true

julia&gt; SoleLogics.goeswithdim(OneWorld, 1)
false

julia&gt; SoleLogics.goeswithdim(Interval, 1)
true

julia&gt; SoleLogics.goeswithdim(Interval, 2)
false

julia&gt; all([SoleLogics.goeswithdim.(SoleLogics.Point{N}, N) for N in 1:10])
true
</code></pre><p>See also <a href="#SoleLogics.OneWorld"><code>OneWorld</code></a>, <a href="#SoleLogics.World"><code>World</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/worlds.jl#L2-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G" href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G"><code>SoleLogics.grammar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grammar(l::AbstractLogic{G})::G where {G&lt;:AbstractGrammar}</code></pre><p>Return the <code>grammar</code> of a given logic.</p><p>See also <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G"><code>grammar</code></a>, <a href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, A}}, Tuple{A}, Tuple{G}} where {G, A}"><code>algebra</code></a>, <a href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>operators</code></a>, <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}"><code>alphabet</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T"><code>truthtype</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{A, O} where {A, O}}"><code>formulas</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1565-L1575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.hasconverse-Tuple{Type{&lt;:AbstractRelation}}" href="#SoleLogics.hasconverse-Tuple{Type{&lt;:AbstractRelation}}"><code>SoleLogics.hasconverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converse(R::Type{&lt;:AbstractRelation})::Type{&lt;:AbstractRelation}
converse(r::AbstractRelation)::AbstractRelation = converse(typeof(r))()</code></pre><p>If it exists, return the converse relation (type) of a given relation (type).</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.height-Tuple{AbstractFormula}" href="#SoleLogics.height-Tuple{AbstractFormula}"><code>SoleLogics.height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L633-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.height-Tuple{SyntaxTree}" href="#SoleLogics.height-Tuple{SyntaxTree}"><code>SoleLogics.height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">height(t::SyntaxTree)::Integer</code></pre><p>Return the height of a syntax tree.</p><p>See also <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L818-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isbottom-Tuple{Any}" href="#SoleLogics.isbottom-Tuple{Any}"><code>SoleLogics.isbottom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbottom(::TruthValue)::Bool</code></pre><p>Return true if the truth value is the bottom of its algebra. For example, in the crisp case, with <code>Bool</code> truth values, it is:</p><pre><code class="nohighlight hljs">isbottom(t::Bool)::Bool = (t == false)</code></pre><p>See also <a href="#SoleLogics.istop-Tuple{Any}"><code>istop</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1368-L1377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isbox-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.isbox-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.isbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbox(::Type{&lt;:AbstractOperator})::Bool = false
isbox(o::AbstractOperator)::Bool = isbox(typeof(o))</code></pre><p>Return whether it is known that an <code>AbstractOperator</code> is a box (i.e., universal) operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.isbox(◊)
false

julia&gt; SoleLogics.isbox(∧)
false

julia&gt; SoleLogics.isbox(□)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L792-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.iscommutative-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.iscommutative-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.iscommutative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscommutative(::Type{AbstractOperator})
iscommutative(o::AbstractOperator) = iscommutative(typeof(o))</code></pre><p>Return whether an operator is known to be commutative.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iscommutative(∧)
true

julia&gt; iscommutative(→)
false</code></pre><p>Note that nullary and unary operators are considered commutative.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p><p><strong>Implementation</strong></p><p>When implementing a new type for a <em>commutative</em> operator <code>O</code> with arity higher than 1, please provide a method <code>iscommutative(::Type{O})</code>. This can help model checking operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L329-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.iscrisp-Tuple{Type{&lt;:SoleLogics.AbstractAlgebra}}" href="#SoleLogics.iscrisp-Tuple{Type{&lt;:SoleLogics.AbstractAlgebra}}"><code>SoleLogics.iscrisp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscrisp(A::Type{&lt;:AbstractAlgebra}) = (truthtype(A) == Bool)
iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))</code></pre><p>An algebra is crisp (or <em>boolean</em>) when its domain type is... <code>Bool</code>, quite literally! The antonym of crisp is <em>fuzzy</em>.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1536-L1544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isgrounded-Tuple{AbstractFormula}" href="#SoleLogics.isgrounded-Tuple{AbstractFormula}"><code>SoleLogics.isgrounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isgrounded(f::AbstractFormula)::Bool</code></pre><p>Return <code>true</code> if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parsebaseformula(&quot;⟨G⟩p → [G]q&quot;);

julia&gt; syntaxstring(f)
&quot;(⟨G⟩p) → ([G]q)&quot;

julia&gt; SoleLogics.isgrounded(f)
true</code></pre><p>See also <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>), <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/check.jl#L297-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isgrounding-Tuple{AbstractRelation}" href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>SoleLogics.isgrounding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isgrounding(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is grounding. A relation <code>R</code> is grounding if ∀x,y R(x,y) ⇔ R(z,y).</p><p>See also <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L290-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ismodal-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.ismodal-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.ismodal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismodal(::Type{&lt;:AbstractOperator})::Bool = false
ismodal(o::AbstractOperator)::Bool = ismodal(typeof(o))</code></pre><p>Return whether it is known that an <code>AbstractOperator</code> is modal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ismodal(◊)
true

julia&gt; ismodal(∧)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L774-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isreflexive-Tuple{AbstractRelation}" href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>SoleLogics.isreflexive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreflexive(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is reflexive.</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isrightassociative-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.isrightassociative-Tuple{Type{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.isrightassociative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isrightassociative(::Type{AbstractOperator})
isrightassociative(o::AbstractOperator) = isrightassociative(typeof(o))</code></pre><p>Return whether an <code>AbstractOperator</code> is right associative or no.</p><p>Associativity establishes how operators of the same precedence are grouped in the absence of the parentheses.</p><p>Conjunction and disjunction are commutative operators, thus, the left associativity case &quot;(p ∧ q) ∧ r&quot; and the right associativity case &quot;p ∧ (q ∧ r)&quot; are equivalent; by convention we consider the latter form. Implication is right associative, meaning that &quot;p → q → r&quot; is grouped as &quot;p → (q → r)&quot;.</p><p>By default, an operator is right associative.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isrightassociative(∧)
true

julia&gt; isrightassociative(→)
true</code></pre><p>See also <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L406-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.issymmetric-Tuple{AbstractRelation}" href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>SoleLogics.issymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymmetric(::AbstractRelation) = hasconverse(r) ? converse(r) == r : false</code></pre><p>Return whether it is known that a relation is symmetric.</p><p>See also <a href="#SoleLogics.hasconverse-Tuple{Type{&lt;:AbstractRelation}}"><code>hasconverse</code></a>, <a href="#SoleLogics.converse-Tuple{Type{&lt;:AbstractRelation}}"><code>converse</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.istop-Tuple{Any}" href="#SoleLogics.istop-Tuple{Any}"><code>SoleLogics.istop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istop(::TruthValue)::Bool</code></pre><p>Return true if the truth value is the top of its algebra. For example, in the crisp case, with <code>Bool</code> truth values, it is:</p><pre><code class="nohighlight hljs">istop(t::Bool)::Bool = (t == true)</code></pre><p>See also <a href="#SoleLogics.isbottom-Tuple{Any}"><code>isbottom</code></a>, <a href="#SoleLogics.TruthValue"><code>TruthValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1356-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}" href="#SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}"><code>SoleLogics.istopological</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istopological(r::GeometricalRelation)</code></pre><p>Return whether it is known that a given geometrical relation is topological (i.e., invariant under homeomorphisms,  see <a href="https://en.wikipedia.org/wiki/Topological_property">here</a>)</p><p>See also <a href="#SoleLogics.GeometricalRelation"><code>GeometricalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/algebras/relations/geometrical-relations.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.istransitive-Tuple{AbstractRelation}" href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>SoleLogics.istransitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istransitive(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is transitive.</p><p>See also <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L280-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.joinformulas-Union{Tuple{F}, Tuple{N}, Tuple{SoleLogics.AbstractOperator, Tuple{Vararg{F, N}}}} where {N, F&lt;:AbstractFormula}" href="#SoleLogics.joinformulas-Union{Tuple{F}, Tuple{N}, Tuple{SoleLogics.AbstractOperator, Tuple{Vararg{F, N}}}} where {N, F&lt;:AbstractFormula}"><code>SoleLogics.joinformulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">joinformulas(
    op::AbstractOperator,
    ::NTuple{N,F}
)::F where {N,F&lt;:AbstractFormula}</code></pre><p>Return a new formula of type <code>F</code> by composing <code>N</code> formulas of the same type via an operator <code>op</code>. This function allows one to use operators for flexibly composing formulas (see <em>Implementation</em>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;◊(p→q)&quot;);

julia&gt; p = Atom(&quot;p&quot;);

julia&gt; ∧(f, p)  # Easy way to compose a formula
SyntaxTree: ◊(p → q) ∧ p

julia&gt; f ∧ ¬p   # Leverage infix notation ;)
SyntaxTree: ◊(p → q) ∧ ¬p

julia&gt; ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))
SyntaxTree: ◊(p → q) ∧ p ∧ ¬p</code></pre><p><strong>Implementation</strong></p><p>Upon <code>joinformulas</code> lies a flexible way of using operators for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:</p><pre><code class="nohighlight hljs">function (op::AbstractOperator)(
    children::NTuple{N,Union{AbstractSyntaxToken,AbstractFormula}},
) where {N}
    ...
end</code></pre><p>These allow composing formulas as in <code>∧(f, ¬p)</code>, and in order to access this composition with any newly defined subtype of <code>AbstractFormula</code>, a new method for <code>joinformulas</code> should be defined, together with promotion from/to other <code>AbstractFormula</code>s should be taken care of (see <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">here</a> and <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">here</a>).</p><p>Similarly, for allowing a (possibly newly defined) operator to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined operator <code>op</code>, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as <code>∧(f, f2, f3, ...)</code> and <code>∨(f, f2, f3, ...)</code> can be done thanks to the following two methods that were defined in SoleLogics:</p><pre><code class="nohighlight hljs">function ∧(
    c1::Union{AbstractSyntaxToken,AbstractFormula},
    c2::Union{AbstractSyntaxToken,AbstractFormula},
    c3::Union{AbstractSyntaxToken,AbstractFormula},
    cs::Union{AbstractSyntaxToken,AbstractFormula}...
)
    return ∧(c1, ∧(c2, c3, cs...))
end
function ∨(
    c1::Union{AbstractSyntaxToken,AbstractFormula},
    c2::Union{AbstractSyntaxToken,AbstractFormula},
    c3::Union{AbstractSyntaxToken,AbstractFormula},
    cs::Union{AbstractSyntaxToken,AbstractFormula}...
)
    return ∨(c1, ∨(c2, c3, cs...))
end</code></pre><p>See also <a href="../autodocs/#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>, <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L470-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.modallogic-Tuple{}" href="#SoleLogics.modallogic-Tuple{}"><code>SoleLogics.modallogic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modallogic(;
    alphabet = AlphabetOfAny{String}(),
    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],
    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),
    algebra = BooleanAlgebra(),
)</code></pre><p>Instantiate a <a href="https://simple.wikipedia.org/wiki/Modal_logic">modal logic</a> given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (¬) isa operatorstype(modallogic());
true

julia&gt; (□) isa operatorstype(modallogic());
true

julia&gt; (□) isa operatorstype(modallogic(; operators = [¬, ∨]))
┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedOperator[¬, ∨]). Consider using propositionallogic instead.
└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642
false

julia&gt; modallogic(; alphabet = [&quot;p&quot;, &quot;q&quot;]);

julia&gt; modallogic(; alphabet = ExplicitAlphabet([Atom(&quot;p&quot;), Atom(&quot;q&quot;)]));
</code></pre><p>See also <a href="#SoleLogics.propositionallogic-Tuple{}"><code>propositionallogic</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L864-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.natoms-Tuple{AbstractFormula}" href="#SoleLogics.natoms-Tuple{AbstractFormula}"><code>SoleLogics.natoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L629-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.natoms-Tuple{SyntaxTree}" href="#SoleLogics.natoms-Tuple{SyntaxTree}"><code>SoleLogics.natoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">natoms(t::SyntaxTree)::Integer</code></pre><p>Return the count of all atoms appearing in a syntax tree.</p><p>See also <a href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>atoms</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L806-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.noperators-Tuple{SyntaxTree}" href="#SoleLogics.noperators-Tuple{SyntaxTree}"><code>SoleLogics.noperators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noperators(t::SyntaxTree)::Integer</code></pre><p>Return the count of all operators appearing in a syntax tree.</p><p>See also <a href="@ref"><code>operaters</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L794-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.normalize-Tuple{AbstractSyntaxStructure}" href="#SoleLogics.normalize-Tuple{AbstractSyntaxStructure}"><code>SoleLogics.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(
    f::AbstractFormula;
    remove_boxes = true,
    reduce_negations = true,
    allow_atom_flipping = true,
)</code></pre><p>Return a modified version of a given formula, that has the same semantics but different syntax. This is useful when dealing with the truth of many (possibly similar) formulas; for example, when performing <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>. BEWARE: it currently assumes the underlying algebra is Boolean!</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractFormula</code>: when set to <code>true</code>,   the formula;</li><li><code>remove_boxes::Bool</code>: converts all uni-modal and multi-modal box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.</li><li><code>reduce_negations::Bool</code>: when set to <code>true</code>,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s laws</a>).   Note: this assumes an underlying Boolean algebra.</li><li><code>allow_atom_flipping::Bool</code>: when set to <code>true</code>,   together with <code>reduce_negations=true</code>, this may cause the negation of an atom   to be replaced with the its <a href="#SoleLogics.dual-Tuple{AbstractSyntaxToken}"><code>dual</code></a> atom.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parsebaseformula(&quot;□¬((p∧¬q)→r)∧⊤&quot;);

julia&gt; syntaxstring(f)
&quot;□¬((p ∧ ¬q) → r) ∧ ⊤&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))
&quot;¬◊(q ∨ ¬p ∨ r)&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))
&quot;□(¬r ∧ p ∧ ¬q)&quot;</code></pre><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/check.jl#L48-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ntokens-Tuple{AbstractFormula}" href="#SoleLogics.ntokens-Tuple{AbstractFormula}"><code>SoleLogics.ntokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L625-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.ntokens-Tuple{SyntaxTree}" href="#SoleLogics.ntokens-Tuple{SyntaxTree}"><code>SoleLogics.ntokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ntokens(t::SyntaxTree)::Integer</code></pre><p>Return the count of all tokens appearing in a syntax tree.</p><p>See also <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L783-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}" href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>SoleLogics.nworlds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nworlds(fr::AbstractFrame)::Integer</code></pre><p>Return the number of worlds within the frame.</p><p>See also <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.operators-Tuple{AbstractFormula}" href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>SoleLogics.operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L617-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.operators-Tuple{SyntaxTree}" href="#SoleLogics.operators-Tuple{SyntaxTree}"><code>SoleLogics.operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operators(t::SyntaxTree)::AbstractVector{AbstractOperator}</code></pre><p>List all operators appearing in a syntax tree.</p><p>See also <a href="#SoleLogics.noperators-Tuple{SyntaxTree}"><code>noperators</code></a>, <a href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>atoms</code></a>, <a href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>tokens</code></a>, <a href="#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L759-L765">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}" href="#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>SoleLogics.parsebaseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function parsebaseformula(
    expression::String,
    additional_operators::Union{Nothing,Vector{&lt;:AbstractOperator}} = nothing;
    operators::Union{Nothing,Vector{&lt;:AbstractOperator}},
    grammar::Union{Nothing,AbstractGrammar} = nothing,
    algebra::Union{Nothing,AbstractAlgebra} = nothing,
    kwargs...
)::Formula</code></pre><p>Return a <code>Formula</code> which is the result of parsing <code>expression</code>  via the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a>  algorithm. By default, this function is only able to parse operators in <code>SoleLogics.BASE_PARSABLE_OPERATORS</code>; additional operators may be provided as a second argument.</p><p>The <code>grammar</code> and <code>algebra</code> of the associated logic is inferred using the <code>baseformula</code> function from the operators encountered in the expression, and those in <code>additional_operators</code>.</p><p>See <a href="../getting-started/#SoleLogics.parsetree"><code>parsetree</code></a>, <a href="#SoleLogics.baseformula-Tuple{Union{AbstractFormula, SYNTACTICAL}}"><code>baseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/parse.jl#L543-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}" href="#SoleLogics.parseformula-Tuple{Type{&lt;:AbstractFormula}, AbstractString, Vararg{Any}}"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function parseformula(
    F::Type{&lt;:AbstractFormula},
    str::AbstractString,
    args...;
    kwargs...
)</code></pre><p>Parses a formula of type <code>F</code> from a string. When <code>F</code> is not specified, it defaults to     <code>SyntaxTree</code> and <a href="../getting-started/#SoleLogics.parsetree"><code>parsetree</code></a> is called.</p><p>See also <a href="../getting-started/#SoleLogics.parsetree"><code>parsetree</code></a>, <a href="#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>parsebaseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/parse.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.parsetree-Tuple{Any, Vararg{Any}}" href="#SoleLogics.parsetree-Tuple{Any, Vararg{Any}}"><code>SoleLogics.parsetree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsetree(
    expression::String,
    additional_operators::Union{Nothing,Vector{&lt;:AbstractOperator}} = nothing;
    function_notation::Bool = false,
    atom_parser::Base.Callable = Atom{String},
    additional_whitespaces::Vector{Char} = Char[],
    opening_parenthesis::String = &quot;(&quot;,
    closing_parenthesis::String = &quot;)&quot;,
    arg_delim::String = &quot;,&quot;
)</code></pre><p>Return a <code>SyntaxTree</code> which is the result of parsing <code>expression</code>  via the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a>  algorithm. By default, this function is only able to parse operators in <code>SoleLogics.BASE_PARSABLE_OPERATORS</code> (see arguments section); additional operators may be provided as a second argument.</p><p><strong>Arguments</strong></p><ul><li><code>expression::String</code>: expression to be parsed;</li><li><code>additional_operators::Vector{&lt;:AbstractOperator}</code>: additional, non-standard operators   needed to correctly parse the expression.   When left unset, only the operators in <code>SoleLogics.BASE_PARSABLE_OPERATORS</code> are   correctly parsed: S, o, l, e, L, o, g, i, c, s, ., A, b, s, t, r, a, c, t, O, p, e, r, a, t, o, r, [, ⊤, ,,  , ⊥, ,,  , ¬, ,,  , ∧, ,,  , ∨, ,,  , →, ,,  , ◊, ,,  , □, ,,  , ⟨, G, ⟩, ,,  , [, G, ], ,,  , ⟨, =, ⟩, ,,  , [, =, ], ];   note that, in case of clashing <code>syntaxstring</code>&#39;s,   the provided additional operators will override these.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g, <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g, <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces</code>::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis</code>::String = &quot;(&quot;:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis</code>::String = &quot;)&quot;:   the string signaling the closing of an expression block;</li><li><code>arg_delim</code>::String = &quot;,&quot;:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parsetree(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parsetree(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parsetree(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><p>See also <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, [].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/parse.jl#L290-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.propositionallogic-Tuple{}" href="#SoleLogics.propositionallogic-Tuple{}"><code>SoleLogics.propositionallogic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propositionallogic(;
    alphabet = AlphabetOfAny{String}(),
    operators = [⊤, ⊥, ¬, ∧, ∨, →],
    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →]),
    algebra = BooleanAlgebra(),
)</code></pre><p>Instantiate a <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a> given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (¬) isa operatorstype(propositionallogic())
true

julia&gt; (¬) isa operatorstype(propositionallogic(; operators = [∨]))
false

julia&gt; propositionallogic(; alphabet = [&quot;p&quot;, &quot;q&quot;]);

julia&gt; propositionallogic(; alphabet = ExplicitAlphabet([Atom(&quot;p&quot;), Atom(&quot;q&quot;)]));
</code></pre><p>See also <a href="#SoleLogics.modallogic-Tuple{}"><code>modallogic</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/propositional-logic.jl#L7-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.randbaseformula-Tuple{Integer, Any, Vector{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.randbaseformula-Tuple{Integer, Any, Vector{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.randbaseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::SyntaxTree

function randbaseformula(
    height::Integer,
    g::AbstractGrammar;
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula

function randbaseformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula</code></pre><p>Return a pseudo-randomic <code>SyntaxTree</code> or <code>Formula</code>.</p><p><strong>Arguments</strong></p><ul><li><code>height::Integer</code>: height of the generated structure;</li><li><code>alphabet::AbstractAlphabet</code>: collection from which atoms are chosen randomly;</li><li><code>operators::Vector{&lt;:AbstractOperator}</code>: vector from which legal operators are chosen;</li><li><code>g::AbstractGrammar</code>: alternative to passing alphabet and operators separately.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG</code>: random number generator;</li><li><code>picker::Function</code> = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))
&quot;¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))&quot;</code></pre><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/random.jl#L203-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.randbaseformula-Tuple{Integer, SoleLogics.AbstractGrammar}" href="#SoleLogics.randbaseformula-Tuple{Integer, SoleLogics.AbstractGrammar}"><code>SoleLogics.randbaseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::SyntaxTree

function randbaseformula(
    height::Integer,
    g::AbstractGrammar;
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula

function randbaseformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula</code></pre><p>Return a pseudo-randomic <code>SyntaxTree</code> or <code>Formula</code>.</p><p><strong>Arguments</strong></p><ul><li><code>height::Integer</code>: height of the generated structure;</li><li><code>alphabet::AbstractAlphabet</code>: collection from which atoms are chosen randomly;</li><li><code>operators::Vector{&lt;:AbstractOperator}</code>: vector from which legal operators are chosen;</li><li><code>g::AbstractGrammar</code>: alternative to passing alphabet and operators separately.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG</code>: random number generator;</li><li><code>picker::Function</code> = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))
&quot;¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))&quot;</code></pre><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/random.jl#L187-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.randformula-Tuple{Integer, Any, Vector{&lt;:SoleLogics.AbstractOperator}}" href="#SoleLogics.randformula-Tuple{Integer, Any, Vector{&lt;:SoleLogics.AbstractOperator}}"><code>SoleLogics.randformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::SyntaxTree

function randbaseformula(
    height::Integer,
    g::AbstractGrammar;
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula

function randbaseformula(
    height::Integer,
    alphabet,
    operators::Vector{&lt;:AbstractOperator};
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG
)::Formula</code></pre><p>Return a pseudo-randomic <code>SyntaxTree</code> or <code>Formula</code>.</p><p><strong>Arguments</strong></p><ul><li><code>height::Integer</code>: height of the generated structure;</li><li><code>alphabet::AbstractAlphabet</code>: collection from which atoms are chosen randomly;</li><li><code>operators::Vector{&lt;:AbstractOperator}</code>: vector from which legal operators are chosen;</li><li><code>g::AbstractGrammar</code>: alternative to passing alphabet and operators separately.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG</code>: random number generator;</li><li><code>picker::Function</code> = method used to pick a random element. For example, this could be   Base.rand or SimpleStats.sample.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))
&quot;¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))&quot;</code></pre><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/random.jl#L219-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.relation-Tuple{AbstractRelationalOperator}" href="#SoleLogics.relation-Tuple{AbstractRelationalOperator}"><code>SoleLogics.relation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relationtype(::AbstractRelationalOperator{R}) where {R&lt;:AbstractRelation} = R
relation(op::AbstractRelationalOperator) = relationtype(op)()</code></pre><p>Return the underlying relation (and relation type) of the relational operator.</p><p>See also <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L950-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.relationtype-Union{Tuple{AbstractRelationalOperator{R}}, Tuple{R}} where R&lt;:AbstractRelation" href="#SoleLogics.relationtype-Union{Tuple{AbstractRelationalOperator{R}}, Tuple{R}} where R&lt;:AbstractRelation"><code>SoleLogics.relationtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relationtype(::AbstractRelationalOperator{R}) where {R&lt;:AbstractRelation} = R
relation(op::AbstractRelationalOperator) = relationtype(op)()</code></pre><p>Return the underlying relation (and relation type) of the relational operator.</p><p>See also <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L948-L955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.subformulas-Tuple{AbstractSyntaxStructure}" href="#SoleLogics.subformulas-Tuple{AbstractSyntaxStructure}"><code>SoleLogics.subformulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subformulas(f::AbstractFormula; sorted=true)</code></pre><p>Return all sub-formulas (sorted by size when <code>sorted=true</code>) of a given formula.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(SoleLogics.subformulas(parsebaseformula(&quot;◊((p∧q)→r)&quot;)))
6-element Vector{String}:
 &quot;p&quot;
 &quot;q&quot;
 &quot;r&quot;
 &quot;p ∧ q&quot;
 &quot;◊(p ∧ q)&quot;
 &quot;(◊(p ∧ q)) → r&quot;</code></pre><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/check.jl#L2-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.syntaxstring-Tuple{AbstractSyntaxToken}" href="#SoleLogics.syntaxstring-Tuple{AbstractSyntaxToken}"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syntaxstring(φ::AbstractFormula; kwargs...)::String
syntaxstring(tok::AbstractSyntaxToken; kwargs...)::String</code></pre><p>Produce the string representation of a formula or syntax token by performing a tree traversal of the syntax tree representation of the formula. Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leafs of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(p, ∧(q, ∧(r, ∧(s, t))))&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;(p) ∧ ((q) ∧ ((r) ∧ ((s) ∧ (t))))&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="../autodocs/#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>parsebaseformula</code></a>, <a href="#SoleLogics.parsetree"><code>parsetree</code></a>, <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="../autodocs/#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including <code>kwargs...</code>) for every newly defined <code>AbstractSyntaxToken</code> (e.g., operators and <code>Atom</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(p::Atom; kwargs...) = syntaxstring(value(p); kwargs...)</code></pre><p>Then, the syntaxstring for a given value can be defined. For example, with <code>String</code> (or <code>Number</code>) values, it defaults to:</p><pre><code class="nohighlight hljs">syntaxstring(value::String; kwargs...) = value</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>). See also <a href="../autodocs/#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>parsebaseformula</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L66-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.tokens-Tuple{AbstractFormula}" href="#SoleLogics.tokens-Tuple{AbstractFormula}"><code>SoleLogics.tokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(f::AbstractFormula)::AbstractVector{&lt;:AbstractSyntaxToken}
operators(f::AbstractFormula)::AbstractVector{&lt;:AbstractOperator}
atoms(f::AbstractFormula)::AbstractVector{&lt;:Atom}
ntokens(f::AbstractFormula)::Integer
noperators(f::AbstractFormula)::Integer
natoms(f::AbstractFormula)::Integer</code></pre><p>Return the list or the number of (unique) syntax tokens/operators/atoms appearing in a formula.</p><p>See also <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L613-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.tokens-Tuple{SyntaxTree}" href="#SoleLogics.tokens-Tuple{SyntaxTree}"><code>SoleLogics.tokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(t::SyntaxTree)::AbstractVector{AbstractSyntaxToken}</code></pre><p>List all tokens appearing in a syntax tree.</p><p>See also <a href="#SoleLogics.ntokens-Tuple{AbstractFormula}"><code>ntokens</code></a>, <a href="#SoleLogics.operators-Tuple{AbstractFormula}"><code>operators</code></a>, <a href="#SoleLogics.atoms-Tuple{AbstractFormula}"><code>atoms</code></a>, <a href="#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L748-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.top</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">top(a::AbstractAlgebra)</code></pre><p>Return the <code>top</code> of a given algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1514-L1520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.tree-Tuple{AbstractFormula}" href="#SoleLogics.tree-Tuple{AbstractFormula}"><code>SoleLogics.tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree(f::AbstractFormula)::SyntaxTree</code></pre><p>Extract the <code>SyntaxTree</code> representation of a formula (equivalent to <code>Base.convert(SyntaxTree, f)</code>).</p><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>. <a href="#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L917-L927">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}" href="#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}"><code>SoleLogics.treewalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function treewalk(
    st::SyntaxTree,
    args...;
    rng::AbstractRNG = Random.GLOBAL_RNG,
    criterion::Function = ntokens,
    toleaf::Bool = true,
    returnnode::Bool = false,
    transformnode::Function = nothing,
)::SyntaxTree</code></pre><p>Return a subtree from passed SyntaxTree by following options:</p><ul><li><code>criterion</code>: function used to calculate the probability of stopping at a random node;</li><li><code>returnnode</code>: true if only the subtree is to be returned;</li><li><code>transformnode</code>: function that will be applied to the chosen subtree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/syntax-utils.jl#L274-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T" href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T"><code>SoleLogics.truthtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truthtype(::Type{&lt;:AbstractAlgebra{T}}) where {T&lt;:TruthValue} = T
truthtype(a::AbstractAlgebra) = truthtype(typeof(a))</code></pre><p>The Julia type for representing truth values of the algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1489-L1496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W&lt;:AbstractWorld, A, T}" href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W&lt;:AbstractWorld, A, T}"><code>SoleLogics.truthtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truthtype(::Type{&lt;:AbstractKripkeStructure{W,A,T}}) where {W&lt;:AbstractWorld,A,T&lt;:TruthValue} = T
truthtype(a::AbstractKripkeStructure) = truthtype(typeof(a))</code></pre><p>The truth type of the model.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L556-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld" href="#SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld"><code>SoleLogics.worldtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">worldtype(::Type{&lt;:AbstractFrame{W}}) where {W&lt;:AbstractWorld} = W
worldtype(fr::AbstractFrame) = worldtype(typeof(fr))</code></pre><p>Return the world type of the frame.</p><p>See also <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W&lt;:AbstractWorld, A, T}" href="#SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractKripkeStructure{W, A, T, FR} where FR&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{T}, Tuple{A}, Tuple{W}} where {W&lt;:AbstractWorld, A, T}"><code>SoleLogics.worldtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">worldtype(::Type{&lt;:AbstractKripkeStructure{W,A,T}}) where {W&lt;:AbstractWorld,A,T&lt;:TruthValue} = W
worldtype(a::AbstractKripkeStructure) = worldtype(typeof(a))</code></pre><p>The world type of the model.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/modal-logic.jl#L567-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample-Tuple{SoleLogics.AbstractGrammar, Vararg{Any}}" href="#StatsBase.sample-Tuple{SoleLogics.AbstractGrammar, Vararg{Any}}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function StatsBase.sample(
    [rng::AbstractRNG = Random.GLOBAL_RNG, ]
    g::AbstractGrammar,
    height::Integer,
    args...;
    kwargs...
)::AbstractFormula</code></pre><p>Randomly sample a logic formula of given <code>height</code> from a grammar <code>g</code>.</p><p><strong>Implementation</strong></p><p>This method for must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.</p><p>See also <a href="@ref">`AbstractAlphabet&#39;</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/random.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.@atoms-Tuple" href="#SoleLogics.@atoms-Tuple"><code>SoleLogics.@atoms</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@atoms(cast, ps...)</p><p>Instantiate a collection of <a href="#SoleLogics.Atom"><code>Atom</code></a>s and return them as a vector.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Atoms instantiated with this macro are defined in the global scope as constants.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.@atoms String p q r s
4-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)
 Atom{String}(&quot;r&quot;)
 Atom{String}(&quot;s&quot;)

julia&gt; p
Atom{String}(&quot;p&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L208-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.@synexpr-Tuple{Any}" href="#SoleLogics.@synexpr-Tuple{Any}"><code>SoleLogics.@synexpr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@synexpr(expression)</code></pre><p>Return an expression after automatically instantiating undefined <a href="#SoleLogics.Atom"><code>Atom</code></a>s.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"></div></div><p>Every identified atom is of type <code>Atom{String}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @synexpr x = p # Atom{String}(&quot;p&quot;) is assigned to the global variable x
Atom{String}(&quot;p&quot;)

julia&gt; @synexpr st = p ∧ q → r
(p ∧ q) → r

julia&gt; typeof(st)
SyntaxTree{SoleLogics.NamedOperator{:→}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L245-L264">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modal-logic/">« Modal logic</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 10 October 2023 15:20">Tuesday 10 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
