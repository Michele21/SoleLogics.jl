<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Logics and Propositional Logic · SoleLogics.jl</title><meta name="title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta property="og:title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta property="twitter:title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Introduction to Logics and Propositional Logic</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#alphabets"><span>Alphabet</span></a></li><li class="toplevel"><a class="tocitem" href="#grammars"><span>Grammar</span></a></li><li class="toplevel"><a class="tocitem" href="#algebra"><span>Algebra</span></a></li><li class="toplevel"><a class="tocitem" href="#logic"><span>Logic</span></a></li><li class="toplevel"><a class="tocitem" href="#more-about-connectives"><span>More about Connectives</span></a></li><li><a class="tocitem" href="#boolean-algebra"><span>Boolean logic</span></a></li></ul></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li><a class="tocitem" href="../wip/">Work in progress</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction to Logics and Propositional Logic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Logics and Propositional Logic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/base-logic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#base-logic-introduction">Introduction</a></li><li><a href="#alphabets">Alphabet</a></li><li><a href="#grammars">Grammar</a></li><li><a href="#algebra">Algebra</a></li><li><a href="#logic">Logic</a></li><li><a href="#more-about-connectives">More about Connectives</a></li><li class="no-marker"><ul><li><a href="#boolean-algebra">Boolean logic</a></li></ul></li></ul><h1 id="base-logic-introduction"><a class="docs-heading-anchor" href="#base-logic-introduction">Introduction</a><a id="base-logic-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#base-logic-introduction" title="Permalink"></a></h1><p>At the end of this chapter, you are going to understand how <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>s and <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a> values are organized in alphabets, and how grammars are defined. </p><p>You will also get an in-depth view of how boolean truth values and boolean <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>&#39;s are defined from both a syntax and a syntactical standpoint of view.</p><p>The end of this chapter is dedicated to modal logic, which is one of the most hot topics covered by SoleLogics.</p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a><ul><li><a href="#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a> (new)<ul><li><a href="⊤"><code>Top</code></a></li><li><a href="⊥"><code>Bot</code></a></li></ul></li></ul></li></ul><hr/><ul><li><a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a><ul><li><a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a> (new)<ul><li><a href="#SoleLogics.NEGATION"><code>NEGATION</code></a></li><li><a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a> </li><li><a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a></li><li><a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a></li><li><a href="../modal-logic/#SoleLogics.DIAMOND"><code>DIAMOND</code></a></li><li><a href="../modal-logic/#SoleLogics.BOX"><code>BOX</code></a></li></ul></li></ul></li></ul><hr/><ul><li><a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet{V}</code></a> (new)<ul><li><a href="#SoleLogics.ExplicitAlphabet"><code>ExplicitAlphabet{V}</code></a></li><li><a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny{V}</code></a></li></ul></li></ul><hr/><ul><li><a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator}</code></a> (new)<ul><li><a href="#SoleLogics.CompleteFlatGrammar"><code>CompleteFlatGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator}</code></a></li></ul></li></ul><hr/><ul><li><a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra{T&lt;:Truth}</code></a> (new)<ul><li><a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a></li></ul></li></ul><hr/><ul><li><a href="#SoleLogics.AbstractLogic"><code>AbstractLogic{G&lt;:AbstractGrammar,V&lt;:AbstractAlgebra}</code></a> (new)<ul><li>[<code>BaseLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra}</code>]</li></ul></li></ul><h1 id="alphabets"><a class="docs-heading-anchor" href="#alphabets">Alphabet</a><a id="alphabets-1"></a><a class="docs-heading-anchor-permalink" href="#alphabets" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractAlphabet" href="#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlphabet{V} end</code></pre><p>Abstract type for representing an alphabet of atoms with values of type <code>V</code>. An alphabet (or <em>propositional alphabet</em>) is a set of atoms (assumed to be <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Atom(1) in ExplicitAlphabet(Atom.(1:10))
true

julia&gt; Atom(1) in ExplicitAlphabet(1:10)
true

julia&gt; Atom(1) in AlphabetOfAny{String}()
false

julia&gt; Atom(&quot;mystring&quot;) in AlphabetOfAny{String}()
true

julia&gt; &quot;mystring&quot; in AlphabetOfAny{String}()
┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})
└ @ SoleLogics ...
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new alphabet type <code>MyAlphabet</code>, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:</p><pre><code class="nohighlight hljs">function Base.in(p::Atom, a::MyAlphabet)::Bool</code></pre><p>in the case of <em>finite</em> alphabets, it suffices to define a method:</p><pre><code class="nohighlight hljs">function atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>By default, an alphabet is considered finite:</p><pre><code class="nohighlight hljs">Base.isfinite(::Type{&lt;:AbstractAlphabet}) = true
Base.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))
Base.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)</code></pre><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>, <a href="#SoleLogics.ExplicitAlphabet"><code>ExplicitAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L8-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isfinite-Tuple{Type{&lt;:SoleLogics.AbstractAlphabet}}" href="#Base.isfinite-Tuple{Type{&lt;:SoleLogics.AbstractAlphabet}}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.isfinite(a::AbstractAlphabet)</code></pre><p>Return <code>true</code> if the alphabet is finite, <code>false</code> otherwise.</p><p>See <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}" href="#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>SoleLogics.atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>List the atoms of a <em>finite</em> alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}" href="#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(p::Atom, a::AbstractAlphabet)::Bool</code></pre><p>Return whether an atom belongs to an alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{SoleLogics.AbstractAlphabet}" href="#Base.length-Tuple{SoleLogics.AbstractAlphabet}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.length(a::AbstractAlphabet)::Bool</code></pre><p>Return the alphabet length, if it is finite.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{SoleLogics.AbstractAlphabet}" href="#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(a::AbstractAlphabet)
Base.iterate(a::AbstractAlphabet, state)</code></pre><p>Return an iterator to the next element in an alhabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L134-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ExplicitAlphabet" href="#SoleLogics.ExplicitAlphabet"><code>SoleLogics.ExplicitAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitAlphabet{V} &lt;: AbstractAlphabet{V}
    atoms::Vector{Atom{V}}
end</code></pre><p>An alphabet wrapping atoms in a (finite) <code>Vector</code>.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>atoms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AlphabetOfAny" href="#SoleLogics.AlphabetOfAny"><code>SoleLogics.AlphabetOfAny</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AlphabetOfAny{V} &lt;: AbstractAlphabet{V} end</code></pre><p>An implicit, infinite alphabet that includes all atoms with values of a subtype of V.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L199-L205">source</a></section></article><h1 id="grammars"><a class="docs-heading-anchor" href="#grammars">Grammar</a><a id="grammars-1"></a><a class="docs-heading-anchor-permalink" href="#grammars" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractGrammar" href="#SoleLogics.AbstractGrammar"><code>SoleLogics.AbstractGrammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator} end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a> based on a <em>single</em> alphabet of type <code>V</code>, and a set of operators that consists of all the (singleton) child types of <code>O</code>. V context-free grammar is a simple structure for defining formulas inductively.</p><p>See also <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L214-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}" href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>SoleLogics.alphabet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alphabet(g::AbstractGrammar{V} where {V})::V</code></pre><p>Return the propositional alphabet of a grammar.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L231-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}" href="#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool</code></pre><p>Return whether a <code>SyntaxTree</code>, belongs to a grammar.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}" href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::AbstractGrammar;
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing,
    args...
)::Vector{&lt;:SyntaxBranch}</code></pre><p>Enumerate the formulas produced by a given grammar with a finite and iterable alphabet.</p><p><strong>Implementation</strong></p><p>Additional <code>args</code> can be used to model the function&#39;s behavior. At least these two arguments should be covered:</p><ul><li>a <code>nformulas</code> argument can be used to limit the size of the returned <code>Vector</code>;</li><li>a <code>maxdepth</code> argument can be used to limit the syntactic component, represented as a syntax tree,</li></ul><p>to a given maximum depth;</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L265-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CompleteFlatGrammar" href="#SoleLogics.CompleteFlatGrammar"><code>SoleLogics.CompleteFlatGrammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CompleteFlatGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator} &lt;: AbstractGrammar{V,O}
    alphabet::V
    operators::Vector{&lt;:O}
end</code></pre><p>V grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type <code>V</code>, and all operators in <code>operators</code>. With n operators, this grammar has exactly n+1 production rules. For example, with <code>operators = [∧,∨]</code>, the grammar (in Backus-Naur form) is:</p><pre><code class="nohighlight hljs">φ ::= p | φ ∧ φ | φ ∨ φ</code></pre><p>with p ∈ alphabet. Note: it is <em>flat</em> in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>formulas</code></a>, <a href="#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}"><code>connectives</code></a>, <a href="@ref"><code>operators</code></a>, <a href="#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}"><code>leaves</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L312-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}" href="#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.connectives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectives(g::AbstractGrammar)</code></pre><p>List all connectives appearing in a grammar.</p><p>See also <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="@ref"><code>nconnectives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L366-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}" href="#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leaves(g::AbstractGrammar)</code></pre><p>List all leaves appearing in a grammar.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="@ref"><code>nleaves</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}" href="#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::CompleteFlatGrammar{V,O} where {V,O};
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing
)::Vector{SyntaxBranch}</code></pre><p>Generate all formulas whose <code>SyntaxBranch</code>s that are not taller than a given <code>maxdepth</code>.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L404-L414">source</a></section></article><h1 id="algebra"><a class="docs-heading-anchor" href="#algebra">Algebra</a><a id="algebra-1"></a><a class="docs-heading-anchor-permalink" href="#algebra" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractAlgebra" href="#SoleLogics.AbstractAlgebra"><code>SoleLogics.AbstractAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlgebra{T&lt;:Truth} end</code></pre><p>Abstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> where two elements(or nodes) <em>⊤</em> and <em>⊥</em> are referred to as <em>TOP</em> (or maximum) and <em>bot</em> (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.</p><p><strong>Implementation</strong></p><p>When implementing a new algebra type, the methods <code>domain</code>, <code>TOP</code>, and <code>bot</code> should be implemented.</p><p>See also <a href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>bot</code></a>, <a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="@ref"><code>TOP</code></a>, <a href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N"><code>collatetruth</code></a>, <a href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>domain</code></a>, <a href="#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><code>iscrisp</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>truthtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L458-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth" href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>SoleLogics.truthtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truthtype(::Type{&lt;:AbstractAlgebra{T}}) where {T&lt;:Truth} = T
truthtype(a::AbstractAlgebra) = truthtype(typeof(a))</code></pre><p>The Julia type for representing truth values of the algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L479-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domain(a::AbstractAlgebra)</code></pre><p>Return an iterator to the values in the <code>domain</code> of a given algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L490-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}" href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}"><code>SoleLogics.top</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">top(a::AbstractAlgebra)</code></pre><p>Return the top of a given algebra.</p><p>See also <a href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>bot</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L504-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.bot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bot(a::AbstractAlgebra)</code></pre><p>Return the bottom of a given algebra.</p><p>See also <a href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}"><code>top</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L515-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}" href="#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.iscrisp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))</code></pre><p>An algebra is crisp (or <em>boolean</em>) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is <em>fuzzy</em>.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L526-L533">source</a></section></article><h1 id="logic"><a class="docs-heading-anchor" href="#logic">Logic</a><a id="logic-1"></a><a class="docs-heading-anchor-permalink" href="#logic" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractLogic" href="#SoleLogics.AbstractLogic"><code>SoleLogics.AbstractLogic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLogic{G&lt;:AbstractGrammar,V&lt;:AbstractAlgebra} end</code></pre><p>Abstract type of a logic, which comprehends a context-free grammar (<em>syntax</em>) and an algebra (<em>semantics</em>).</p><p><strong>Implementation</strong></p><p>When implementing a new logic type, the methods <code>grammar</code> and <code>algebra</code> should be implemented.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L540-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar" href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>SoleLogics.grammar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grammar(l::AbstractLogic{G})::G where {G&lt;:AbstractGrammar}</code></pre><p>Return the <code>grammar</code> of a given logic.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>, <a href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}"><code>algebra</code></a>, <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>formulas</code></a>, <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>grammar</code></a>, <a href="@ref"><code>operators</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>truthtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L555-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}" href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}"><code>SoleLogics.algebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">algebra(l::AbstractLogic{G,V})::V where {G,V}</code></pre><p>Return the <code>algebra</code> of a given logic.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/logics.jl#L580-L586">source</a></section></article><h1 id="more-about-connectives"><a class="docs-heading-anchor" href="#more-about-connectives">More about Connectives</a><a id="more-about-connectives-1"></a><a class="docs-heading-anchor-permalink" href="#more-about-connectives" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.NamedConnective" href="#SoleLogics.NamedConnective"><code>SoleLogics.NamedConnective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NamedConnective{Symbol} &lt;: Connective end</code></pre><p>A singleton type for representing connectives defined by a name or a symbol.</p><p><strong>Examples</strong></p><p>The AND connective (i.e., the logical conjunction) is defined as the subtype:</p><pre><code class="nohighlight hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>See also <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>, <a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N" href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N"><code>SoleLogics.collatetruth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collatetruth(c::Connective, ts::NTuple{N,T where T&lt;:Truth})::Truth where {N}</code></pre><p>Return the truth value for a composed formula <code>c(t1, ..., tN)</code>, given the <code>N</code> with t1, ..., tN being <code>Truth</code> values.</p><p>See also <a href="#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N"><code>simplify</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N" href="#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N"><code>SoleLogics.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(c::Connective, ts::NTuple{N,F where F&lt;:Formula})::Truth where {N}</code></pre><p>Return a formula with the same semantics of a composed formula <code>c(φ1, ..., φN)</code>, given the <code>N</code> immediate sub-formulas.</p><p>See also <a href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N"><code>collatetruth</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L29-L37">source</a></section></article><h2 id="boolean-algebra"><a class="docs-heading-anchor" href="#boolean-algebra">Boolean logic</a><a id="boolean-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#boolean-algebra" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.NEGATION" href="#SoleLogics.NEGATION"><code>SoleLogics.NEGATION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const NEGATION = NamedConnective{:¬}()
const ¬ = NEGATION
arity(::typeof(¬)) = 1</code></pre><p>Logical negation (also referred to as complement). It can be typed by <code>\neg&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CONJUNCTION" href="#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DISJUNCTION" href="#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedConnective{:∨}()
const ∨ = DISJUNCTION
arity(::typeof(∨)) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.IMPLICATION" href="#SoleLogics.IMPLICATION"><code>SoleLogics.IMPLICATION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const IMPLICATION = NamedConnective{:→}()
const → = IMPLICATION
arity(::typeof(→)) = 2</code></pre><p>Logical implication. It can be typed by <code>\to&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L157-L166">source</a></section></article><p>Boolean logic <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are regrouped in a single collection.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BASE_CONNECTIVES" href="#SoleLogics.BASE_CONNECTIVES"><code>SoleLogics.BASE_CONNECTIVES</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const BASE_CONNECTIVES = [¬, ∧, ∨, →]</code></pre><p>Basic logical operators.</p><p>See also <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>, <a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L401-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BooleanTruth" href="#SoleLogics.BooleanTruth"><code>SoleLogics.BooleanTruth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type BooleanTruth &lt;: Truth end</code></pre><p>Supertype of <code>Top</code> and <code>Bot</code>, the two truth values of <code>BooleanAlgebra</code></p><p>See also <a href="#SoleLogics.Bot"><code>Bot</code></a>, <a href="#SoleLogics.Top"><code>Top</code></a>, <a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Top" href="#SoleLogics.Top"><code>SoleLogics.Top</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Top &lt;: Truth end
const TOP = Top()
const ⊤ = TOP</code></pre><p>Canonical truth operator representing the value <code>true</code>. It can be typed by <code>\top&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>BOT</code></a>, <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L199-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Bot" href="#SoleLogics.Bot"><code>SoleLogics.Bot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Bot &lt;: Truth end
const BOT = Bot()
const ⊥ = BOT</code></pre><p>Canonical truth operator representing the value <code>false</code>. It can be typed by <code>\bot&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>TOP</code></a>, <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BooleanAlgebra" href="#SoleLogics.BooleanAlgebra"><code>SoleLogics.BooleanAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BooleanAlgebra &lt;: AbstractAlgebra{Bool} end</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Boolean_algebra">Boolean algebra</a>, defined on the values Top (representing <code>true</code>) and Bot (for bottom, representing <code>false</code>). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of <code>true</code> and <code>false</code>, respectively.</p><p>See also <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BaseLogic" href="#SoleLogics.BaseLogic"><code>SoleLogics.BaseLogic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BaseLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra} &lt;: AbstractLogic{G,A}
    grammar::G
    algebra::A
end</code></pre><p>A basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.</p><p>See also <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>grammar</code></a>, <a href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}"><code>algebra</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/bf80baa7625aa1505f85d0c7644b9258bccdd63d/src/base-logic.jl#L337-L348">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting started</a><a class="docs-footer-nextpage" href="../modal-logic/">Modal Logic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 14 November 2023 06:27">Tuesday 14 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
