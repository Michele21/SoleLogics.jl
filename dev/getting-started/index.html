<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SoleLogics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/getting-started/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#syntactical-base-definitions"><span>Syntax Basics</span></a></li><li><a class="tocitem" href="#Semantics"><span>Semantics</span></a></li><li><a class="tocitem" href="#customization-section"><span>Customization</span></a></li></ul></li><li><a class="tocitem" href="../propositional-logic/">Propositional logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal logic</a></li><li><a class="tocitem" href="../autodocs/">Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/getting-started.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-core"><a class="docs-heading-anchor" href="#man-core">Getting started</a><a id="man-core-1"></a><a class="docs-heading-anchor-permalink" href="#man-core" title="Permalink"></a></h1><h2 id="syntactical-base-definitions"><a class="docs-heading-anchor" href="#syntactical-base-definitions">Syntax Basics</a><a id="syntactical-base-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#syntactical-base-definitions" title="Permalink"></a></h2><p>Logical formulas are synctactical objects representing statements which level of truth can be assessed. Formulas arise from formal grammars (e.g., context-free grammars), and are most commonly represented as syntax trees. At the leaf nodes of a syntax tree are atoms (simple, atomic statements) or truth values (e.g., ⊤, representing truth), while at the internal nodes are logical connectives that allow for the composition of formulas to represent complex concepts.</p><p>In SoleLogics, an Atom is a wrapper for any value (accessible via the <code>value</code> method).</p><p>arity</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Atom</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>TruthValue</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractOperator</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SyntaxTree</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Let&#39;s review these concepts with a simple example.</p><pre><code class="language-julia-repl hljs">julia&gt; p = Atom(&quot;p&quot;)
Atom{String}(&quot;p&quot;)

julia&gt; q = Atom(&quot;q&quot;)
Atom{String}(&quot;q&quot;)

julia&gt; value(p)
&quot;p&quot;

# Operators are syntax tokens too
julia&gt; CONJUNCTION
∧

# SyntaxTree&#39;s are arity-compliant
julia&gt; st = SyntaxTree(CONJUNCTION, p)
ERROR: AssertionError: Cannot instantiate SyntaxTree{SoleLogics.NamedOperator{:∧}} 
with token ∧ of arity 2 and 1 children.

# In fact, the conjunction operator in a syntax tree must have exactly 2 children 
julia&gt; arity(CONJUNCTION)
2

julia&gt; stree = SyntaxTree(CONJUNCTION, (p,q))
SyntaxTree: p ∧ q

# Get the token of the root node
julia&gt; token(st)
∧

# Get the first subtree, containing only an atom
julia&gt; leftree = children(st)[1]; 
SyntaxTree: p

julia&gt; typeof(leftree)
SyntaxTree{Atom{String}}

# Atoms are necessarily at the leaves; in fact their arity is 0
julia&gt; leftree |&gt; token |&gt; arity
0</code></pre><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractSyntaxStructure</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractSyntaxToken</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.arity-Tuple{Type{&lt;:AbstractSyntaxToken}}" href="#SoleLogics.arity-Tuple{Type{&lt;:AbstractSyntaxToken}}"><code>SoleLogics.arity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arity(::Type{&lt;:AbstractSyntaxToken})::Integer
arity(tok::AbstractSyntaxToken)::Integer = arity(typeof(tok))</code></pre><p>Return the <code>arity</code> of a syntax token. The arity of a syntax token is an integer representing the number of allowed children in a <code>SyntaxTree</code>. Tokens with <code>arity</code> equal to 0, 1 or 2 are called <code>nullary</code>, <code>unary</code> and <code>binary</code>, respectively.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L18-L27">source</a></section></article><h3 id="Connectives"><a class="docs-heading-anchor" href="#Connectives">Connectives</a><a id="Connectives-1"></a><a class="docs-heading-anchor-permalink" href="#Connectives" title="Permalink"></a></h3><p>TODO</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.AbstractOperator</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement custom operators. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.NamedOperator</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.operator_precedence(op::AbstractOperator)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.isrightassociative" href="#SoleLogics.isrightassociative"><code>SoleLogics.isrightassociative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isrightassociative(::Type{AbstractOperator})
isrightassociative(o::AbstractOperator) = isrightassociative(typeof(o))</code></pre><p>Return whether an <code>AbstractOperator</code> is right associative or no.</p><p>Associativity establishes how operators of the same precedence are grouped in the absence of the parentheses.</p><p>Conjunction and disjunction are commutative operators, thus, the left associativity case &quot;(p ∧ q) ∧ r&quot; and the right associativity case &quot;p ∧ (q ∧ r)&quot; are equivalent; by convention we consider the latter form. Implication is right associative, meaning that &quot;p → q → r&quot; is grouped as &quot;p → (q → r)&quot;.</p><p>By default, an operator is right associative.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isrightassociative(∧)
true

julia&gt; isrightassociative(→)
true</code></pre><p>See also <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L406-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.iscommutative" href="#SoleLogics.iscommutative"><code>SoleLogics.iscommutative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscommutative(::Type{AbstractOperator})
iscommutative(o::AbstractOperator) = iscommutative(typeof(o))</code></pre><p>Return whether an operator is known to be commutative.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iscommutative(∧)
true

julia&gt; iscommutative(→)
false</code></pre><p>Note that nullary and unary operators are considered commutative.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p><p><strong>Implementation</strong></p><p>When implementing a new type for a <em>commutative</em> operator <code>O</code> with arity higher than 1, please provide a method <code>iscommutative(::Type{O})</code>. This can help model checking operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L329-L352">source</a></section></article><p>To learn more about operators, refer to <a href="@ref">Propositional Logic</a> and <a href="@ref">Modal Logic</a> chapters.</p><h3 id="Formulas"><a class="docs-heading-anchor" href="#Formulas">Formulas</a><a id="Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Formulas" title="Permalink"></a></h3><p>TODO: the following definition might be unclear, since &quot;evaluation&quot; and &quot;logic&quot; are not concepts already read by the user. When the Logic structure will be removed from SoleLogics, this section will be expanded with semantics-related concepts.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractFormula</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement a custom <a href="../autodocs/#SoleLogics.Formula"><code>Formula</code></a> type. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.joinformulas" href="#SoleLogics.joinformulas"><code>SoleLogics.joinformulas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">joinformulas(
    op::AbstractOperator,
    ::NTuple{N,F}
)::F where {N,F&lt;:AbstractFormula}</code></pre><p>Return a new formula of type <code>F</code> by composing <code>N</code> formulas of the same type via an operator <code>op</code>. This function allows one to use operators for flexibly composing formulas (see <em>Implementation</em>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;◊(p→q)&quot;);

julia&gt; p = Atom(&quot;p&quot;);

julia&gt; ∧(f, p)  # Easy way to compose a formula
SyntaxTree: ◊(p → q) ∧ p

julia&gt; f ∧ ¬p   # Leverage infix notation ;)
SyntaxTree: ◊(p → q) ∧ ¬p

julia&gt; ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))
SyntaxTree: ◊(p → q) ∧ p ∧ ¬p</code></pre><p><strong>Implementation</strong></p><p>Upon <code>joinformulas</code> lies a flexible way of using operators for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:</p><pre><code class="nohighlight hljs">function (op::AbstractOperator)(
    children::NTuple{N,Union{AbstractSyntaxToken,AbstractFormula}},
) where {N}
    ...
end</code></pre><p>These allow composing formulas as in <code>∧(f, ¬p)</code>, and in order to access this composition with any newly defined subtype of <code>AbstractFormula</code>, a new method for <code>joinformulas</code> should be defined, together with promotion from/to other <code>AbstractFormula</code>s should be taken care of (see <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">here</a> and <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">here</a>).</p><p>Similarly, for allowing a (possibly newly defined) operator to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined operator <code>op</code>, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as <code>∧(f, f2, f3, ...)</code> and <code>∨(f, f2, f3, ...)</code> can be done thanks to the following two methods that were defined in SoleLogics:</p><pre><code class="nohighlight hljs">function ∧(
    c1::Union{AbstractSyntaxToken,AbstractFormula},
    c2::Union{AbstractSyntaxToken,AbstractFormula},
    c3::Union{AbstractSyntaxToken,AbstractFormula},
    cs::Union{AbstractSyntaxToken,AbstractFormula}...
)
    return ∧(c1, ∧(c2, c3, cs...))
end
function ∨(
    c1::Union{AbstractSyntaxToken,AbstractFormula},
    c2::Union{AbstractSyntaxToken,AbstractFormula},
    c3::Union{AbstractSyntaxToken,AbstractFormula},
    cs::Union{AbstractSyntaxToken,AbstractFormula}...
)
    return ∨(c1, ∨(c2, c3, cs...))
end</code></pre><p>See also <a href="../autodocs/#SoleLogics.AbstractFormula"><code>AbstractFormula</code></a>, <a href="../autodocs/#SoleLogics.AbstractOperator"><code>AbstractOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L470-L543">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>tokens(f::AbstractFormula)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.height(t::SyntaxTree)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.tree(f::AbstractFormula)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Parsing-and-Printing"><a class="docs-heading-anchor" href="#Parsing-and-Printing">Parsing &amp; Printing</a><a id="Parsing-and-Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-and-Printing" title="Permalink"></a></h3><p>SoleLogics.jl allows you to: </p><ul><li>Extract the string representation of a formula (via <code>syntaxstring</code>);</li><li>Parse formulas from strings (via <code>parsetree</code>).</li></ul><p>These features are highly customizable, and leverage three properties of syntactical tokens: <a href="../autodocs/#SoleLogics.arity-Tuple{Type{&lt;:AbstractRelation}}"><code>arity</code></a>, operator precedence (<a href="@ref"><code>operator_precedence</code></a>) and operator associativity (<a href="#SoleLogics.isrightassociative"><code>isrightassociative</code></a>).</p><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.syntaxstring" href="#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">syntaxstring(φ::AbstractFormula; kwargs...)::String
syntaxstring(tok::AbstractSyntaxToken; kwargs...)::String</code></pre><p>Produce the string representation of a formula or syntax token by performing a tree traversal of the syntax tree representation of the formula. Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leafs of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(p, ∧(q, ∧(r, ∧(s, t))))&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;(p) ∧ ((q) ∧ ((r) ∧ ((s) ∧ (t))))&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parsebaseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="../autodocs/#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>parsebaseformula</code></a>, <a href="#SoleLogics.parsetree"><code>parsetree</code></a>, <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="../autodocs/#SoleLogics.AbstractSyntaxToken"><code>AbstractSyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including <code>kwargs...</code>) for every newly defined <code>AbstractSyntaxToken</code> (e.g., operators and <code>Atom</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(p::Atom; kwargs...) = syntaxstring(value(p); kwargs...)</code></pre><p>Then, the syntaxstring for a given value can be defined. For example, with <code>String</code> (or <code>Number</code>) values, it defaults to:</p><pre><code class="nohighlight hljs">syntaxstring(value::String; kwargs...) = value</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>). See also <a href="../autodocs/#SoleLogics.parsebaseformula-Tuple{Any, Vararg{Any}}"><code>parsebaseformula</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L66-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.parsetree" href="#SoleLogics.parsetree"><code>SoleLogics.parsetree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parsetree(
    expression::String,
    additional_operators::Union{Nothing,Vector{&lt;:AbstractOperator}} = nothing;
    function_notation::Bool = false,
    atom_parser::Base.Callable = Atom{String},
    additional_whitespaces::Vector{Char} = Char[],
    opening_parenthesis::String = &quot;(&quot;,
    closing_parenthesis::String = &quot;)&quot;,
    arg_delim::String = &quot;,&quot;
)</code></pre><p>Return a <code>SyntaxTree</code> which is the result of parsing <code>expression</code>  via the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a>  algorithm. By default, this function is only able to parse operators in <code>SoleLogics.BASE_PARSABLE_OPERATORS</code> (see arguments section); additional operators may be provided as a second argument.</p><p><strong>Arguments</strong></p><ul><li><code>expression::String</code>: expression to be parsed;</li><li><code>additional_operators::Vector{&lt;:AbstractOperator}</code>: additional, non-standard operators   needed to correctly parse the expression.   When left unset, only the operators in <code>SoleLogics.BASE_PARSABLE_OPERATORS</code> are   correctly parsed: S, o, l, e, L, o, g, i, c, s, ., A, b, s, t, r, a, c, t, O, p, e, r, a, t, o, r, [, ⊤, ,,  , ⊥, ,,  , ¬, ,,  , ∧, ,,  , ∨, ,,  , →, ,,  , ◊, ,,  , □, ,,  , ⟨, G, ⟩, ,,  , [, G, ], ,,  , ⟨, =, ⟩, ,,  , [, =, ], ];   note that, in case of clashing <code>syntaxstring</code>&#39;s,   the provided additional operators will override these.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g, <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g, <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces</code>::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis</code>::String = &quot;(&quot;:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis</code>::String = &quot;)&quot;:   the string signaling the closing of an expression block;</li><li><code>arg_delim</code>::String = &quot;,&quot;:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parsetree(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parsetree(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parsetree(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><p>See also <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, [].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/parse.jl#L290-L359">source</a></section></article><h3 id="Grammar"><a class="docs-heading-anchor" href="#Grammar">Grammar</a><a id="Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Grammar" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractAlphabet</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement a custom <a href="../autodocs/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> concrete type. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>atoms(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.in(p::Atom, a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.length(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.iterate(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ExplicitAlphabet</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphabetOfAny</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractGrammar</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>alphabet(g::AbstractGrammar{A} where {A})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.in(t::SyntaxTree, g::AbstractGrammar)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}" href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::AbstractGrammar;
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing,
    args...
)::Vector{&lt;:SyntaxTree}</code></pre><p>Enumerate the formulas produced by a given grammar with a finite and iterable alphabet.</p><p><strong>Implementation</strong></p><p>Additional <code>args</code> can be used to model the function&#39;s behavior. At least these two arguments should be covered:</p><ul><li>a <code>nformulas</code> argument can be used to limit the size of the returned <code>Vector</code>;</li><li>a <code>maxdepth</code> argument can be used to limit the syntactic component, represented as a syntax tree,</li></ul><p>to a given maximum depth;</p><p>See also <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/a5f0cc3bad8f9784fd527724d7d76101ab3aa653/src/core.jl#L1177-L1196">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CompleteFlatGrammar{A&lt;:AbstractAlphabet,O&lt;:AbstractOperator}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>formulas(g::CompleteFlatGrammar{A,O} where {A,O}; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Semantics"><a class="docs-heading-anchor" href="#Semantics">Semantics</a><a id="Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Semantics" title="Permalink"></a></h2><h2 id="customization-section"><a class="docs-heading-anchor" href="#customization-section">Customization</a><a id="customization-section-1"></a><a class="docs-heading-anchor-permalink" href="#customization-section" title="Permalink"></a></h2><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc justo justo, finibus ac odio in, tempor fermentum augue. Vivamus ullamcorper lacus eget enim imperdiet, ac lobortis turpis elementum. Fusce non auctor eros. Duis scelerisque auctor volutpat. Morbi non luctus est. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Pellentesque porttitor a est sit amet ornare. Aliquam faucibus fringilla imperdiet.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../propositional-logic/">Propositional logic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 10 October 2023 15:20">Tuesday 10 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
