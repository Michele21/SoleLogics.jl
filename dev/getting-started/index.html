<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SoleLogics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/getting-started/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#syntactical-base-definitions"><span>Syntax Basics</span></a></li><li><a class="tocitem" href="#Semantics"><span>Semantics</span></a></li><li><a class="tocitem" href="#customization-section"><span>Customization</span></a></li></ul></li><li><a class="tocitem" href="../propositional-logic/">Propositional logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal logic</a></li><li><a class="tocitem" href="../autodocs/">Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/getting-started.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-core"><a class="docs-heading-anchor" href="#man-core">Getting started</a><a id="man-core-1"></a><a class="docs-heading-anchor-permalink" href="#man-core" title="Permalink"></a></h1><h2 id="syntactical-base-definitions"><a class="docs-heading-anchor" href="#syntactical-base-definitions">Syntax Basics</a><a id="syntactical-base-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#syntactical-base-definitions" title="Permalink"></a></h2><p>Logical formulas are syntactical objects representing statements which level of truth can be assessed. Formulas arise from formal grammars (e.g., context-free grammars), and are most commonly represented as syntax trees. At the leaf nodes of a syntax tree are atoms (simple, atomic statements) or truth values (e.g., ⊤, representing truth), while at the internal nodes are logical connectives that allow for the composition of formulas to represent complex concepts.</p><p>In SoleLogics, an Atom is a wrapper for any value (accessible via the <code>value</code> method). TODO arity</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Atom</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Truth</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Connective</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SyntaxBranch</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Let&#39;s review these concepts with a simple example.</p><pre><code class="language-julia-repl hljs">julia&gt; p = Atom(&quot;p&quot;)
Atom{String}(&quot;p&quot;)

julia&gt; q = Atom(&quot;q&quot;)
Atom{String}(&quot;q&quot;)

julia&gt; value(p)
&quot;p&quot;

# Operators are syntax tokens too
julia&gt; CONJUNCTION
∧

# SyntaxBranch&#39;s are arity-compliant
julia&gt; st = SyntaxBranch(CONJUNCTION, p)
ERROR: AssertionError: Cannot instantiate SyntaxBranch{SoleLogics.NamedConnective{:∧}} 
with token ∧ of arity 2 and 1 children.

# In fact, the conjunction operator in a syntax tree must have exactly 2 children 
julia&gt; arity(CONJUNCTION)
2

julia&gt; stree = SyntaxBranch(CONJUNCTION, (p,q))
SyntaxBranch: p ∧ q

# Get the token of the root node
julia&gt; token(st)
∧

# Get the first subtree, containing only an atom
julia&gt; leftree = children(st)[1]; 
SyntaxBranch: p

julia&gt; typeof(leftree)
SyntaxBranch{Atom{String}}

# Atoms are necessarily at the leaves; in fact their arity is 0
julia&gt; leftree |&gt; token |&gt; arity
0</code></pre><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractSyntaxStructure</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SyntaxToken</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.arity(::SyntaxToken)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Connectives"><a class="docs-heading-anchor" href="#Connectives">Connectives</a><a id="Connectives-1"></a><a class="docs-heading-anchor-permalink" href="#Connectives" title="Permalink"></a></h3><p>TODO</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.Connective</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement custom operators. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.NamedConnective</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.precedence" href="#SoleLogics.precedence"><code>SoleLogics.precedence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precedence(c::Connective)</code></pre><p>Return the precedence of a binary connective.</p><p>When using infix notation, and in the absence of parentheses, <code>precedence</code> establishes how binary connectives are interpreted. A precedence value is a standard integer, and connectives with high precedence take precedence over connectives with lower precedences. This affects how formulas are shown (via <code>syntaxstring</code>) and parsed (via <code>parseformula</code>).</p><p>By default, the value for a <code>NamedConnective</code> is derived from the <code>Base.operator_precedence</code> of its symbol (<code>name</code>); there are some exceptions (e.g., ¬). Because of this, when dealing with a custom connective <code>⊙</code>, it will be the case that <code>parseformula(&quot;p ⊙ q ∧ r&quot;) == (@synexpr p ⊙ q ∧ r)</code>.</p><p>It is possible to assign a specific precedence to a connective type <code>C</code> by providing a method <code>Base.operator_precedence(::C)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; precedence(∧) == Base.operator_precedence(:∧)
true

julia&gt; precedence(∧), precedence(∨), precedence(→)
∨(12, 11, 4)

julia&gt; syntaxstring(parseformula(&quot;¬a ∧ b ∧ c&quot;))
&quot;¬a ∧ b ∧ c&quot;

julia&gt; syntaxstring(parseformula(&quot;¬a → b ∧ c&quot;))
&quot;(¬a) → (b ∧ c)&quot;

julia&gt; syntaxstring(parseformula(&quot;a ∧ b → c ∧ d&quot;))
&quot;(a ∧ b) → (c ∧ d)&quot;</code></pre><p>See also <a href="#SoleLogics.associativity"><code>associativity</code></a>, <a href="../autodocs/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L121-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.associativity" href="#SoleLogics.associativity"><code>SoleLogics.associativity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">associativity(::Connective)</code></pre><p>Return whether a (binary) connective is right-associative.</p><p>When using infix notation, and in the absence of parentheses, <code>associativity establishes how binary connectives of the same</code>precedence<code>are interpreted. This affects how formulas are shown (via</code>syntaxstring<code>) and parsed (via</code>parseformula`).</p><p>By default, the value for a <code>NamedConnective</code> is derived from the <code>Base.operator_precedence</code> of its symbol (<code>name</code>); thus, for example, most connectives are left-associative (e.g., <code>∧</code> and <code>∨</code>), while <code>→</code> is right-associative. Because of this, when dealing with a custom connective <code>⊙</code>, it will be the case that <code>parseformula(&quot;p ⊙ q ∧ r&quot;) == (@synexpr p ⊙ q ∧ r)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; associativity(∧)
:left

julia&gt; associativity(→)
:right

julia&gt; syntaxstring(parseformula(&quot;p → q → r&quot;); remove_redundant_parentheses = false)
&quot;p → (q → r)&quot;

julia&gt; syntaxstring(parseformula(&quot;p ∧ q ∨ r&quot;); remove_redundant_parentheses = false)
&quot;(p ∧ q) ∨ r&quot;</code></pre><p>See also <a href="../autodocs/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.parseformula"><code>parseformula</code></a>, <a href="#SoleLogics.precedence"><code>precedence</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L126-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.iscommutative" href="#SoleLogics.iscommutative"><code>SoleLogics.iscommutative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscommutative(c::Connective)</code></pre><p>Return whether a connective is known to be commutative.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iscommutative(∧)
true

julia&gt; iscommutative(→)
false</code></pre><p>Note that nullary and unary connectives are considered commutative.</p><p>See also <a href="../autodocs/#SoleLogics.Connective"><code>Connective</code></a>.</p><p><strong>Implementation</strong></p><p>When implementing a new type for a <em>commutative</em> connective <code>C</code> with arity higher than 1, please provide a method <code>iscommutative(::C)</code>. This can help model checking operations.</p><p>See also <a href="../autodocs/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L116-L140">source</a></section></article><p>To learn more about operators, refer to <a href="@ref">Propositional Logic</a> and <a href="@ref">Modal Logic</a> chapters.</p><h3 id="Formulas"><a class="docs-heading-anchor" href="#Formulas">Formulas</a><a id="Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Formulas" title="Permalink"></a></h3><p>TODO: the following definition might be unclear, since &quot;evaluation&quot; and &quot;logic&quot; are not concepts already read by the user. When the Logic structure will be removed from SoleLogics, this section will be expanded with semantics-related concepts.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Formula</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement a custom <a href="../autodocs/#SoleLogics.Formula"><code>Formula</code></a> subtype. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.composeformulas" href="#SoleLogics.composeformulas"><code>SoleLogics.composeformulas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F&lt;:Formula}</code></pre><p>Return a new formula of type <code>F</code> by composing <code>N</code> formulas of the same type via a connective <code>c</code>. This function allows one to use connectives for flexibly composing formulas (see <em>Implementation</em> section).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;◊(p→q)&quot;);

julia&gt; p = Atom(&quot;p&quot;);

julia&gt; ∧(f, p)  # Easy way to compose a formula
SyntaxBranch: ◊(p → q) ∧ p

julia&gt; f ∧ ¬p   # Leverage infix notation ;) (see https://stackoverflow.com/a/60321302/5646732)
SyntaxBranch: ◊(p → q) ∧ ¬p

julia&gt; ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))
SyntaxBranch: ◊(p → q) ∧ p ∧ ¬p</code></pre><p><strong>Implementation</strong></p><p>Upon <code>composeformulas</code> lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:</p><pre><code class="nohighlight hljs">function (c::Connective)(φs::NTuple{N,Formula}) where {N}
    ...
end</code></pre><p>These allow composing formulas as in <code>∧(f, ¬p)</code>, and in order to access this composition with any newly defined subtype of <code>Formula</code>, a new method for <code>composeformulas</code> should be defined, together with promotion from/to other <code>Formula</code>s should be taken care of (see <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">here</a> and <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">here</a>).</p><p>Similarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective <code>c</code>, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as <code>∧(f, f2, f3, ...)</code> and <code>∨(f, f2, f3, ...)</code> can be done thanks to the following two methods that were defined in SoleLogics:</p><pre><code class="nohighlight hljs">function ∧(
    c1::Formula,
    c2::Formula,
    c3::Formula,
    cs::Formula...
)
    return ∧(c1, ∧(c2, c3, cs...))
end
function ∨(
    c1::Formula,
    c2::Formula,
    c3::Formula,
    cs::Formula...
)
    return ∨(c1, ∨(c2, c3, cs...))
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>To allow for the composition of <code>Formula</code>s of different types, promotion rules should be provided.</p><p>See also <a href="../autodocs/#SoleLogics.Formula"><code>Formula</code></a>, <a href="../autodocs/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L236-L306">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>tokens(::Formula)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.height-Tuple{SyntaxBranch}" href="#SoleLogics.height-Tuple{SyntaxBranch}"><code>SoleLogics.height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">height(φ::Formula)::Integer</code></pre><p>Return the height of a formula in its syntax tree representation.</p><p>See also <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L166-L172">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SoleLogics.tree(::Formula)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Parsing-and-Printing"><a class="docs-heading-anchor" href="#Parsing-and-Printing">Parsing &amp; Printing</a><a id="Parsing-and-Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-and-Printing" title="Permalink"></a></h3><p>SoleLogics.jl allows you to: </p><ul><li>Extract the string representation of a formula (via <code>syntaxstring</code>);</li><li>Parse formulas from strings (via <code>parseformula</code>).</li></ul><p>These features are highly customizable, and leverage three properties of syntactical tokens: <a href="../autodocs/#SoleLogics.arity-Tuple{AbstractRelation}"><code>arity</code></a>, connective <a href="#SoleLogics.precedence"><code>precedence</code></a> and connective <a href="#SoleLogics.associativity"><code>associativity</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.syntaxstring" href="#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">syntaxstring(s::Syntactical; kwargs...)::String</code></pre><p>Return the string representation of any syntactic object (e.g., <code>Formula</code>, <code>SyntaxTree</code>, <code>SyntaxToken</code>, <code>Atom</code>, <code>Truth</code>, etc). Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leaves of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(∧(∧(∧(p, q), r), s), t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="#SoleLogics.parseformula"><code>parseformula</code></a>, <a href="../autodocs/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="../autodocs/#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including <code>kwargs...</code>) for every newly defined <code>SyntaxToken</code> (e.g., <code>SyntaxLeaf</code>s, that is, <code>Atom</code>s and <code>Truth</code> values, and <code>Operator</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxBranch</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)</code></pre><p>The <code>syntaxstring</code> for any value defaults to its <code>string</code> representation, but it can be defined by defining the appropriate <code>syntaxstring</code> method.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>).</p></div></div><p>See also <a href="../autodocs/#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="../autodocs/#SoleLogics.Operator"><code>Operator</code></a>, <a href="#SoleLogics.parseformula"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/core.jl#L49-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.parseformula" href="#SoleLogics.parseformula"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parseformula(expr::String, additional_operators = nothing; kwargs...)
parseformula(F::Type{&lt;:Formula}, expr::String, additional_operators = nothing; kwargs...)</code></pre><p>Parse a formula of type <code>F</code> from a string expression (its <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>). When <code>F</code> is not specified, it defaults to <code>SyntaxTree</code>.</p><p>By default, this function is only able to parse operators in <a href="../autodocs/#SoleLogics.BASE_PARSABLE_OPERATORS"><code>SoleLogics.BASE_PARSABLE_OPERATORS</code></a> (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector <code>additional_operators</code>, and their <code>syntaxstring</code>&#39;s will be used for parsing them. Note that, in case of clashing <code>syntaxstring</code>&#39;s, the provided additional operators will override the standard ones.</p><p>When parsing <code>SyntaxTree</code>s, the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm is used, and the method allows the following keywords arguments.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g., <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g., <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces::Vector{Char} = Char[]</code>: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis::String = &quot;(&quot;</code>:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis::String = &quot;)&quot;</code>:   the string signaling the closing of an expression block;</li><li><code>arg_delim::String = &quot;,&quot;</code>:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>For any <code>Formula</code> type <code>F</code>, this function should be the inverse of <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>; that is, if <code>φ::F</code> then the following should hold, for at least some <code>args</code>, and for every <code>kwargs</code> allowing correct parsing: <code>φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...)</code>.</p><p>See also <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="../autodocs/#SoleLogics.BASE_PARSABLE_OPERATORS"><code>BASE_PARSABLE_OPERATORS</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/parse.jl#L35-L102">source</a></section></article><h3 id="Grammar"><a class="docs-heading-anchor" href="#Grammar">Grammar</a><a id="Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Grammar" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractAlphabet</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SoleLogics.jl offers the possibility to implement a custom <a href="../autodocs/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> concrete type. To see an in-depth example, please refer to section <a href="#customization-section">Customization</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>atoms(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.in(p::Atom, a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.length(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.iterate(a::AbstractAlphabet)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ExplicitAlphabet</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphabetOfAny</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractGrammar</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}" href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{A} where A}"><code>SoleLogics.alphabet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alphabet(g::AbstractGrammar{V} where {V})::V</code></pre><p>Return the propositional alphabet of a grammar.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/logics.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{SyntaxBranch, SoleLogics.AbstractGrammar}" href="#Base.in-Tuple{SyntaxBranch, SoleLogics.AbstractGrammar}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool</code></pre><p>Return whether a <code>SyntaxTree</code>, belongs to a grammar.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../autodocs/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/logics.jl#L239-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}" href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::AbstractGrammar;
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing,
    args...
)::Vector{&lt;:SyntaxBranch}</code></pre><p>Enumerate the formulas produced by a given grammar with a finite and iterable alphabet.</p><p><strong>Implementation</strong></p><p>Additional <code>args</code> can be used to model the function&#39;s behavior. At least these two arguments should be covered:</p><ul><li>a <code>nformulas</code> argument can be used to limit the size of the returned <code>Vector</code>;</li><li>a <code>maxdepth</code> argument can be used to limit the syntactic component, represented as a syntax tree,</li></ul><p>to a given maximum depth;</p><p>See also <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../autodocs/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/logics.jl#L260-L279">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CompleteFlatGrammar{A&lt;:AbstractAlphabet,O&lt;:Operator}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}" href="#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{A, O} where {A, O}}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulas(
    g::CompleteFlatGrammar{V,O} where {V,O};
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing
)::Vector{SyntaxBranch}</code></pre><p>Generate all formulas whose <code>SyntaxBranch</code>s that are not taller than a given <code>maxdepth</code>.</p><p>See also <a href="../autodocs/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../autodocs/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/8d266db6647bb73877991a57396ee32d11c1b02c/src/logics.jl#L399-L409">source</a></section></article><h2 id="Semantics"><a class="docs-heading-anchor" href="#Semantics">Semantics</a><a id="Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Semantics" title="Permalink"></a></h2><h2 id="customization-section"><a class="docs-heading-anchor" href="#customization-section">Customization</a><a id="customization-section-1"></a><a class="docs-heading-anchor-permalink" href="#customization-section" title="Permalink"></a></h2><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc justo justo, finibus ac odio in, tempor fermentum augue. Vivamus ullamcorper lacus eget enim imperdiet, ac lobortis turpis elementum. Fusce non auctor eros. Duis scelerisque auctor volutpat. Morbi non luctus est. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Pellentesque porttitor a est sit amet ornare. Aliquam faucibus fringilla imperdiet.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../propositional-logic/">Propositional logic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 9 November 2023 03:34">Thursday 9 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
